# Spec: E10-F06-T02 - Result Persistence Repository

---
# ============================================================================
# SPEC METADATA
# ============================================================================

# === IDENTIFICATION ===
id: E10-F06-T02
clickup_task_id: '86ew0fu0n'
title: Create IBacktestResultRepository and DuckDB Implementation
type: task

# === HIERARCHY ===
parent: E10-F06
children: []
epic: E10
feature: F06
task: T02
domain: backtesting

# === WORKFLOW ===
status: draft
priority: high

# === TRACKING ===
created: '2025-12-30'
updated: '2025-12-30'
due_date: ''
estimated_hours: 6
actual_hours: 0

# === METADATA ===
tags: [repository, persistence, duckdb, serialization]
effort: medium
risk: medium
---

**Status**: Draft
**Type**: Task
**Parent**: [E10-F06 - Export and Persistence](../E10-F06.spec.md)
**Created**: 2025-12-30
**Updated**: 2025-12-30

## Executive Summary

Create `IBacktestResultRepository` interface and `DuckDBBacktestResultRepository` implementation for persisting backtest results. The repository stores complete backtest results as JSON-serialized fields in DuckDB, supporting save, retrieve, list with filters, and delete operations. Includes serialization/deserialization logic for all domain objects to ensure data integrity through roundtrips.

## Execution Flow

```
1. Initialize DuckDBBacktestResultRepository
   -> Receive DuckDB connection
   -> Call _ensure_tables() to create schema
   -> Return: Ready repository instance

2. Save Result (save)
   -> Serialize config to JSON
   -> Serialize metrics to JSON
   -> Serialize equity_curve to JSON array
   -> Serialize trades to JSON array
   -> Serialize daily_returns to JSON array
   -> INSERT into backtest_results table
   -> Return: result.id

3. Get Result (get)
   -> SELECT by result_id
   -> If not found: Return None
   -> Deserialize config JSON -> BacktestConfig
   -> Deserialize metrics JSON -> PerformanceMetrics
   -> Deserialize equity_curve JSON -> list[EquityPoint]
   -> Deserialize trades JSON -> list[Trade]
   -> Deserialize daily_returns JSON -> list[DailyReturn]
   -> Return: BacktestResult

4. List Results (list)
   -> Build query with optional filters
   -> Apply strategy_id filter (if provided)
   -> Apply date range filters (if provided)
   -> ORDER BY created_at DESC
   -> LIMIT results
   -> Convert to BacktestResultSummary objects
   -> Return: list[BacktestResultSummary]

5. Delete Result (delete)
   -> DELETE by result_id
   -> Return: True if deleted, False if not found
```

## User Stories

### Primary User Story
**As a** trader
**I want to** save and retrieve backtest results
**So that** I can compare strategies over time

### Additional Stories
- **As a** quant analyst, **I want to** list historical backtests, **So that** I can filter and compare results
- **As a** developer, **I want to** a clean repository interface, **So that** I can swap implementations

## Acceptance Scenarios

### Scenario 1: Save and Retrieve
**Given** a complete BacktestResult object
**When** calling save() then get()
**Then** retrieved result equals original (roundtrip integrity)

### Scenario 2: Result Not Found
**Given** non-existent result_id
**When** calling get()
**Then** returns None

### Scenario 3: List with Filters
**Given** multiple saved results
**When** calling list(start_date, end_date, limit)
**Then** returns filtered summaries ordered by created_at DESC

### Scenario 4: Delete Result
**Given** existing result
**When** calling delete()
**Then** returns True and result no longer retrievable

### Scenario 5: Decimal Precision
**Given** result with precise Decimal values
**When** roundtrip save/get
**Then** Decimal precision preserved exactly

### Scenario 6: Enum Roundtrip
**Given** trades with TradeSide and ExitReason enums
**When** roundtrip save/get
**Then** enum values correctly restored

## Requirements

### Functional Requirements
- **FR-001**: IBacktestResultRepository MUST define save, get, list, delete methods
- **FR-002**: save() MUST persist all BacktestResult fields
- **FR-003**: get() MUST return fully reconstructed BacktestResult or None
- **FR-004**: list() MUST support strategy_id, start_date, end_date, limit filters
- **FR-005**: list() MUST return BacktestResultSummary (lightweight)
- **FR-006**: delete() MUST return boolean success indicator
- **FR-007**: MUST preserve Decimal precision through serialization
- **FR-008**: MUST preserve datetime/date values through serialization
- **FR-009**: MUST preserve enum values through serialization

### Non-Functional Requirements
- **NFR-001**: Save 1000-trade result in < 500ms
- **NFR-002**: List 100 results in < 100ms
- **NFR-003**: Get single result in < 50ms

### Technical Constraints
- **TC-001**: Use DuckDB from E02 Storage Layer
- **TC-002**: Store complex objects as JSON columns
- **TC-003**: Use repository pattern with interface

## Key Entities

### Interface: IBacktestResultRepository
```python
from abc import ABC, abstractmethod
from datetime import date
from typing import Optional

class IBacktestResultRepository(ABC):
    """Repository interface for backtest results"""

    @abstractmethod
    async def save(self, result: BacktestResult) -> str:
        """
        Save result and return ID.

        Persists all fields including:
        - config, metrics, equity_curve, trades, daily_returns
        """
        pass

    @abstractmethod
    async def get(self, result_id: str) -> Optional[BacktestResult]:
        """
        Get result by ID.

        Returns fully reconstructed BacktestResult or None.
        """
        pass

    @abstractmethod
    async def list(
        self,
        strategy_id: Optional[str] = None,
        start_date: Optional[date] = None,
        end_date: Optional[date] = None,
        limit: int = 100
    ) -> list[BacktestResultSummary]:
        """
        List results with optional filters.

        Returns lightweight summaries, not full results.
        Ordered by created_at DESC.
        """
        pass

    @abstractmethod
    async def delete(self, result_id: str) -> bool:
        """
        Delete result by ID.

        Returns True if deleted, False if not found.
        """
        pass
```

### Class: BacktestResultSummary
```python
from dataclasses import dataclass
from datetime import datetime

@dataclass
class BacktestResultSummary:
    """Lightweight summary for result listing"""
    id: str
    strategy_name: str
    total_return_pct: float
    sharpe_ratio: float
    max_drawdown_pct: float
    total_trades: int
    created_at: datetime
```

### Class: DuckDBBacktestResultRepository
```python
import duckdb
import json
from typing import Any

class DuckDBBacktestResultRepository(IBacktestResultRepository):
    """DuckDB implementation of backtest result repository"""

    def __init__(self, connection: duckdb.DuckDBPyConnection):
        self._conn = connection
        self._ensure_tables()

    def _ensure_tables(self) -> None:
        """Create tables if not exist"""
        self._conn.execute("""
            CREATE TABLE IF NOT EXISTS backtest_results (
                id VARCHAR PRIMARY KEY,
                config_json TEXT,
                metrics_json TEXT,
                equity_curve_json TEXT,
                trades_json TEXT,
                daily_returns_json TEXT,
                execution_time_ms DOUBLE,
                created_at TIMESTAMP
            )
        """)

    # Serialization helpers
    def _serialize_config(self, config: BacktestConfig) -> str: ...
    def _serialize_metrics(self, metrics: PerformanceMetrics) -> str: ...
    def _serialize_equity_curve(self, curve: list[EquityPoint]) -> str: ...
    def _serialize_trades(self, trades: list[Trade]) -> str: ...
    def _serialize_daily_returns(self, returns: list[DailyReturn]) -> str: ...

    # Deserialization helpers
    def _deserialize_config(self, json_str: str) -> BacktestConfig: ...
    def _deserialize_metrics(self, json_str: str) -> PerformanceMetrics: ...
    def _deserialize_equity_curve(self, json_str: str) -> list[EquityPoint]: ...
    def _deserialize_trades(self, json_str: str) -> list[Trade]: ...
    def _deserialize_daily_returns(self, json_str: str) -> list[DailyReturn]: ...

    def _deserialize_result(self, row: tuple) -> BacktestResult: ...
    def _to_summary(self, row: tuple) -> BacktestResultSummary: ...
```

### Database Schema
```sql
CREATE TABLE IF NOT EXISTS backtest_results (
    id VARCHAR PRIMARY KEY,
    config_json TEXT,           -- Serialized BacktestConfig
    metrics_json TEXT,          -- Serialized PerformanceMetrics
    equity_curve_json TEXT,     -- Serialized list[EquityPoint]
    trades_json TEXT,           -- Serialized list[Trade]
    daily_returns_json TEXT,    -- Serialized list[DailyReturn]
    execution_time_ms DOUBLE,
    created_at TIMESTAMP
);

-- Index for listing queries
CREATE INDEX IF NOT EXISTS idx_backtest_results_created
ON backtest_results(created_at DESC);
```

### Serialization Format Example
```json
// config_json
{
    "strategy_id": "rsi-momentum-v1",
    "strategy_name": "RSI Momentum Strategy",
    "symbols": ["005930", "000660"],
    "start_date": "2024-01-01",
    "end_date": "2024-12-31",
    "initial_capital": "100000000",
    "commission_pct": 0.015,
    "slippage_pct": 0.05,
    "timeframe": "1d"
}

// trades_json (array)
[
    {
        "id": "trade-001",
        "symbol": "005930",
        "symbol_name": "Samsung Electronics",
        "side": "LONG",
        "entry_date": "2024-01-15",
        "entry_price": "72000",
        "entry_quantity": 100,
        "exit_date": "2024-01-18",
        "exit_price": "75600",
        "exit_reason": "TAKE_PROFIT",
        "pnl": "360000",
        "pnl_pct": 5.0,
        "holding_days": 3,
        "commission": "2160",
        "slippage": "1800"
    }
]
```

## Dependencies

### Upstream Dependencies
- [ ] E10-F01: BacktestResult, Trade, PerformanceMetrics, EquityPoint, DailyReturn
- [ ] E02: DuckDB connection and infrastructure

### Downstream Impact
- [ ] Used by E10-F05 UI Components for loading saved results
- [ ] Used by comparison/analysis workflows

## Gate Checks

### Pre-Implementation Gates
- [x] E10-F01 domain models defined
- [x] E02 DuckDB infrastructure available
- [x] Serialization format documented

### Quality Gates
- [ ] Unit tests with in-memory DuckDB
- [ ] Roundtrip serialization tests for all types
- [ ] Filter and pagination tests
- [ ] Test coverage > 90%

## Success Criteria

### Acceptance Criteria
- [ ] Repository interface complete with all methods
- [ ] DuckDB implementation saves all fields
- [ ] Get returns fully reconstructed result
- [ ] List returns summaries with filters working
- [ ] Delete works correctly
- [ ] Decimal precision preserved
- [ ] Enum values roundtrip correctly

### Definition of Done
- [ ] Code reviewed
- [ ] Unit tests passing
- [ ] Integration tests with DuckDB passing
- [ ] Documentation complete

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| JSON serialization precision loss | Medium | High | Use string for Decimal |
| Large result serialization slow | Low | Medium | Optimize JSON encoding |
| Schema migration needed | Low | Medium | Version schema, add migrations |
| Query performance on large datasets | Low | Medium | Add appropriate indexes |

## Artifacts

### Output Artifacts
- [ ] `libs/core/src/backtesting/repository/__init__.py`
- [ ] `libs/core/src/backtesting/repository/interface.py`
- [ ] `libs/core/src/backtesting/repository/duckdb_impl.py`
- [ ] `libs/core/src/backtesting/repository/serializers.py`
- [ ] `libs/core/tests/backtesting/repository/test_interface.py`
- [ ] `libs/core/tests/backtesting/repository/test_duckdb_impl.py`
- [ ] `libs/core/tests/backtesting/repository/test_serializers.py`

---
*Template Version: 2.0.0 - Enhanced with Speckit features*
