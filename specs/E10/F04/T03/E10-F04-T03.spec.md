---
id: E10-F04-T03
clickup_task_id: '86ew0ftyb'
title: Trade Statistics and Calculator Orchestration
type: task
parent: E10-F04
children: []
epic: E10
feature: F04
task: T03
domain: backtesting
status: Draft
priority: High
dates:
  created: '2025-12-30'
  due: null
  started: null
  completed: null
hours:
  estimated: 6
  spent: 0
tags:
  - metrics
  - trade-statistics
  - profit-factor
  - orchestration
  - calculator
effort: M
risk: L
---

# Spec: E10-F04-T03 - Trade Statistics and Calculator Orchestration

**Status:** Draft | **Priority:** High | **Effort:** Medium | **Risk:** Low

---

## Executive Summary

Implement trade statistics calculations (win rate, profit factor, average win/loss, holding period) and the main `calculate()` orchestrator method that assembles all metrics into a PerformanceMetrics object. This task completes the MetricsCalculator by integrating T01 (return/risk-adjusted) and T02 (drawdown) calculations with trade-based statistics.

---

## Execution Flow

1. **Implement Trade Classification**: Categorize trades into winners and losers
2. **Implement Win Rate**: Calculate percentage of winning trades
3. **Implement Profit Factor**: Calculate gross profit / gross loss ratio
4. **Implement Average Win/Loss**: Calculate mean PnL percentage for winners/losers
5. **Implement Holding Period**: Calculate average days held per trade
6. **Implement calculate() Orchestrator**: Assemble all metrics into PerformanceMetrics
7. **Create Module Structure**: Set up `__init__.py` exports

---

## User Stories

- As a trader, I want win rate calculated so I can understand my strategy's success frequency.
- As a risk manager, I want profit factor so I can evaluate risk/reward efficiency.
- As a portfolio manager, I want average holding days so I can understand capital turnover.
- As a developer, I want a single calculate() entry point that returns all metrics.

---

## Acceptance Scenarios

| Scenario | Given | When | Then |
|----------|-------|------|------|
| Win rate calculation | 60 winners out of 100 trades | `win_rate` calculated | Returns 60.0 |
| Profit factor | Gross profit 10M, Gross loss 5M | `_calc_profit_factor()` | Returns 2.0 |
| Profit factor all winners | 10 winning trades, 0 losing | `_calc_profit_factor()` | Returns float('inf') |
| Profit factor all losers | 0 winning, 10 losing | `_calc_profit_factor()` | Returns 0.0 |
| No trades | Empty trades list | `calculate()` | Returns zeroed PerformanceMetrics |
| Average holding | Trades with 5, 10, 15 days | `_calc_avg_holding()` | Returns 10.0 |
| Full calculation | Complete backtest data | `calculate()` | Returns valid PerformanceMetrics |

---

## Requirements

### Functional Requirements
- **FR-001**: `_calc_profit_factor(winners, losers)` MUST return gross_profit / gross_loss
- **FR-002**: `_calc_avg_pnl(trades)` MUST return mean of pnl_pct values
- **FR-003**: `_calc_avg_holding(trades)` MUST return mean holding_days
- **FR-004**: `calculate()` MUST return complete PerformanceMetrics object
- **FR-005**: `calculate()` MUST handle empty trades, equity_curve, daily_returns
- **FR-006**: Trade classification MUST use Trade.is_winner property
- **FR-007**: Largest win/loss MUST use pnl_pct field

### Non-Functional Requirements
- **NFR-001**: All percentages as float values
- **NFR-002**: Profit factor returns float('inf') for no losses, 0.0 for no profits
- **NFR-003**: Type hints on all public and private methods
- **NFR-004**: Single responsibility for each helper method

### Technical Constraints
- **TC-001**: Use Trade.is_winner property for winner detection
- **TC-002**: Use Trade.pnl for absolute P&L, Trade.pnl_pct for percentage
- **TC-003**: Final Decimal values from EquityPoint for final_equity, final_cash

---

## Key Entities

### MetricsCalculator Class (Complete)

```python
class MetricsCalculator:
    """Calculate comprehensive performance metrics from backtest results"""

    def calculate(
        self,
        trades: list[Trade],
        equity_curve: list[EquityPoint],
        daily_returns: list[DailyReturn],
        initial_capital: Decimal
    ) -> PerformanceMetrics:
        """Calculate all metrics from backtest data

        Main entry point that orchestrates all metric calculations.

        Args:
            trades: List of completed trades
            equity_curve: Daily equity point series
            daily_returns: Daily return percentages
            initial_capital: Starting capital amount

        Returns:
            PerformanceMetrics with all calculated values
        """
        # Categorize trades
        winners = [t for t in trades if t.is_winner]
        losers = [t for t in trades if t.pnl and t.pnl < 0]

        # Calculate returns (from T01)
        final_equity = equity_curve[-1].equity if equity_curve else initial_capital
        total_return = self._calc_total_return(initial_capital, final_equity)
        cagr = self._calc_cagr(initial_capital, final_equity, len(equity_curve))

        # Calculate risk metrics (from T01)
        returns = [d.return_pct for d in daily_returns]
        sharpe = self._calc_sharpe(returns)
        sortino = self._calc_sortino(returns)

        # Calculate drawdown (from T02)
        max_dd = self._calc_max_drawdown(equity_curve)
        avg_dd = self._calc_avg_drawdown(equity_curve)
        dd_duration = self._calc_dd_duration(equity_curve)

        # Calmar ratio (T01 helper with T02 result)
        calmar = cagr / abs(max_dd) if max_dd != 0 else 0.0

        # Trade statistics (this task)
        win_rate = len(winners) / len(trades) * 100 if trades else 0.0
        profit_factor = self._calc_profit_factor(winners, losers)

        return PerformanceMetrics(
            total_return_pct=total_return,
            cagr=cagr,
            sharpe_ratio=sharpe,
            sortino_ratio=sortino,
            calmar_ratio=calmar,
            max_drawdown_pct=max_dd,
            avg_drawdown_pct=avg_dd,
            max_drawdown_duration_days=dd_duration,
            total_trades=len(trades),
            winning_trades=len(winners),
            losing_trades=len(losers),
            win_rate=win_rate,
            profit_factor=profit_factor,
            avg_win=self._calc_avg_pnl(winners),
            avg_loss=self._calc_avg_pnl(losers),
            largest_win=max((t.pnl_pct or 0) for t in trades) if trades else 0.0,
            largest_loss=min((t.pnl_pct or 0) for t in trades) if trades else 0.0,
            avg_holding_days=self._calc_avg_holding(trades),
            final_equity=final_equity,
            final_cash=equity_curve[-1].cash if equity_curve else initial_capital
        )

    def _calc_profit_factor(
        self,
        winners: list[Trade],
        losers: list[Trade]
    ) -> float:
        """Calculate profit factor (gross profit / gross loss)

        Args:
            winners: List of winning trades
            losers: List of losing trades

        Returns:
            Ratio of gross profits to gross losses.
            Returns float('inf') if no losses, 0.0 if no profits.
        """
        gross_profit = sum(t.pnl for t in winners if t.pnl) or Decimal(0)
        gross_loss = abs(sum(t.pnl for t in losers if t.pnl)) or Decimal(0)

        if gross_loss == 0:
            return float('inf') if gross_profit > 0 else 0.0

        return float(gross_profit / gross_loss)

    def _calc_avg_pnl(self, trades: list[Trade]) -> float:
        """Calculate average P&L percentage for a group of trades

        Args:
            trades: List of trades (typically winners or losers)

        Returns:
            Mean pnl_pct value, or 0.0 if no trades
        """
        if not trades:
            return 0.0

        pnl_values = [t.pnl_pct for t in trades if t.pnl_pct is not None]
        if not pnl_values:
            return 0.0

        return float(np.mean(pnl_values))

    def _calc_avg_holding(self, trades: list[Trade]) -> float:
        """Calculate average holding period in days

        Args:
            trades: List of completed trades

        Returns:
            Mean holding_days value, or 0.0 if no trades
        """
        if not trades:
            return 0.0

        holding_days = [t.holding_days for t in trades if t.holding_days is not None]
        if not holding_days:
            return 0.0

        return float(np.mean(holding_days))

    # Methods from T01 (return and risk-adjusted metrics)
    def _calc_total_return(self, initial_capital: Decimal, final_equity: Decimal) -> float: ...
    def _calc_cagr(self, initial_capital: Decimal, final_equity: Decimal, trading_days: int) -> float: ...
    def _calc_sharpe(self, returns: list[float]) -> float: ...
    def _calc_sortino(self, returns: list[float]) -> float: ...

    # Methods from T02 (drawdown analysis)
    def _calc_max_drawdown(self, equity_curve: list[EquityPoint]) -> float: ...
    def _calc_avg_drawdown(self, equity_curve: list[EquityPoint]) -> float: ...
    def _calc_dd_duration(self, equity_curve: list[EquityPoint]) -> int: ...
```

### Module Structure

```
libs/core/src/backtesting/metrics/
├── __init__.py          # Export MetricsCalculator
└── calculator.py        # MetricsCalculator class
```

### `__init__.py` Contents

```python
"""Metrics calculation module for backtesting"""

from .calculator import MetricsCalculator

__all__ = ["MetricsCalculator"]
```

---

## Dependencies

### Upstream Dependencies
- **E10-F04-T01**: Return and risk-adjusted metric methods
- **E10-F04-T02**: Drawdown analysis methods
- **E10-F01**: Domain Models (Trade, EquityPoint, DailyReturn, PerformanceMetrics)
- **numpy**: For mean calculations

### Downstream Impact
- **E10-F02**: BacktestEngine uses MetricsCalculator
- **E10-F05**: UI displays all calculated metrics

---

## Gate Checks

### Pre-Implementation Gates
- [ ] E10-F04-T01 complete (return/risk methods)
- [ ] E10-F04-T02 complete (drawdown methods)
- [x] E10-F01 domain models defined

### Quality Gates
- [ ] Unit tests for each trade statistic method
- [ ] Integration test for full calculate() flow
- [ ] Edge case tests (no trades, all winners, all losers)
- [ ] Test coverage > 90%

---

## Success Criteria

### Acceptance Criteria
- [ ] Win rate calculates correctly as percentage
- [ ] Profit factor handles edge cases (no wins, no losses)
- [ ] Average win/loss uses pnl_pct correctly
- [ ] Holding period averages correctly
- [ ] calculate() returns valid PerformanceMetrics for all scenarios
- [ ] Module exports MetricsCalculator correctly

### Definition of Done
- [ ] Code reviewed and approved
- [ ] Unit tests passing with > 90% coverage
- [ ] Integration tests with BacktestEngine
- [ ] Module structure and exports verified

---

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| None handling in Trade fields | Medium | Medium | Defensive None checks in all methods |
| Division by zero in win_rate | Low | Low | Check len(trades) before division |
| Integration issues with T01/T02 | Low | Medium | Unit test individual methods first |

---

## Artifacts

### Output Artifacts
- [ ] `libs/core/src/backtesting/metrics/calculator.py` (complete class)
- [ ] `libs/core/src/backtesting/metrics/__init__.py`
- [ ] `tests/unit/backtesting/metrics/test_trade_statistics.py`
- [ ] `tests/unit/backtesting/metrics/test_calculator_integration.py`

### Test Data
```python
# Test trade fixtures
def create_test_trades():
    """Create trades for testing statistics"""
    from decimal import Decimal
    from datetime import date

    return [
        Trade(
            id="1", symbol="005930", symbol_name="Samsung",
            side=TradeSide.LONG,
            entry_date=date(2024, 1, 2), entry_price=Decimal("70000"),
            entry_quantity=100,
            exit_date=date(2024, 1, 10), exit_price=Decimal("73500"),
            exit_reason=ExitReason.SIGNAL,
            pnl=Decimal("350000"), pnl_pct=5.0,
            holding_days=8,
            commission=Decimal("1050"), slippage=Decimal("350")
        ),
        Trade(
            id="2", symbol="000660", symbol_name="SK Hynix",
            side=TradeSide.LONG,
            entry_date=date(2024, 1, 15), entry_price=Decimal("130000"),
            entry_quantity=50,
            exit_date=date(2024, 1, 18), exit_price=Decimal("126100"),
            exit_reason=ExitReason.STOP_LOSS,
            pnl=Decimal("-195000"), pnl_pct=-3.0,
            holding_days=3,
            commission=Decimal("975"), slippage=Decimal("325")
        ),
        # Add more test trades...
    ]

test_cases = {
    "profit_factor": {
        "winners": [create_winner_trade(pnl=Decimal("100000"))],
        "losers": [create_loser_trade(pnl=Decimal("-50000"))],
        "expected": 2.0
    },
    "win_rate": {
        "total_trades": 10,
        "winners": 6,
        "expected": 60.0
    }
}
```

---

## Notes and Clarifications

- Trade.is_winner property returns True if pnl > 0
- Trade.pnl is absolute P&L in currency, pnl_pct is percentage return
- Profit factor > 1.0 indicates profitable strategy
- Win rate alone is insufficient - consider with profit factor
- The calculate() method is the single public entry point for all metrics

---

## References

- PRD Section 5.5.2: Performance Metrics
- E10-F04.spec.md Section 2.4: Trade Statistics
- E10-F04.spec.md Section 3.1: MetricsCalculator Class
- [Profit Factor - Investopedia](https://www.investopedia.com/terms/p/profitfactor.asp)

---

*Template Version: 2.0.0 - Enhanced with Speckit features*
