---
id: E10-F04-T01
clickup_task_id: '86ew0ftxe'
title: Return and Risk-Adjusted Metrics Calculation
type: task
parent: E10-F04
children: []
epic: E10
feature: F04
task: T01
domain: backtesting
status: Draft
priority: High
dates:
  created: '2025-12-30'
  due: null
  started: null
  completed: null
hours:
  estimated: 6
  spent: 0
tags:
  - metrics
  - sharpe-ratio
  - sortino-ratio
  - risk-adjusted
  - cagr
effort: M
risk: L
---

# Spec: E10-F04-T01 - Return and Risk-Adjusted Metrics Calculation

**Status:** Draft | **Priority:** High | **Effort:** Medium | **Risk:** Low

---

## Executive Summary

Implement the return metrics (total return, CAGR) and risk-adjusted ratio calculations (Sharpe, Sortino, Calmar) for the MetricsCalculator. These are the core statistical calculations that evaluate strategy performance on a risk-adjusted basis. All calculations use annualized values with 252 trading days per year.

---

## Execution Flow

1. **Initialize Helper Methods**: Create private calculation methods with proper edge case handling
2. **Implement Total Return**: Calculate percentage return from initial to final capital
3. **Implement CAGR**: Calculate compound annual growth rate handling fractional years
4. **Implement Sharpe Ratio**: Annualized risk-adjusted return using total volatility
5. **Implement Sortino Ratio**: Risk-adjusted return using only downside deviation
6. **Implement Calmar Ratio Helper**: Return CAGR / |max_drawdown| (uses T02 drawdown result)

---

## User Stories

- As a quantitative analyst, I want Sharpe ratio calculated correctly so I can compare strategy performance against industry benchmarks.
- As a trader, I want Sortino ratio so I can understand downside risk separately from overall volatility.
- As a portfolio manager, I want CAGR so I can understand annualized returns for different backtest periods.
- As a developer, I want all edge cases handled so the calculator never throws division-by-zero errors.

---

## Acceptance Scenarios

| Scenario | Given | When | Then |
|----------|-------|------|------|
| Total return calculation | Initial: 100M, Final: 145M | `_calc_total_return()` called | Returns 45.0 (percentage) |
| CAGR for 1 year | Initial: 100M, Final: 120M, 252 days | `_calc_cagr()` called | Returns ~20.0% |
| CAGR for 6 months | Initial: 100M, Final: 110M, 126 days | `_calc_cagr()` called | Returns ~21.6% (annualized) |
| Sharpe with positive returns | Daily returns avg 0.05%, std 1% | `_calc_sharpe()` called | Returns ~0.79 (annualized) |
| Sharpe with zero std | All returns identical | `_calc_sharpe()` called | Returns 0.0 (not infinity) |
| Sortino with no negative returns | All returns >= 0 | `_calc_sortino()` called | Returns float('inf') if avg > 0 |
| Sortino with mixed returns | Mix of positive and negative | `_calc_sortino()` called | Returns valid ratio |
| Empty returns list | Empty daily_returns | Any calculation | Returns 0.0 gracefully |

---

## Requirements

### Functional Requirements
- **FR-001**: `_calc_total_return(initial, final)` MUST return percentage ((final-initial)/initial * 100)
- **FR-002**: `_calc_cagr(initial, final, trading_days)` MUST annualize using 252 days/year
- **FR-003**: `_calc_sharpe(returns)` MUST use sample std dev (ddof=1) and annualize by sqrt(252)
- **FR-004**: `_calc_sortino(returns)` MUST use only negative returns for downside deviation
- **FR-005**: All methods MUST handle empty inputs gracefully (return 0.0)
- **FR-006**: All methods MUST handle zero denominators (return 0.0 or appropriate value)

### Non-Functional Requirements
- **NFR-001**: Risk-free rate assumed 0% (standard for Korean market backtests)
- **NFR-002**: All output values as Python float type
- **NFR-003**: Use numpy for statistical calculations
- **NFR-004**: Type hints on all methods

### Technical Constraints
- **TC-001**: Use 252 trading days for annualization
- **TC-002**: Use sample standard deviation (ddof=1)
- **TC-003**: Depend only on E10-F01 domain models and numpy

---

## Key Entities

### Methods to Implement

```python
class MetricsCalculator:
    """Return and risk-adjusted metric calculations"""

    def _calc_total_return(
        self,
        initial_capital: Decimal,
        final_equity: Decimal
    ) -> float:
        """Calculate total return percentage"""
        if initial_capital == 0:
            return 0.0
        return float((final_equity - initial_capital) / initial_capital) * 100

    def _calc_cagr(
        self,
        initial_capital: Decimal,
        final_equity: Decimal,
        trading_days: int
    ) -> float:
        """Calculate compound annual growth rate"""
        if initial_capital == 0 or trading_days == 0:
            return 0.0

        years = trading_days / 252
        ratio = float(final_equity / initial_capital)

        if ratio <= 0:
            return 0.0

        return (pow(ratio, 1 / years) - 1) * 100

    def _calc_sharpe(self, returns: list[float]) -> float:
        """Calculate annualized Sharpe ratio (risk-free rate = 0)"""
        if not returns or len(returns) < 2:
            return 0.0

        avg_return = np.mean(returns)
        std_return = np.std(returns, ddof=1)  # Sample std dev

        if std_return == 0:
            return 0.0

        # Annualize: multiply avg by 252, std by sqrt(252)
        annualized_return = avg_return * 252
        annualized_std = std_return * np.sqrt(252)

        return annualized_return / annualized_std

    def _calc_sortino(self, returns: list[float]) -> float:
        """Calculate Sortino ratio (downside deviation only)"""
        if not returns or len(returns) < 2:
            return 0.0

        avg_return = np.mean(returns)

        # Only negative returns for downside deviation
        negative_returns = [r for r in returns if r < 0]
        if not negative_returns:
            return float('inf') if avg_return > 0 else 0.0

        downside_std = np.std(negative_returns, ddof=1)

        if downside_std == 0:
            return 0.0

        annualized_return = avg_return * 252
        annualized_downside = downside_std * np.sqrt(252)

        return annualized_return / annualized_downside
```

### Mathematical Formulas

| Metric | Formula | Annualization |
|--------|---------|---------------|
| Total Return | `(final - initial) / initial * 100` | N/A |
| CAGR | `(final/initial)^(252/days) - 1) * 100` | Built-in |
| Sharpe | `(avg_daily * 252) / (std_daily * sqrt(252))` | 252 days |
| Sortino | `(avg_daily * 252) / (downside_std * sqrt(252))` | 252 days |

---

## Dependencies

### Upstream Dependencies
- **E10-F01**: Domain Models (DailyReturn, EquityPoint types)
- **numpy**: Statistical calculations (mean, std)

### Downstream Impact
- **E10-F04-T03**: Uses these methods in main `calculate()` orchestrator
- **E10-F05**: UI displays these metrics

---

## Gate Checks

### Pre-Implementation Gates
- [x] E10-F01 domain models defined (DailyReturn, EquityPoint)
- [x] numpy available as dependency

### Quality Gates
- [ ] Unit tests for each calculation method
- [ ] Edge case tests (empty data, zero std, all positive/negative)
- [ ] Mathematical correctness validated against known values
- [ ] Test coverage > 90%

---

## Success Criteria

### Acceptance Criteria
- [ ] Total return calculates correctly for various scenarios
- [ ] CAGR handles fractional years correctly
- [ ] Sharpe ratio matches industry-standard calculations
- [ ] Sortino ratio uses only downside deviation
- [ ] All edge cases return valid numeric values (no exceptions)

### Definition of Done
- [ ] Code reviewed and approved
- [ ] Unit tests passing with > 90% coverage
- [ ] Mathematical validation against reference library (empyrical/quantstats)
- [ ] Documentation with formula references

---

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Annualization errors | Low | High | Cross-validate with quantstats library |
| Floating point precision | Low | Low | Use numpy for calculations |
| Edge case exceptions | Medium | Medium | Comprehensive edge case tests |

---

## Artifacts

### Output Artifacts
- [ ] `libs/core/src/backtesting/metrics/calculator.py` (partial - return/risk methods)
- [ ] `tests/unit/backtesting/metrics/test_return_metrics.py`
- [ ] `tests/unit/backtesting/metrics/test_risk_adjusted_metrics.py`

### Test Data
```python
# Known value test cases
test_cases = {
    "sharpe_positive": {
        "returns": [0.01, -0.005, 0.008, 0.002, -0.003] * 50,  # 250 days
        "expected_sharpe": approx(0.85, rel=0.1)  # Validate against empyrical
    },
    "cagr_one_year": {
        "initial": 100_000_000,
        "final": 120_000_000,
        "days": 252,
        "expected_cagr": 20.0
    }
}
```

---

## Notes and Clarifications

- Risk-free rate is 0% by design (standard for Korean market backtests per PRD)
- Sharpe ratio formula: `(R_p - R_f) / sigma_p` where R_f = 0
- Sortino improvement: Only penalizes downside volatility, better for asymmetric returns
- Calmar ratio calculation will use max_drawdown from T02, but helper method defined here

---

## References

- PRD Section 5.5.2: Performance Metrics
- [Sharpe Ratio - Wikipedia](https://en.wikipedia.org/wiki/Sharpe_ratio)
- [Sortino Ratio - Wikipedia](https://en.wikipedia.org/wiki/Sortino_ratio)
- E10-F04.spec.md Section 2.2: Risk-Adjusted Metrics

---

*Template Version: 2.0.0 - Enhanced with Speckit features*
