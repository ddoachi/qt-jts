# Task E10-F02-T01: Portfolio State Management

## Metadata

| Field | Value |
|-------|-------|
| Task ID | E10-F02-T01 |
| Title | Portfolio State Management |
| Feature | E10-F02 (Backtest Engine Core) |
| Epic | E10 (Backtesting) |
| Status | Draft |
| Effort | M |
| Risk | L |
| Dependencies | E10-F01 (TradeSide enum) |

---

## 1. Overview

### 1.1 Purpose

Implement the internal portfolio state management classes used during backtest simulation. This includes the mutable `Portfolio` class for tracking cash and positions, and the `Position` class representing an open position during simulation. These are internal implementation details of the backtest engine, distinct from the domain models in E10-F01.

### 1.2 Goals

1. **Position Tracking**: Track open positions with entry details
2. **Cash Management**: Track cash balance through trades
3. **Portfolio Operations**: Open, close, query positions
4. **Validation**: Ensure valid state transitions

---

## 2. Key Entities

### 2.1 Position (Internal)

```python
@dataclass
class Position:
    """Open position during backtest simulation (internal)"""
    symbol: str
    quantity: int
    entry_price: Decimal
    entry_date: date
    side: TradeSide  # From E10-F01

    def current_value(self, price: Decimal) -> Decimal:
        """Calculate position value at given price"""
        return price * self.quantity

    def unrealized_pnl(self, price: Decimal) -> Decimal:
        """Calculate unrealized P&L at given price"""
        return (price - self.entry_price) * self.quantity

    def unrealized_pnl_pct(self, price: Decimal) -> float:
        """Calculate unrealized P&L percentage"""
        if self.entry_price == 0:
            return 0.0
        return float((price - self.entry_price) / self.entry_price) * 100
```

### 2.2 Portfolio (Internal)

```python
class Portfolio:
    """Mutable portfolio state during backtest simulation"""

    def __init__(self, initial_capital: Decimal):
        self.cash: Decimal = initial_capital
        self.positions: dict[str, Position] = {}

    def has_position(self, symbol: str) -> bool:
        """Check if position exists for symbol"""
        return symbol in self.positions

    def get_position(self, symbol: str) -> Optional[Position]:
        """Get position for symbol, or None"""
        return self.positions.get(symbol)

    def open_position(
        self,
        symbol: str,
        price: Decimal,
        quantity: int,
        date: date,
        side: TradeSide,
        commission: Decimal
    ) -> Position:
        """Open new position, deduct cash"""
        trade_value = price * quantity
        self.cash -= (trade_value + commission)
        position = Position(
            symbol=symbol,
            quantity=quantity,
            entry_price=price,
            entry_date=date,
            side=side
        )
        self.positions[symbol] = position
        return position

    def close_position(
        self,
        symbol: str,
        exit_price: Decimal,
        commission: Decimal
    ) -> Decimal:
        """Close position, return P&L"""
        position = self.positions.pop(symbol)
        exit_value = exit_price * position.quantity
        pnl = exit_value - (position.entry_price * position.quantity)
        self.cash += (exit_value - commission)
        return pnl

    def total_positions_value(self, prices: dict[str, Decimal]) -> Decimal:
        """Calculate total value of all positions"""
        total = Decimal(0)
        for symbol, position in self.positions.items():
            if symbol in prices:
                total += position.current_value(prices[symbol])
        return total

    def total_equity(self, prices: dict[str, Decimal]) -> Decimal:
        """Calculate total portfolio equity"""
        return self.cash + self.total_positions_value(prices)
```

---

## 3. Acceptance Criteria

### 3.1 Position Class

- [ ] Position tracks symbol, quantity, entry_price, entry_date, side
- [ ] `current_value()` computes price * quantity
- [ ] `unrealized_pnl()` computes (price - entry_price) * quantity
- [ ] `unrealized_pnl_pct()` computes percentage return

### 3.2 Portfolio Class

- [ ] Portfolio initializes with cash = initial_capital
- [ ] Portfolio initializes with empty positions dict
- [ ] `has_position()` returns True/False correctly
- [ ] `get_position()` returns Position or None
- [ ] `open_position()` creates Position and deducts cash
- [ ] `close_position()` removes Position and adds cash
- [ ] `total_positions_value()` sums all position values
- [ ] `total_equity()` returns cash + positions value

### 3.3 Testing

- [ ] Unit tests for Position calculations
- [ ] Unit tests for Portfolio operations
- [ ] Edge case tests (zero quantity, zero price)
- [ ] Test coverage > 90%

---

## 4. Technical Notes

### 4.1 Design Decisions

| Decision | Choice | Reason |
|----------|--------|--------|
| Mutability | Mutable classes | Performance in hot simulation loop |
| Storage | Internal classes | Not exposed as domain models |
| Commission | Deducted on open/close | Accurate cost tracking |

### 4.2 Estimated LOC

- Position class: ~60 LOC
- Portfolio class: ~100 LOC
- Tests: ~150 LOC
- **Total: ~150-200 LOC (production code)**

### 4.3 Files to Create

- `libs/core/src/backtesting/engine/portfolio.py`
- `tests/unit/backtesting/engine/test_portfolio.py`

---

## 5. Dependencies

### 5.1 Upstream

| Dependency | Provides |
|------------|----------|
| E10-F01 | TradeSide enum |

### 5.2 Downstream

| Dependent | Uses |
|-----------|------|
| E10-F02-T02 | Portfolio, Position classes |
| E10-F02-T03 | Portfolio for simulation loop |
| E10-F02-T04 | Portfolio for equity calculation |

---

## 6. References

- E10-F02.spec.md Section 3.2: Portfolio State
- E10-F01: TradeSide enum
