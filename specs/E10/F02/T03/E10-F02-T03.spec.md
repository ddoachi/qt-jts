# Task E10-F02-T03: Simulation Loop Implementation

## Metadata

| Field | Value |
|-------|-------|
| Task ID | E10-F02-T03 |
| Title | Simulation Loop Implementation |
| Feature | E10-F02 (Backtest Engine Core) |
| Epic | E10 (Backtesting) |
| Status | Draft |
| Effort | L |
| Risk | M |
| Dependencies | E10-F02-T01, E10-F02-T02, E10-F03 (stub) |

---

## 1. Overview

### 1.1 Purpose

Implement the core simulation loop in the `BacktestEngine.run()` method. This is the heart of the backtesting engine that iterates through trading days, processes each symbol, coordinates with external services for signal evaluation, manages position entry/exit, and applies slippage and commission.

### 1.2 Goals

1. **Day-by-Day Iteration**: Process each trading day chronologically
2. **Exit Before Entry**: Check exits first to handle same-day reversals
3. **Cost Simulation**: Apply slippage and commission
4. **Position Closure**: Close remaining positions at backtest end

---

## 2. Simulation Flow

```
1. Initialize portfolio with initial_capital
2. Load all candle data via _load_data()
3. Get trading days via _get_trading_days()
4. For each trading day:
   a. For each symbol:
      - Get candle at current date
      - If position exists: check exit conditions
      - If exit signal: close position, record trade
      - If no position: check entry conditions
      - If entry signal: open position
   b. End of day: calculate equity, record equity point
   c. Call progress callback if provided
5. Close remaining positions with TIMEOUT reason
6. Build and return BacktestResult
```

---

## 3. Core Implementation

### 3.1 Main Loop

```python
async def run(
    self,
    config: BacktestConfig,
    progress_callback: Callable[[int, int], None] = None
) -> BacktestResult:
    start_time = time.perf_counter()

    portfolio = Portfolio(initial_capital=config.initial_capital)
    symbol_data = await self._load_data(config)
    trading_days = self._get_trading_days(config.start_date, config.end_date)
    total_days = len(trading_days)

    trades: list[Trade] = []
    equity_curve: list[EquityPoint] = []

    for day_idx, day in enumerate(trading_days):
        for symbol, df in symbol_data.items():
            candle = self._get_candle_at(df, day)
            if candle is None:
                continue

            # Check exits first
            if portfolio.has_position(symbol):
                position = portfolio.get_position(symbol)
                exit_signal = self._check_exit(position, candle, df, config.strategy)
                if exit_signal:
                    trade = self._close_position_with_costs(
                        portfolio, position, candle, exit_signal.reason, config
                    )
                    trades.append(trade)

            # Check entries
            if not portfolio.has_position(symbol):
                if self._can_open_position(portfolio, config):
                    entry_signal = self._check_entry(symbol, candle, df, config.strategy)
                    if entry_signal:
                        self._open_position_with_costs(portfolio, symbol, candle, day, config)

        # End of day equity
        equity_point = self._calculate_equity_point(portfolio, symbol_data, day, equity_curve)
        equity_curve.append(equity_point)

        if progress_callback:
            progress_callback(day_idx + 1, total_days)

    # Close remaining positions
    trades.extend(self._close_remaining_positions(portfolio, symbol_data, trading_days[-1], config))

    elapsed_ms = (time.perf_counter() - start_time) * 1000

    return BacktestResult(
        id=str(uuid.uuid4()),
        config=config,
        metrics=self._calculate_metrics(trades, equity_curve, config),
        equity_curve=equity_curve,
        trades=trades,
        daily_returns=self._calculate_daily_returns(equity_curve, config),
        execution_time_ms=elapsed_ms
    )
```

### 3.2 Slippage and Commission

```python
def _apply_slippage(self, price: Decimal, slippage_pct: float, is_buy: bool) -> Decimal:
    """Apply slippage (unfavorable direction)"""
    factor = 1 + slippage_pct / 100 if is_buy else 1 - slippage_pct / 100
    return price * Decimal(str(factor))

def _calculate_commission(self, trade_value: Decimal, commission_pct: float) -> Decimal:
    """Calculate commission amount"""
    return trade_value * Decimal(str(commission_pct / 100))
```

### 3.3 Position Operations with Costs

```python
def _open_position_with_costs(
    self,
    portfolio: Portfolio,
    symbol: str,
    candle: Candle,
    date: date,
    config: BacktestConfig
) -> None:
    """Open position with slippage and commission"""
    allocation = config.strategy.risk_config.position_size_pct / 100
    trade_value = portfolio.cash * Decimal(str(allocation))

    entry_price = self._apply_slippage(candle.close, config.slippage_pct, is_buy=True)
    quantity = int(trade_value / entry_price)

    if quantity <= 0:
        return

    commission = self._calculate_commission(entry_price * quantity, config.commission_pct)
    portfolio.open_position(symbol, entry_price, quantity, date, TradeSide.LONG, commission)

def _close_position_with_costs(
    self,
    portfolio: Portfolio,
    position: Position,
    candle: Candle,
    exit_reason: ExitReason,
    config: BacktestConfig
) -> Trade:
    """Close position with slippage and commission, return Trade"""
    exit_price = self._apply_slippage(candle.close, config.slippage_pct, is_buy=False)
    commission = self._calculate_commission(exit_price * position.quantity, config.commission_pct)

    pnl = portfolio.close_position(position.symbol, exit_price, commission)

    return Trade(
        id=str(uuid.uuid4()),
        symbol=position.symbol,
        side=position.side,
        entry_date=position.entry_date,
        entry_price=position.entry_price,
        entry_quantity=position.quantity,
        exit_date=candle.timestamp,
        exit_price=exit_price,
        exit_reason=exit_reason,
        pnl=pnl,
        pnl_pct=float(pnl / (position.entry_price * position.quantity) * 100),
        holding_days=(candle.timestamp - position.entry_date).days,
        commission=commission,
        slippage=abs(candle.close - exit_price) * position.quantity
    )
```

---

## 4. Acceptance Criteria

### 4.1 Simulation Loop

- [ ] Iterates trading days in chronological order
- [ ] Processes all symbols on each day
- [ ] Exits checked before entries
- [ ] Progress callback invoked with (current, total)

### 4.2 Cost Application

- [ ] Slippage applied correctly (buy up, sell down)
- [ ] Commission deducted on entry and exit
- [ ] Trade value uses slippage-adjusted price

### 4.3 Position Lifecycle

- [ ] `_can_open_position()` validates cash and max positions
- [ ] Open positions closed at backtest end with TIMEOUT
- [ ] Trade records contain all required fields

### 4.4 Testing

- [ ] Unit tests for slippage calculation
- [ ] Unit tests for commission calculation
- [ ] Integration tests for full backtest
- [ ] Performance: 252 days x 10 symbols < 5 seconds
- [ ] Test coverage > 85%

---

## 5. Technical Notes

### 5.1 Design Decisions

| Decision | Choice | Reason |
|----------|--------|--------|
| Exit first | Check exits before entries | Handle same-day reversals |
| Slippage direction | Unfavorable | Conservative simulation |
| Signal evaluation | Stub initially | E10-F03 implements |

### 5.2 Estimated LOC

- Slippage/commission methods: ~30 LOC
- Position open/close with costs: ~60 LOC
- Main simulation loop: ~80 LOC
- Close remaining positions: ~20 LOC
- Tests: ~250 LOC
- **Total: ~180-220 LOC (production code)**

### 5.3 Files to Modify

- `libs/core/src/backtesting/engine/backtest_engine.py` (extended)
- `tests/unit/backtesting/engine/test_simulation_loop.py`
- `tests/integration/backtesting/test_backtest_integration.py`

---

## 6. Dependencies

### 6.1 Upstream

| Dependency | Provides |
|------------|----------|
| E10-F01 | BacktestConfig, BacktestResult, Trade, ExitReason |
| E10-F02-T01 | Portfolio, Position classes |
| E10-F02-T02 | _load_data(), _get_trading_days(), _get_candle_at() |
| E10-F03 | _check_entry(), _check_exit() (can be stubbed) |

### 6.2 Downstream

| Dependent | Uses |
|-----------|------|
| E10-F02-T04 | Provides trades and equity_curve |
| E10-F03 | Implements actual signal evaluation |

---

## 7. References

- E10-F02.spec.md Section 2.2: Simulation Loop
- E10.spec.md Section 4.1: Core Engine
- E10-F03: Signal Evaluation (interface)
