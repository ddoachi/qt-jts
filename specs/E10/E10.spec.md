# Epic E10: Backtesting

## Metadata

| Field | Value |
|-------|-------|
| Epic ID | E10 |
| Title | Backtesting |
| Status | Draft |
| Platform | Cross-platform |
| Dependencies | E04 (Data), E06 (Processing), E09 (Strategy) |
| PRD Sections | 5.5 |

---

## 1. Overview

### 1.1 Purpose

Test trading strategies on historical data to measure performance:
- Simulate trade execution on past data
- Calculate key performance metrics
- Visualize equity curve and drawdowns
- Analyze individual trades

### 1.2 Goals

1. **Accurate Simulation**: Realistic trade execution with slippage/commission
2. **Fast Execution**: 1 year backtest in < 5 seconds
3. **Comprehensive Metrics**: Sharpe, drawdown, win rate, profit factor
4. **Visual Analysis**: Charts and trade lists

---

## 2. Architecture

### 2.1 Backtest Engine

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           Backtest Engine                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌──────────┐ │
│  │  Data       │───►│  Signal     │───►│  Order      │───►│  Metrics │ │
│  │  Feed       │    │  Generator  │    │  Executor   │    │  Calc    │ │
│  │             │    │             │    │             │    │          │ │
│  │  OHLCV      │    │  Entry/Exit │    │  Simulate   │    │  Sharpe, │ │
│  │  Stream     │    │  Signals    │    │  Fills      │    │  DD, etc │ │
│  └─────────────┘    └─────────────┘    └─────────────┘    └──────────┘ │
│                            │                   │                        │
│                            ▼                   ▼                        │
│                     ┌─────────────┐    ┌─────────────┐                 │
│                     │  Position   │◄───│  Portfolio  │                 │
│                     │  Manager    │    │  Tracker    │                 │
│                     └─────────────┘    └─────────────┘                 │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 Simulation Loop

```python
for each day in date_range:
    for each symbol in universe:
        candle = get_candle(symbol, day)

        # Check exits first
        for position in open_positions[symbol]:
            if should_exit(position, candle, strategy):
                close_position(position, candle)

        # Check entries
        if not has_position(symbol):
            if should_enter(symbol, candle, strategy):
                open_position(symbol, candle)

    # End of day processing
    update_portfolio_value(day)
    check_daily_limits()
```

---

## 3. Domain Model

### 3.1 Backtest Configuration (PRD 5.5.1)

```python
@dataclass
class BacktestConfig:
    """Backtest configuration"""
    strategy: Strategy
    symbols: list[str]
    start_date: date
    end_date: date
    initial_capital: Decimal = Decimal("100000000")  # 1억원
    commission_pct: float = 0.015  # 0.015%
    slippage_pct: float = 0.05  # 0.05%
    timeframe: str = "1d"

@dataclass
class BacktestResult:
    """Complete backtest results"""
    id: str
    config: BacktestConfig
    metrics: PerformanceMetrics
    equity_curve: list[EquityPoint]
    trades: list[Trade]
    daily_returns: list[DailyReturn]
    execution_time_ms: float
    created_at: datetime = field(default_factory=datetime.utcnow)
```

### 3.2 Performance Metrics (PRD 5.5.2)

```python
@dataclass
class PerformanceMetrics:
    """Key performance metrics"""
    # Returns
    total_return_pct: float  # 총 수익률
    cagr: float  # Compound annual growth rate

    # Risk-adjusted
    sharpe_ratio: float  # 샤프 비율
    sortino_ratio: float
    calmar_ratio: float

    # Drawdown
    max_drawdown_pct: float  # 최대 낙폭
    avg_drawdown_pct: float
    max_drawdown_duration_days: int

    # Trade statistics
    total_trades: int  # 총 거래수
    winning_trades: int
    losing_trades: int
    win_rate: float  # 승률
    profit_factor: float  # 손익비 (gross profit / gross loss)
    avg_win: float
    avg_loss: float
    largest_win: float
    largest_loss: float
    avg_holding_days: float

    # Final values
    final_equity: Decimal
    final_cash: Decimal

@dataclass
class EquityPoint:
    """Point on equity curve"""
    date: date
    equity: Decimal
    cash: Decimal
    positions_value: Decimal
    drawdown_pct: float

@dataclass
class DailyReturn:
    """Daily return data"""
    date: date
    return_pct: float
    cumulative_return_pct: float
```

### 3.3 Trade Entity

```python
@dataclass
class Trade:
    """A completed trade"""
    id: str
    symbol: str
    symbol_name: str
    side: TradeSide  # LONG, SHORT
    entry_date: date
    entry_price: Decimal
    entry_quantity: int
    exit_date: Optional[date]
    exit_price: Optional[Decimal]
    exit_reason: Optional[ExitReason]  # SIGNAL, STOP_LOSS, TAKE_PROFIT, TIMEOUT
    pnl: Optional[Decimal]
    pnl_pct: Optional[float]
    holding_days: Optional[int]
    commission: Decimal = Decimal(0)
    slippage: Decimal = Decimal(0)

    @property
    def is_winner(self) -> bool:
        return self.pnl and self.pnl > 0

    @property
    def net_pnl(self) -> Decimal:
        if self.pnl is None:
            return Decimal(0)
        return self.pnl - self.commission - self.slippage

class ExitReason(Enum):
    SIGNAL = "signal"  # Exit rule triggered
    STOP_LOSS = "stop_loss"
    TAKE_PROFIT = "take_profit"
    TIMEOUT = "timeout"  # End of backtest
    DAILY_LIMIT = "daily_limit"
```

---

## 4. Backtest Engine

### 4.1 Core Engine

```python
class BacktestEngine:
    """Core backtesting engine"""

    def __init__(
        self,
        candle_repo: ICandleRepository,
        formula_service: FormulaService
    ):
        self._candle_repo = candle_repo
        self._formula_service = formula_service

    async def run(
        self,
        config: BacktestConfig,
        progress_callback: Callable[[int, int], None] = None
    ) -> BacktestResult:
        start_time = time.perf_counter()

        # Initialize portfolio
        portfolio = Portfolio(
            cash=config.initial_capital,
            positions={}
        )

        # Load all candle data upfront
        symbol_data = await self._load_data(config)

        trades = []
        equity_curve = []
        daily_returns = []

        # Get trading days
        trading_days = self._get_trading_days(
            config.start_date, config.end_date
        )
        total_days = len(trading_days)

        prev_equity = config.initial_capital

        for i, day in enumerate(trading_days):
            # Process each symbol
            for symbol, df in symbol_data.items():
                if day not in df.index:
                    continue

                candle = self._get_candle_at(df, day)

                # Check exits for open positions
                if symbol in portfolio.positions:
                    position = portfolio.positions[symbol]
                    exit_signal = self._check_exit(
                        position, candle, df, config.strategy
                    )

                    if exit_signal:
                        trade = self._close_position(
                            portfolio, position, candle,
                            exit_signal.reason, config
                        )
                        trades.append(trade)

                # Check entries
                if symbol not in portfolio.positions:
                    if self._can_open_position(portfolio, config):
                        if self._check_entry(symbol, candle, df, config.strategy):
                            self._open_position(
                                portfolio, symbol, candle, config
                            )

            # End of day - calculate equity
            equity = self._calculate_equity(portfolio, symbol_data, day)
            drawdown = self._calculate_drawdown(equity, equity_curve)

            equity_curve.append(EquityPoint(
                date=day,
                equity=equity,
                cash=portfolio.cash,
                positions_value=equity - portfolio.cash,
                drawdown_pct=drawdown
            ))

            # Daily return
            daily_return = float((equity - prev_equity) / prev_equity) * 100
            daily_returns.append(DailyReturn(
                date=day,
                return_pct=daily_return,
                cumulative_return_pct=float((equity - config.initial_capital) / config.initial_capital) * 100
            ))
            prev_equity = equity

            if progress_callback:
                progress_callback(i + 1, total_days)

        # Close remaining positions
        for symbol, position in list(portfolio.positions.items()):
            last_day = trading_days[-1]
            if symbol in symbol_data and last_day in symbol_data[symbol].index:
                candle = self._get_candle_at(symbol_data[symbol], last_day)
                trade = self._close_position(
                    portfolio, position, candle, ExitReason.TIMEOUT, config
                )
                trades.append(trade)

        # Calculate metrics
        metrics = self._calculate_metrics(
            trades, equity_curve, daily_returns, config
        )

        elapsed = (time.perf_counter() - start_time) * 1000

        return BacktestResult(
            id=str(uuid.uuid4()),
            config=config,
            metrics=metrics,
            equity_curve=equity_curve,
            trades=trades,
            daily_returns=daily_returns,
            execution_time_ms=elapsed
        )

    def _check_entry(
        self,
        symbol: str,
        candle: Candle,
        df: pd.DataFrame,
        strategy: Strategy
    ) -> bool:
        """Check if entry rule is satisfied"""
        # Get data up to current candle
        current_idx = df.index.get_loc(candle.timestamp)
        history = df.iloc[:current_idx + 1]

        result = self._formula_service.evaluate(
            strategy.entry_rule.to_formula(),
            history,
            strategy.entry_rule.parameters
        )

        return result.iloc[-1] if len(result) > 0 else False

    def _check_exit(
        self,
        position: Position,
        candle: Candle,
        df: pd.DataFrame,
        strategy: Strategy
    ) -> Optional[ExitSignal]:
        """Check if any exit condition is met"""
        current_price = candle.close

        # Check stop-loss
        if strategy.risk_config.stop_loss_pct:
            loss_pct = (current_price - position.entry_price) / position.entry_price
            if loss_pct <= -strategy.risk_config.stop_loss_pct / 100:
                return ExitSignal(reason=ExitReason.STOP_LOSS)

        # Check take-profit
        if strategy.risk_config.take_profit_pct:
            gain_pct = (current_price - position.entry_price) / position.entry_price
            if gain_pct >= strategy.risk_config.take_profit_pct / 100:
                return ExitSignal(reason=ExitReason.TAKE_PROFIT)

        # Check exit rule
        if strategy.exit_rule:
            current_idx = df.index.get_loc(candle.timestamp)
            history = df.iloc[:current_idx + 1]

            result = self._formula_service.evaluate(
                strategy.exit_rule.to_formula(),
                history,
                strategy.exit_rule.parameters
            )

            if result.iloc[-1]:
                return ExitSignal(reason=ExitReason.SIGNAL)

        return None
```

### 4.2 Metrics Calculator

```python
class MetricsCalculator:
    """Calculate performance metrics"""

    def calculate(
        self,
        trades: list[Trade],
        equity_curve: list[EquityPoint],
        daily_returns: list[DailyReturn],
        initial_capital: Decimal
    ) -> PerformanceMetrics:
        # Basic counts
        winners = [t for t in trades if t.is_winner]
        losers = [t for t in trades if t.pnl and t.pnl < 0]

        # Returns
        final_equity = equity_curve[-1].equity if equity_curve else initial_capital
        total_return = float((final_equity - initial_capital) / initial_capital) * 100

        # CAGR
        years = len(equity_curve) / 252 if equity_curve else 1
        cagr = (pow(float(final_equity / initial_capital), 1 / years) - 1) * 100

        # Sharpe Ratio (annualized)
        returns = [d.return_pct for d in daily_returns]
        if returns:
            avg_return = np.mean(returns)
            std_return = np.std(returns)
            sharpe = (avg_return * 252) / (std_return * np.sqrt(252)) if std_return > 0 else 0
        else:
            sharpe = 0

        # Max Drawdown
        max_dd = min(e.drawdown_pct for e in equity_curve) if equity_curve else 0

        # Win rate and profit factor
        win_rate = len(winners) / len(trades) * 100 if trades else 0

        gross_profit = sum(t.pnl for t in winners if t.pnl) or Decimal(0)
        gross_loss = abs(sum(t.pnl for t in losers if t.pnl)) or Decimal(1)
        profit_factor = float(gross_profit / gross_loss) if gross_loss else 0

        # Average win/loss
        avg_win = float(np.mean([t.pnl_pct for t in winners])) if winners else 0
        avg_loss = float(np.mean([t.pnl_pct for t in losers])) if losers else 0

        return PerformanceMetrics(
            total_return_pct=total_return,
            cagr=cagr,
            sharpe_ratio=sharpe,
            sortino_ratio=self._calc_sortino(returns),
            calmar_ratio=cagr / abs(max_dd) if max_dd != 0 else 0,
            max_drawdown_pct=max_dd,
            avg_drawdown_pct=np.mean([e.drawdown_pct for e in equity_curve if e.drawdown_pct < 0]) if equity_curve else 0,
            max_drawdown_duration_days=self._calc_dd_duration(equity_curve),
            total_trades=len(trades),
            winning_trades=len(winners),
            losing_trades=len(losers),
            win_rate=win_rate,
            profit_factor=profit_factor,
            avg_win=avg_win,
            avg_loss=avg_loss,
            largest_win=max((t.pnl_pct or 0) for t in trades) if trades else 0,
            largest_loss=min((t.pnl_pct or 0) for t in trades) if trades else 0,
            avg_holding_days=np.mean([t.holding_days or 0 for t in trades]) if trades else 0,
            final_equity=final_equity,
            final_cash=equity_curve[-1].cash if equity_curve else initial_capital
        )
```

---

## 5. UI Components

### 5.1 Backtest View (PRD 6.4)

```
┌─────────────────────────────────────────────────────────────────────────┐
│ Backtest                                                                 │
├─────────────────────────────────────────────────────────────────────────┤
│ Strategy: RSI Momentum Strategy                                          │
│ Period: 2023-01-01 ~ 2024-12-31    Capital: ₩100,000,000                │
│                                                      [▶ 백테스트 실행]  │
├─────────────────────────────────────────────────────────────────────────┤
│ Performance Summary                                                      │
│ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐            │
│ │ 수익률   │ │ 샤프    │ │ 최대낙폭│ │ 승률    │ │ 거래수  │            │
│ │ +45.2%  │ │  1.85   │ │ -12.3%  │ │  62%    │ │  127    │            │
│ └─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────┘            │
├─────────────────────────────────────────────────────────────────────────┤
│ Equity Curve                                                             │
│ ┌─────────────────────────────────────────────────────────────────────┐ │
│ │ ₩145M                                          ╭────────────        │ │
│ │ ₩130M                          ╭───────────────╯                    │ │
│ │ ₩115M           ╭──────────────╯                                    │ │
│ │ ₩100M ──────────╯                                                   │ │
│ │        Jan   Mar   May   Jul   Sep   Nov                            │ │
│ └─────────────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────────────┤
│ Trade History                                          [CSV 내보내기]   │
│ ┌────────┬────────────┬────────────┬───────────┬─────────┬──────────┐  │
│ │ Symbol │ Entry      │ Exit       │ P&L       │ P&L %   │ 청산사유  │  │
│ ├────────┼────────────┼────────────┼───────────┼─────────┼──────────┤  │
│ │ 005930 │ 01-15      │ 01-18      │ +₩520,000 │ +5.2%   │ 익절     │  │
│ │ 000660 │ 01-22      │ 01-22      │ -₩180,000 │ -1.8%   │ 손절     │  │
│ └────────┴────────────┴────────────┴───────────┴─────────┴──────────┘  │
└─────────────────────────────────────────────────────────────────────────┘
```

### 5.2 Metrics Summary Widget

```python
class MetricsSummaryWidget(QWidget):
    """Display key performance metrics"""

    def __init__(self, parent=None):
        super().__init__(parent)
        self._setup_ui()

    def _setup_ui(self):
        layout = QHBoxLayout(self)

        # Create metric cards
        self._cards = {
            'return': self._create_card("수익률", "+0.0%"),
            'sharpe': self._create_card("샤프", "0.00"),
            'drawdown': self._create_card("최대낙폭", "0.0%"),
            'win_rate': self._create_card("승률", "0%"),
            'trades': self._create_card("거래수", "0")
        }

        for card in self._cards.values():
            layout.addWidget(card)

    def _create_card(self, label: str, initial_value: str) -> QFrame:
        """Create a metric card widget"""
        card = QFrame()
        card.setFrameStyle(QFrame.Box)
        card.setStyleSheet("QFrame { background: #f5f5f5; border-radius: 8px; }")

        layout = QVBoxLayout(card)

        value_label = QLabel(initial_value)
        value_label.setObjectName("value")
        value_label.setStyleSheet("font-size: 24px; font-weight: bold;")
        value_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(value_label)

        name_label = QLabel(label)
        name_label.setStyleSheet("font-size: 12px; color: #666;")
        name_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(name_label)

        return card

    def set_metrics(self, metrics: PerformanceMetrics):
        """Update display with metrics"""
        self._set_card_value('return', f"+{metrics.total_return_pct:.1f}%"
                            if metrics.total_return_pct >= 0
                            else f"{metrics.total_return_pct:.1f}%")
        self._set_card_value('sharpe', f"{metrics.sharpe_ratio:.2f}")
        self._set_card_value('drawdown', f"{metrics.max_drawdown_pct:.1f}%")
        self._set_card_value('win_rate', f"{metrics.win_rate:.0f}%")
        self._set_card_value('trades', str(metrics.total_trades))

        # Color coding
        if metrics.total_return_pct >= 0:
            self._cards['return'].setStyleSheet("background: #e8f5e9;")
        else:
            self._cards['return'].setStyleSheet("background: #ffebee;")

    def _set_card_value(self, key: str, value: str):
        value_label = self._cards[key].findChild(QLabel, "value")
        if value_label:
            value_label.setText(value)
```

### 5.3 Equity Curve Widget

```python
class EquityCurveWidget(QWidget):
    """Equity curve chart with drawdown overlay"""

    def __init__(self, parent=None):
        super().__init__(parent)
        self._setup_ui()

    def _setup_ui(self):
        layout = QVBoxLayout(self)

        # Create plot widget
        self._plot = pg.PlotWidget()
        self._plot.setBackground('w')
        self._plot.showGrid(x=True, y=True, alpha=0.3)
        self._plot.setLabel('left', 'Equity', units='₩')
        self._plot.setLabel('bottom', 'Date')

        layout.addWidget(self._plot)

    def set_data(self, equity_curve: list[EquityPoint], initial_capital: Decimal):
        """Plot equity curve"""
        self._plot.clear()

        if not equity_curve:
            return

        # Prepare data
        dates = [i for i in range(len(equity_curve))]
        equities = [float(e.equity) for e in equity_curve]

        # Plot equity line
        pen = pg.mkPen(color='#2196F3', width=2)
        self._plot.plot(dates, equities, pen=pen, name='Equity')

        # Plot initial capital reference
        self._plot.addLine(
            y=float(initial_capital),
            pen=pg.mkPen(color='#9E9E9E', width=1, style=Qt.DashLine)
        )

        # Shade drawdown areas
        self._shade_drawdowns(equity_curve)

    def _shade_drawdowns(self, equity_curve: list[EquityPoint]):
        """Add red shading for drawdown periods"""
        peak = equity_curve[0].equity
        in_drawdown = False

        for i, point in enumerate(equity_curve):
            if point.equity > peak:
                peak = point.equity
                in_drawdown = False
            else:
                if not in_drawdown:
                    in_drawdown = True
                    # Start shading
```

---

## 6. Tasks Breakdown

| Task ID | Title | Effort | Dependencies |
|---------|-------|--------|--------------|
| E10-F01-T01 | Define BacktestConfig and BacktestResult | M | E09 |
| E10-F01-T02 | Define PerformanceMetrics | M | T01 |
| E10-F01-T03 | Define Trade entity | M | T01 |
| E10-F02-T01 | Implement BacktestEngine core | L | F01 |
| E10-F02-T02 | Implement entry/exit signal checking | M | F02-T01 |
| E10-F02-T03 | Implement position sizing logic | M | F02-T01 |
| E10-F02-T04 | Implement commission/slippage | S | F02-T01 |
| E10-F03-T01 | Implement MetricsCalculator | L | F01 |
| E10-F03-T02 | Implement Sharpe/Sortino calculation | M | F03-T01 |
| E10-F03-T03 | Implement drawdown analysis | M | F03-T01 |
| E10-F04-T01 | Create BacktestView | M | E01 |
| E10-F04-T02 | Create MetricsSummaryWidget | M | F04-T01 |
| E10-F04-T03 | Create EquityCurveWidget | L | F04-T01 |
| E10-F04-T04 | Create TradeHistoryWidget | M | F04-T01 |
| E10-F05-T01 | Implement result export (CSV) | M | F01 |
| E10-F05-T02 | Implement result persistence | M | F01 |

---

## 7. Acceptance Criteria (PRD 8.4)

### 7.1 Performance

- [ ] 1년 백테스트 5초 이내 완료
- [ ] Memory usage < 500MB during backtest

### 7.2 Metrics

- [ ] 주요 성과 지표 (샤프, 낙폭, 승률) 계산
- [ ] 자산 곡선 차트 표시
- [ ] 개별 거래 내역 표시

### 7.3 Accuracy

- [ ] Commission and slippage correctly applied
- [ ] Position sizing respects max positions
- [ ] Stop-loss/take-profit correctly triggered

### 7.4 Testing

- [ ] Unit tests for BacktestEngine
- [ ] Unit tests for MetricsCalculator
- [ ] Known-result backtest validation
- [ ] Test coverage > 85%

---

## 8. References

- PRD Section 5.5: Backtesting
- PRD Section 6.4: Backtest Screen
- E09: Strategy Builder
- [Sharpe Ratio](https://en.wikipedia.org/wiki/Sharpe_ratio)
