# Epic E08: Pattern Discovery

## Metadata

| Field | Value |
|-------|-------|
| Epic ID | E08 |
| Title | Pattern Discovery |
| Status | Draft |
| Platform | Cross-platform |
| Dependencies | E07 (Scanner) |
| PRD Sections | 5.3 |

---

## 1. Overview

### 1.1 Purpose

Automatically discover profitable entry/exit/stop-loss patterns from historical events:
- Analyze scan results to find predictive patterns
- Measure forward returns after events
- Generate formula rules that predict good outcomes

### 1.2 Goals

1. **Data-Driven**: Discover patterns from actual market data
2. **Measurable**: Clear hit rates and expected returns
3. **Actionable**: Output usable formula rules
4. **Validated**: Sample matches for human review

---

## 2. Architecture

### 2.1 Discovery Workflow (PRD 5.3.1)

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│ 1. Select       │     │ 2. Label        │     │ 3. Discover     │
│    Events       │────►│    Outcomes     │────►│    Patterns     │
│                 │     │                 │     │                 │
│ From scan       │     │ What happened   │     │ What predicted  │
│ results         │     │ after each      │     │ good outcomes   │
│                 │     │ event?          │     │                 │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

### 2.2 Component Structure

```
src/presentation/views/discovery/
├── discovery_view.py           # Main discovery view
├── event_selection_widget.py   # Select events from scans
├── outcome_config_widget.py    # Configure outcome labeling
├── discovery_results_widget.py # Show discovered patterns
└── rule_review_widget.py       # Review and validate rules
```

---

## 3. Domain Model

### 3.1 Discovery Types (PRD 5.3.2)

```python
class DiscoveryType(Enum):
    """Types of patterns to discover"""
    ENTRY = "entry"      # When should I buy?
    EXIT = "exit"        # When should I sell?
    STOP_LOSS = "stop_loss"  # When should I cut losses?

@dataclass
class DiscoveryConfig:
    """Configuration for pattern discovery"""
    discovery_type: DiscoveryType
    lookahead_period: int = 5  # Days to measure outcome
    success_threshold: float = 0.03  # +3% = success
    failure_threshold: float = -0.02  # -2% = failure
    min_samples: int = 30  # Minimum events for valid pattern

@dataclass
class LabeledEvent:
    """An event with its outcome labeled"""
    symbol: str
    timestamp: datetime
    candle: Candle
    indicator_values: dict[str, float]
    outcome: OutcomeLabel  # SUCCESS, FAILURE, NEUTRAL
    forward_return: float
    exit_timestamp: Optional[datetime] = None
    exit_reason: Optional[str] = None  # hit_target, hit_stop, timeout

class OutcomeLabel(Enum):
    SUCCESS = "success"
    FAILURE = "failure"
    NEUTRAL = "neutral"
```

### 3.2 Discovered Rule

```python
@dataclass
class DiscoveredRule:
    """A pattern discovered from data"""
    id: str
    formula: str  # DSL expression
    discovery_type: DiscoveryType
    statistics: RuleStatistics
    sample_matches: list[LabeledEvent]
    created_at: datetime = field(default_factory=datetime.utcnow)

@dataclass
class RuleStatistics:
    """Statistics for a discovered rule"""
    total_events: int
    success_count: int
    failure_count: int
    neutral_count: int
    hit_rate: float  # success / (success + failure)
    avg_return: float
    avg_success_return: float
    avg_failure_return: float
    profit_factor: float  # total gains / total losses
    max_consecutive_failures: int
```

---

## 4. Discovery Algorithm

### 4.1 Outcome Labeling

```python
class OutcomeLabeler:
    """Label events with forward-looking outcomes"""

    def __init__(self, candle_repo: ICandleRepository):
        self._candle_repo = candle_repo

    async def label_events(
        self,
        events: list[ScanMatch],
        config: DiscoveryConfig
    ) -> list[LabeledEvent]:
        """Label each event with its outcome"""
        labeled = []

        for event in events:
            # Get forward candles
            forward_candles = await self._get_forward_candles(
                event.symbol,
                event.match_time,
                config.lookahead_period
            )

            if not forward_candles:
                continue

            # Calculate outcome
            outcome, forward_return, exit_info = self._calculate_outcome(
                event.candle,
                forward_candles,
                config
            )

            labeled.append(LabeledEvent(
                symbol=event.symbol,
                timestamp=event.match_time,
                candle=event.candle,
                indicator_values=event.indicator_values,
                outcome=outcome,
                forward_return=forward_return,
                exit_timestamp=exit_info.get('timestamp'),
                exit_reason=exit_info.get('reason')
            ))

        return labeled

    def _calculate_outcome(
        self,
        entry_candle: Candle,
        forward_candles: list[Candle],
        config: DiscoveryConfig
    ) -> tuple[OutcomeLabel, float, dict]:
        """Determine outcome based on forward price action"""
        entry_price = entry_candle.close
        exit_info = {}

        for candle in forward_candles:
            high_return = (candle.high - entry_price) / entry_price
            low_return = (candle.low - entry_price) / entry_price

            # Check success first (optimistic)
            if high_return >= config.success_threshold:
                exit_info = {
                    'timestamp': candle.timestamp,
                    'reason': 'hit_target'
                }
                return OutcomeLabel.SUCCESS, config.success_threshold, exit_info

            # Check failure
            if low_return <= config.failure_threshold:
                exit_info = {
                    'timestamp': candle.timestamp,
                    'reason': 'hit_stop'
                }
                return OutcomeLabel.FAILURE, config.failure_threshold, exit_info

        # Timeout - use final close
        final_return = (forward_candles[-1].close - entry_price) / entry_price
        exit_info = {
            'timestamp': forward_candles[-1].timestamp,
            'reason': 'timeout'
        }

        if final_return > 0:
            return OutcomeLabel.NEUTRAL, final_return, exit_info
        else:
            return OutcomeLabel.NEUTRAL, final_return, exit_info
```

### 4.2 Pattern Miner

```python
class PatternMiner:
    """Mine patterns from labeled events"""

    def __init__(self):
        self._indicator_thresholds = self._define_thresholds()

    def discover_patterns(
        self,
        labeled_events: list[LabeledEvent],
        config: DiscoveryConfig
    ) -> list[DiscoveredRule]:
        """Discover patterns that predict success"""
        rules = []

        # 1. Analyze indicator distributions for success vs failure
        success_events = [e for e in labeled_events
                        if e.outcome == OutcomeLabel.SUCCESS]
        failure_events = [e for e in labeled_events
                        if e.outcome == OutcomeLabel.FAILURE]

        if len(success_events) < config.min_samples:
            return []

        # 2. Find discriminating indicator conditions
        conditions = self._find_discriminating_conditions(
            success_events, failure_events
        )

        # 3. Combine conditions and validate
        for condition_set in self._generate_condition_combinations(conditions):
            formula = self._build_formula(condition_set)
            stats = self._calculate_stats(labeled_events, formula)

            if self._is_valid_rule(stats, config):
                samples = self._get_sample_matches(labeled_events, formula)
                rules.append(DiscoveredRule(
                    id=str(uuid.uuid4()),
                    formula=formula,
                    discovery_type=config.discovery_type,
                    statistics=stats,
                    sample_matches=samples[:10]
                ))

        # 4. Rank by profit factor
        rules.sort(key=lambda r: r.statistics.profit_factor, reverse=True)

        return rules[:10]  # Top 10 rules

    def _find_discriminating_conditions(
        self,
        success: list[LabeledEvent],
        failure: list[LabeledEvent]
    ) -> list[IndicatorCondition]:
        """Find indicator conditions that separate success from failure"""
        conditions = []

        # Analyze each indicator
        indicators = set()
        for event in success + failure:
            indicators.update(event.indicator_values.keys())

        for indicator in indicators:
            success_values = [e.indicator_values.get(indicator, 0)
                            for e in success]
            failure_values = [e.indicator_values.get(indicator, 0)
                            for e in failure]

            # Find threshold that best separates the groups
            condition = self._find_best_threshold(
                indicator, success_values, failure_values
            )
            if condition:
                conditions.append(condition)

        return conditions

    def _find_best_threshold(
        self,
        indicator: str,
        success_values: list[float],
        failure_values: list[float]
    ) -> Optional[IndicatorCondition]:
        """Find threshold that maximizes separation"""
        all_values = sorted(set(success_values + failure_values))

        best_score = 0
        best_condition = None

        for threshold in all_values:
            # Try "indicator < threshold"
            success_match = sum(1 for v in success_values if v < threshold)
            failure_match = sum(1 for v in failure_values if v < threshold)
            score_lt = self._separation_score(
                success_match, len(success_values),
                failure_match, len(failure_values)
            )

            if score_lt > best_score:
                best_score = score_lt
                best_condition = IndicatorCondition(
                    indicator=indicator,
                    operator="<",
                    threshold=threshold
                )

            # Try "indicator > threshold"
            success_match = sum(1 for v in success_values if v > threshold)
            failure_match = sum(1 for v in failure_values if v > threshold)
            score_gt = self._separation_score(
                success_match, len(success_values),
                failure_match, len(failure_values)
            )

            if score_gt > best_score:
                best_score = score_gt
                best_condition = IndicatorCondition(
                    indicator=indicator,
                    operator=">",
                    threshold=threshold
                )

        return best_condition if best_score > 0.3 else None

    def _build_formula(self, conditions: list[IndicatorCondition]) -> str:
        """Convert conditions to DSL formula"""
        parts = []
        for cond in conditions:
            parts.append(f"{cond.indicator} {cond.operator} {cond.threshold}")
        return " AND ".join(parts)
```

---

## 5. Use Cases

### 5.1 Run Discovery Use Case

```python
class RunDiscoveryUseCase:
    """Execute pattern discovery"""

    def __init__(
        self,
        labeler: OutcomeLabeler,
        miner: PatternMiner,
        rule_repo: IDiscoveredRuleRepository
    ):
        self._labeler = labeler
        self._miner = miner
        self._rule_repo = rule_repo

    async def execute(
        self,
        events: list[ScanMatch],
        config: DiscoveryConfig
    ) -> list[DiscoveredRule]:
        # Label outcomes
        labeled = await self._labeler.label_events(events, config)

        # Mine patterns
        rules = self._miner.discover_patterns(labeled, config)

        # Save discovered rules
        for rule in rules:
            await self._rule_repo.save(rule)

        return rules
```

---

## 6. UI Components

### 6.1 Discovery Configuration

```
┌─────────────────────────────────────────────────────────────────────────┐
│ Pattern Discovery                                                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│ Step 1: Select Events                                                    │
│ ┌─────────────────────────────────────────────────────────────────────┐ │
│ │ Source: [Volume Surge Scan (2024-12-28) ▼]                          │ │
│ │ Events: 47 matches available                                         │ │
│ └─────────────────────────────────────────────────────────────────────┘ │
│                                                                          │
│ Step 2: Discovery Type                                                   │
│ ┌─────────────────────────────────────────────────────────────────────┐ │
│ │ ● Entry Rules - When should I buy?                                   │ │
│ │ ○ Exit Rules - When should I sell?                                   │ │
│ │ ○ Stop-Loss Rules - When should I cut losses?                        │ │
│ └─────────────────────────────────────────────────────────────────────┘ │
│                                                                          │
│ Step 3: Outcome Parameters                                               │
│ ┌─────────────────────────────────────────────────────────────────────┐ │
│ │ Lookahead Period: [5] days                                           │ │
│ │ Success Threshold: [+3.0]%                                           │ │
│ │ Failure Threshold: [-2.0]%                                           │ │
│ │ Minimum Samples: [30]                                                │ │
│ └─────────────────────────────────────────────────────────────────────┘ │
│                                                                          │
│                                               [▶ 패턴 발견 시작]         │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 6.2 Discovery Results

```
┌─────────────────────────────────────────────────────────────────────────┐
│ Discovered Entry Rules                                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│ Rank 1: ⭐ High Probability Entry                                        │
│ ┌─────────────────────────────────────────────────────────────────────┐ │
│ │ Formula: rsi(14) < 25 AND volume > sma(volume, 10) * 1.5            │ │
│ │                                                                       │ │
│ │ Statistics:                                                           │ │
│ │ ├─ Hit Rate: 68.5% (24/35)                                           │ │
│ │ ├─ Avg Return: +2.8%                                                  │ │
│ │ ├─ Profit Factor: 2.3                                                 │ │
│ │ └─ Max Consecutive Losses: 3                                          │ │
│ │                                                                       │ │
│ │ Sample Matches:                                                       │ │
│ │ ├─ 005930 삼성전자 (2024-11-15) → +4.2% ✓                            │ │
│ │ ├─ 000660 SK하이닉스 (2024-10-22) → +3.1% ✓                          │ │
│ │ └─ 035420 NAVER (2024-09-18) → -1.5% ✗                               │ │
│ │                                          [자세히 보기] [전략에 추가] │ │
│ └─────────────────────────────────────────────────────────────────────┘ │
│                                                                          │
│ Rank 2: Momentum Breakout                                                │
│ ┌─────────────────────────────────────────────────────────────────────┐ │
│ │ Formula: close > sma(close, 20) AND sma(close, 20) > sma(close, 50) │ │
│ │ Hit Rate: 62.1% | Profit Factor: 1.8                                 │ │
│ └─────────────────────────────────────────────────────────────────────┘ │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 7. Tasks Breakdown

| Task ID | Title | Effort | Dependencies |
|---------|-------|--------|--------------|
| E08-F01-T01 | Define DiscoveryConfig and LabeledEvent | M | E07 |
| E08-F01-T02 | Define DiscoveredRule and RuleStatistics | M | T01 |
| E08-F02-T01 | Implement OutcomeLabeler | L | F01 |
| E08-F02-T02 | Implement forward return calculation | M | F02-T01 |
| E08-F03-T01 | Implement PatternMiner core | L | F02 |
| E08-F03-T02 | Implement condition finding algorithm | L | F03-T01 |
| E08-F03-T03 | Implement formula generation | M | F03-T02 |
| E08-F04-T01 | Implement RunDiscoveryUseCase | M | F02, F03 |
| E08-F05-T01 | Create DiscoveryView | M | E01 |
| E08-F05-T02 | Create EventSelectionWidget | M | F05-T01 |
| E08-F05-T03 | Create OutcomeConfigWidget | M | F05-T01 |
| E08-F05-T04 | Create DiscoveryResultsWidget | L | F05-T01 |
| E08-F05-T05 | Create RuleReviewWidget | M | F05-T04 |

---

## 8. Acceptance Criteria (PRD 8.3)

### 8.1 Functional

- [ ] 스캔 결과에서 패턴 자동 발견
- [ ] 발견된 규칙의 과거 성과 표시
- [ ] 진입/청산/손절 규칙 각각 발견 가능

### 8.2 Quality

- [ ] Discovered rules have > 55% hit rate
- [ ] Sample matches displayed for validation
- [ ] Clear statistics for each rule

### 8.3 Testing

- [ ] Unit tests for OutcomeLabeler
- [ ] Unit tests for PatternMiner
- [ ] Integration test with real scan data
- [ ] Test coverage > 80%

---

## 9. References

- PRD Section 5.3: Pattern Discovery
- E07: Market Scanner (event source)
- Machine Learning: Decision Tree concepts
