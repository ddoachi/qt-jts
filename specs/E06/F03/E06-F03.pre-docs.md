# E06-F03: Indicator Pipeline - Pre-Implementation Planning

## 1. Overview and Objectives

### 1.1 Purpose
Implement a reusable indicator calculation pipeline that pre-computes common technical indicators efficiently. This pipeline will serve as a critical performance optimization by computing indicators once per symbol and caching results for formula evaluation.

### 1.2 Key Objectives
- Create extensible `IndicatorPipeline` class with registration API
- Implement all PRD-required technical indicators with pandas optimization
- Support custom indicator registration for extensibility
- Provide batch computation capability for multi-indicator processing
- Ensure calculation correctness through comprehensive testing

### 1.3 Success Metrics
- All 11+ default indicators registered and tested
- Individual indicator computation < 10ms for 500 candles
- Test coverage > 85%
- Calculation accuracy verified against known values

---

## 2. Technical Approach

### 2.1 Architecture Pattern
**Strategy Pattern + Registry Pattern**
- `IndicatorPipeline` acts as a registry and orchestrator
- Each indicator is a strategy (callable function) registered by name
- Supports both built-in and custom indicator registration
- Uses pandas vectorized operations for performance

### 2.2 Technology Stack
- **Language**: TypeScript (based on monorepo structure) or Python (based on epic spec examples)
- **Data Processing**: pandas DataFrames for vectorized calculations
- **Testing**: Jest (TypeScript) or pytest (Python) with mock data generators
- **Dependencies**: Epic E06 processing engine architecture

### 2.3 Design Principles
- **Single Responsibility**: Each indicator is a pure function
- **Open/Closed**: Open for extension (custom indicators), closed for modification
- **Performance First**: Leverage pandas vectorization, avoid loops
- **Immutability**: Indicators should not modify input DataFrames
- **Testability**: Pure functions with deterministic outputs

---

## 3. Dependencies and Prerequisites

### 3.1 Hard Dependencies
- **E02 (Storage Layer)**: Candle data models and structures
- **DataFrame Library**: pandas (Python) or data processing equivalent
- **Math/Statistics**: Standard library or specialized libraries

### 3.2 Soft Dependencies
- **E05 (DSL Evaluator)**: Formula evaluation will consume computed indicators
- **E06-F05 (Caching)**: Future caching layer will use indicator pipeline output

### 3.3 External Libraries Consideration
- **TA-Lib**: Industry-standard technical analysis library (optional, for validation)
- **pandas-ta**: Modern pandas-based indicators (alternative to TA-Lib)
- Decision: Start with pure pandas implementations for control and transparency

---

## 4. Implementation Plan

### 4.1 Phase 1: Core Pipeline (Task E06-F03-T01)
**Estimated Effort**: Medium (4-6 hours)

**Steps**:
1. Define `IndicatorPipeline` class structure
2. Implement indicator registration mechanism
3. Create compute method for batch processing
4. Add indicator name validation and error handling
5. Write unit tests for registration and compute logic

**Key Methods**:
```typescript
class IndicatorPipeline {
  register(name: string, calculator: IndicatorCalculator): void
  compute(df: DataFrame, indicators?: string[]): Map<string, Series>
  getAvailableIndicators(): string[]
}
```

### 4.2 Phase 2: Indicator Implementations (Task E06-F03-T02)
**Estimated Effort**: Medium (6-8 hours)

**Implementation Order** (by complexity):
1. **Simple Moving Averages** (SMA 20, 50, 200) - Simplest, validates pipeline
2. **Exponential Moving Averages** (EMA 12, 26) - Introduces EWM
3. **Volume Indicators** (Volume SMA, OBV, VWAP) - Different data columns
4. **RSI** (14-period) - Moderate complexity with gain/loss logic
5. **ATR** (14-period) - Multiple true range calculations
6. **Bollinger Bands** (20/2) - Returns multiple series (upper, middle, lower)
7. **MACD** (12/26/9) - Returns multiple series (MACD, signal, histogram)
8. **Stochastic Oscillator** (14/3/3) - Most complex, multiple smoothing steps

### 4.3 Phase 3: Testing and Validation
**Estimated Effort**: Small (2-3 hours)

**Test Types**:
1. **Unit Tests**: Each indicator with synthetic data
2. **Correctness Tests**: Compare against known values (e.g., TA-Lib output)
3. **Edge Cases**: NaN handling, insufficient data, empty DataFrames
4. **Performance Tests**: Benchmark with 500+ candle datasets

---

## 5. File Structure and Locations

### 5.1 Proposed Directory Structure
```
libs/processing-engine/
├── src/
│   ├── indicator-pipeline/
│   │   ├── indicator-pipeline.ts          # Main pipeline class
│   │   ├── indicator-calculator.interface.ts  # Type definitions
│   │   ├── indicators/
│   │   │   ├── moving-averages.ts         # SMA, EMA implementations
│   │   │   ├── momentum.ts                # RSI, MACD, Stochastic
│   │   │   ├── volatility.ts              # ATR, Bollinger Bands
│   │   │   ├── volume.ts                  # Volume SMA, OBV, VWAP
│   │   │   └── index.ts                   # Export all indicators
│   │   └── index.ts
│   └── index.ts
├── test/
│   ├── indicator-pipeline.spec.ts
│   ├── indicators/
│   │   ├── moving-averages.spec.ts
│   │   ├── momentum.spec.ts
│   │   ├── volatility.spec.ts
│   │   └── volume.spec.ts
│   └── fixtures/
│       ├── test-candles.ts                # Candle data generators
│       └── expected-values.ts             # Known correct outputs
└── README.md
```

### 5.2 Integration Points
- **Import Path**: `@jts/processing-engine/indicator-pipeline`
- **Used By**: `ProcessingEngine`, `FormulaEvaluator`
- **Exports**: `IndicatorPipeline`, indicator calculator functions

---

## 6. Key Interfaces and Contracts

### 6.1 Core Interfaces

```typescript
/**
 * Function signature for indicator calculators
 * @param df - OHLCV DataFrame with timestamp index
 * @returns Pandas Series with indicator values
 */
type IndicatorCalculator = (df: DataFrame) => Series;

/**
 * Configuration for parameterized indicators
 */
interface IndicatorConfig {
  name: string;
  period?: number;
  params?: Record<string, any>;
}

/**
 * Result from batch indicator computation
 */
interface ComputeResult {
  indicators: Map<string, Series>;
  errors: Map<string, Error>;
  computeTime: number; // milliseconds
}
```

### 6.2 DataFrame Structure

**Input Requirements**:
- Index: Datetime timestamps
- Columns: `open`, `high`, `low`, `close`, `volume`
- Sorted chronologically (ascending)
- No missing rows (forward-fill if needed)

**Output Format**:
- Series aligned with input DataFrame index
- NaN for initial periods where indicator cannot be calculated
- Float64 data type

### 6.3 Indicator Naming Convention

**Format**: `{indicator}_{period}` or `{indicator}_{param1}_{param2}`

**Examples**:
- `sma_20`, `sma_50`, `sma_200`
- `ema_12`, `ema_26`
- `rsi_14`
- `atr_14`
- `bb_20_2` (Bollinger Bands: 20 period, 2 std dev)
- `macd_12_26_9`
- `stoch_14_3_3`

---

## 7. Testing Strategy

### 7.1 Unit Testing Approach

**Test Structure**:
```typescript
describe('IndicatorPipeline', () => {
  describe('Registration', () => {
    it('should register custom indicator');
    it('should prevent duplicate registration');
    it('should list all available indicators');
  });

  describe('Computation', () => {
    it('should compute single indicator');
    it('should compute multiple indicators in batch');
    it('should handle missing indicator gracefully');
  });
});

describe('Indicators - SMA', () => {
  it('should calculate SMA(20) correctly');
  it('should handle insufficient data (< 20 candles)');
  it('should match TA-Lib output for SMA(50)');
});
```

### 7.2 Test Data Strategy

**Synthetic Data**:
- Generate known patterns (trending, ranging, volatile)
- Use Faker or custom generators for OHLCV data

**Validation Data**:
- Real market data snapshots with pre-computed indicator values
- Compare against TA-Lib or pandas-ta for correctness

### 7.3 Correctness Validation

**RSI Example**:
```typescript
// Known RSI values for specific dataset
const testCandles = loadFixture('spy-2024-01.csv');
const result = indicatorPipeline.compute(testCandles, ['rsi_14']);
expect(result.get('rsi_14').iloc[-1]).toBeCloseTo(52.34, 2);
```

### 7.4 Performance Benchmarks

**Target**: Process 500 candles with all 11 indicators < 100ms

```typescript
benchmark('All indicators on 500 candles', () => {
  const candles = generateCandles(500);
  const startTime = performance.now();
  indicatorPipeline.compute(candles);
  const elapsed = performance.now() - startTime;
  expect(elapsed).toBeLessThan(100);
});
```

---

## 8. Risks and Mitigations

### 8.1 Technical Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| **Incorrect calculations** | High | Medium | Validate against TA-Lib; use known test vectors; peer review formulas |
| **Performance bottlenecks** | Medium | Low | Use pandas vectorization; avoid loops; benchmark early |
| **NaN propagation issues** | Medium | Medium | Explicit NaN handling; document behavior; test edge cases |
| **Memory usage with large datasets** | Medium | Low | Stream processing for large datasets (future); monitor memory in tests |

### 8.2 Integration Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| **Formula evaluator expects different format** | High | Low | Define clear contract; integration tests with E05 |
| **Caching layer incompatibility** | Medium | Low | Design with serialization in mind; coordinate with F05 |

### 8.3 Indicator-Specific Risks

**RSI**: Wilder's smoothing vs. standard EMA
- **Mitigation**: Document which method is used; provide option for both if needed

**MACD**: Signal line calculation variations
- **Mitigation**: Use standard 12/26/9 configuration; validate against multiple sources

**Stochastic**: Multiple variants (Fast, Slow, Full)
- **Mitigation**: Implement Full Stochastic as default; document clearly

**VWAP**: Requires intraday reset logic for daily timeframes
- **Mitigation**: Assume continuous calculation; document daily reset requirement for future

### 8.4 Operational Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| **Insufficient test coverage** | Medium | Medium | Set coverage gate at 85%; review coverage report |
| **Breaking changes to DataFrame structure** | High | Low | Version interfaces; use type checking; integration tests |
| **Indicator registration conflicts** | Low | Low | Validate unique names; throw error on duplicate registration |

---

## 9. Implementation Checklist

### 9.1 Phase 1: Core Pipeline
- [ ] Create `IndicatorPipeline` class skeleton
- [ ] Implement `register()` method with validation
- [ ] Implement `compute()` method for batch processing
- [ ] Add `getAvailableIndicators()` helper
- [ ] Write unit tests for registration logic
- [ ] Write unit tests for compute logic
- [ ] Document public API

### 9.2 Phase 2: Indicator Implementations
- [ ] Implement SMA (20, 50, 200)
- [ ] Implement EMA (12, 26)
- [ ] Implement RSI (14)
- [ ] Implement ATR (14)
- [ ] Implement Bollinger Bands (20/2)
- [ ] Implement MACD (12/26/9)
- [ ] Implement Stochastic (14/3/3)
- [ ] Implement Volume SMA (20)
- [ ] Implement OBV
- [ ] Implement VWAP
- [ ] Register all default indicators in constructor

### 9.3 Phase 3: Testing
- [ ] Write correctness tests for each indicator
- [ ] Create test fixtures with known values
- [ ] Implement edge case tests (NaN, empty data)
- [ ] Add performance benchmarks
- [ ] Validate test coverage > 85%
- [ ] Cross-check calculations against TA-Lib

### 9.4 Documentation
- [ ] Document each indicator formula
- [ ] Document NaN handling behavior
- [ ] Document performance characteristics
- [ ] Add usage examples
- [ ] Document custom indicator registration

---

## 10. Future Enhancements (Out of Scope)

### 10.1 Advanced Features
- **Adaptive Parameters**: Auto-optimize indicator periods based on volatility
- **Multi-timeframe Indicators**: Calculate indicators on multiple timeframes
- **Composite Indicators**: Combine multiple indicators (e.g., Ichimoku Cloud)
- **Pattern Recognition**: Candlestick patterns, chart patterns

### 10.2 Performance Optimizations
- **Incremental Computation**: Update indicators with new candle instead of full recompute
- **GPU Acceleration**: Use CuPy or similar for massive parallelization
- **Lazy Evaluation**: Compute indicators only when accessed

### 10.3 Ecosystem Integration
- **Indicator Discovery**: Load indicators from plugins or external modules
- **Visual Indicator Editor**: GUI for creating custom indicators
- **Indicator Marketplace**: Share and discover community indicators

---

## 11. References and Resources

### 11.1 Specification Documents
- `/specs/E06/F03/E06-F03.spec.md` - Feature specification
- `/specs/E06/E06.spec.md` - Epic architecture (Section 4.2)

### 11.2 Technical Analysis Resources
- **TA-Lib Documentation**: https://ta-lib.org/function.html
- **pandas-ta Library**: https://github.com/twopirllc/pandas-ta
- **Investopedia Indicator Definitions**: https://www.investopedia.com/technical-analysis-4689657

### 11.3 Implementation Examples
- Pandas rolling/ewm operations: https://pandas.pydata.org/docs/reference/window.html
- RSI calculation: https://school.stockcharts.com/doku.php?id=technical_indicators:relative_strength_index_rsi
- MACD calculation: https://school.stockcharts.com/doku.php?id=technical_indicators:moving_average_convergence_divergence_macd

### 11.4 Testing Resources
- Jest testing best practices
- Pandas testing utilities: `pd.testing.assert_series_equal()`
- Test data generation: `@faker-js/faker` for realistic OHLCV data

---

## 12. Timeline Estimate

| Phase | Tasks | Estimated Effort | Dependencies |
|-------|-------|-----------------|--------------|
| **Phase 1** | Core Pipeline | 4-6 hours | None |
| **Phase 2** | Indicator Implementations | 6-8 hours | Phase 1 |
| **Phase 3** | Testing & Validation | 2-3 hours | Phase 2 |
| **Total** | E06-F03 Complete | **12-17 hours** | E02 models |

**Critical Path**: Phase 1 → Phase 2 → Phase 3 (sequential)

**Parallelization Opportunity**: Individual indicator implementations in Phase 2 can be developed in parallel by different developers.

---

## 13. Acceptance Criteria Mapping

| Spec Criteria | Implementation Approach | Validation Method |
|---------------|------------------------|-------------------|
| IndicatorPipeline class with registration API | `register()` method with Map-based storage | Unit tests verify registration |
| All default indicators registered | 11+ indicators in `_registerDefaults()` | Integration test checks count |
| Batch computation method | `compute()` accepts indicator list | Test with multiple indicators |
| Support for custom indicators | Public `register()` allows external use | Test custom indicator registration |
| Moving averages implemented | SMA/EMA in `moving-averages.ts` | Correctness tests vs TA-Lib |
| RSI calculation correct | RSI in `momentum.ts` | Known value tests |
| ATR calculation correct | ATR in `volatility.ts` | Known value tests |
| Volume indicators implemented | OBV/VWAP in `volume.ts` | Formula validation tests |
| Test coverage > 85% | Comprehensive unit + integration tests | Jest coverage report |

---

**Document Version**: 1.0
**Created**: 2025-12-28
**Status**: Ready for Implementation
