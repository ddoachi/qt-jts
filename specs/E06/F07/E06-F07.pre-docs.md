# E06-F07: Use Cases - Pre-Implementation Planning

## Document Information

| Field | Value |
|-------|-------|
| Feature ID | E06-F07 |
| Title | Use Cases |
| Version | 1.0 |
| Status | Planning |
| Dependencies | E06-F02 (Processing Engine), E06-F04 (Signal Aggregator) |

---

## 1. Overview and Objectives

### 1.1 Purpose

Implement application-layer use cases that provide clean, intuitive entry points for different processing scenarios. The primary focus is on `BatchScanUseCase`, which orchestrates the processing engine components to execute market scanning operations across multiple symbols.

### 1.2 Goals

- **Clean API**: Provide simple, intuitive interfaces that abstract complexity from the UI layer
- **Orchestration**: Coordinate multiple components (engine, aggregator, repositories) seamlessly
- **Result Aggregation**: Combine and format processing results for efficient consumption
- **Error Handling**: Implement graceful error handling with meaningful messages
- **Progress Feedback**: Support progress tracking for long-running operations

### 1.3 Key Deliverables

1. `BatchScanUseCase` class implementation
2. `BatchScanRequest` and `BatchScanResult` DTOs
3. Symbol resolution logic
4. Progress callback integration
5. Comprehensive unit and integration tests

---

## 2. Technical Approach

### 2.1 Architecture Pattern

**Use Case Pattern (Clean Architecture)**
- Use cases act as application service layer
- Coordinate between domain logic and infrastructure
- Keep business logic separate from framework/UI concerns
- Enable testability through dependency injection

### 2.2 Component Interaction

```
┌──────────────────────────────────────────────────────────────────┐
│                        BatchScanUseCase                           │
├──────────────────────────────────────────────────────────────────┤
│                                                                   │
│  1. Validate Request                                              │
│     ↓                                                             │
│  2. Resolve Symbols (ISymbolRepository)                          │
│     ↓                                                             │
│  3. Create ProcessingJob                                          │
│     ↓                                                             │
│  4. Execute Batch (ProcessingEngine) → [ProcessingResult]        │
│     ↓                                                             │
│  5. Aggregate Results (SignalAggregator)                          │
│     ↓                                                             │
│  6. Compute Statistics                                            │
│     ↓                                                             │
│  7. Return BatchScanResult                                        │
│                                                                   │
└──────────────────────────────────────────────────────────────────┘
```

### 2.3 Data Flow

```
Input: BatchScanRequest
  - symbol_list: list[str] OR symbol_criteria: dict
  - timeframe: str (e.g., "1d", "1h")
  - date_range: DateRange
  - formula: Formula
  - parameters: dict[str, Any]
  - progress_callback: Optional[Callable]

Processing:
  1. Symbol Resolution → list[str]
  2. ProcessingJob Creation
  3. Parallel Processing → list[ProcessingResult]
  4. Signal Aggregation → AggregatedSignals
  5. Statistics Calculation → SignalStatistics

Output: BatchScanResult
  - job_id: str
  - signals: AggregatedSignals
  - statistics: SignalStatistics
  - processing_time_ms: float
  - errors: list[dict] (partial failures)
```

### 2.4 Error Handling Strategy

**Defensive Programming Approach**
- Validate inputs early (fail fast)
- Handle empty symbol lists gracefully
- Continue processing on partial failures
- Collect and report errors without stopping execution
- Provide meaningful error messages with context

---

## 3. Dependencies and Prerequisites

### 3.1 Required Components

| Component | Status | Purpose |
|-----------|--------|---------|
| E06-F01: Domain Model | Required | ProcessingJob, ProcessingResult, SignalMatch |
| E06-F02: ProcessingEngine | Required | Core batch processing functionality |
| E06-F04: SignalAggregator | Required | Result aggregation and statistics |
| E02: Storage Layer | Required | Symbol and Candle repositories |
| E05: DSL Parser | Required | Formula evaluation |

### 3.2 External Dependencies

- Python 3.11+
- `asyncio` for async/await support
- `uuid` for unique job ID generation
- `datetime` for timestamp handling
- Type hints (`typing` module)

### 3.3 Interface Contracts

**ISymbolRepository** (from E02)
```python
class ISymbolRepository(ABC):
    @abstractmethod
    async def find_by_criteria(self, criteria: dict) -> list[Symbol]:
        """Find symbols matching criteria"""
        pass

    @abstractmethod
    async def get_by_id(self, symbol_id: int) -> Optional[Symbol]:
        """Get symbol by ID"""
        pass
```

**ProcessingEngine** (from E06-F02)
```python
class ProcessingEngine:
    async def process_batch(
        self,
        job: ProcessingJob,
        progress_callback: Callable[[int, int], None] = None
    ) -> list[ProcessingResult]:
        """Process multiple symbols in parallel"""
        pass
```

**SignalAggregator** (from E06-F04)
```python
class SignalAggregator:
    def aggregate(
        self,
        results: list[ProcessingResult],
        sort_by: str = 'timestamp'
    ) -> AggregatedSignals:
        """Combine results from multiple symbols"""
        pass

    def get_statistics(
        self,
        signals: AggregatedSignals
    ) -> SignalStatistics:
        """Compute statistics on signals"""
        pass
```

---

## 4. Implementation Plan

### 4.1 Task Breakdown

**E06-F07-T01: Create BatchScanUseCase** (Medium Effort)

**Subtasks:**
1. Define DTOs (BatchScanRequest, BatchScanResult)
2. Implement symbol resolution logic
3. Implement BatchScanUseCase.execute()
4. Add error handling and validation
5. Write unit tests
6. Write integration tests

### 4.2 Implementation Steps

#### Step 1: Define Data Transfer Objects (2 hours)

**Files to create:**
- `src/application/dto/batch_scan.py`

**DTOs to define:**
```python
@dataclass
class BatchScanRequest:
    symbol_list: Optional[list[str]] = None
    symbol_criteria: Optional[dict] = None
    timeframe: str = "1d"
    date_range: DateRange = field(default_factory=lambda: DateRange.last_year())
    formula: Optional[Formula] = None
    parameters: dict[str, Any] = field(default_factory=dict)

@dataclass
class BatchScanResult:
    job_id: str
    signals: AggregatedSignals
    statistics: SignalStatistics
    processing_time_ms: float
    total_symbols: int
    successful_symbols: int
    failed_symbols: int
    errors: list[dict] = field(default_factory=list)
```

#### Step 2: Implement Symbol Resolution (2 hours)

**Logic:**
- If `symbol_list` provided: use directly
- If `symbol_criteria` provided: query symbol repository
- If both provided: raise validation error
- If neither provided: raise validation error
- Validate symbol list is not empty

#### Step 3: Implement BatchScanUseCase (4 hours)

**Files to create:**
- `src/application/use_cases/batch_scan_use_case.py`

**Implementation flow:**
1. Validate request
2. Resolve symbols
3. Create ProcessingJob with UUID
4. Execute batch processing with progress callback
5. Separate successful/failed results
6. Aggregate successful results
7. Compute statistics
8. Build BatchScanResult with error summary
9. Return result

#### Step 4: Add Error Handling (1 hour)

**Error scenarios to handle:**
- Empty symbol list → raise `ValueError`
- Invalid formula → raise `ValueError`
- Symbol resolution failure → raise `RepositoryError`
- Processing timeout → partial results with errors
- All symbols failed → return empty result with error list

#### Step 5: Write Unit Tests (3 hours)

**Test cases:**
- Valid request with symbol list
- Valid request with symbol criteria
- Empty symbol list error
- Invalid formula error
- Partial processing failures
- Progress callback invocation
- Statistics calculation accuracy

#### Step 6: Write Integration Tests (2 hours)

**Test scenarios:**
- End-to-end scan with mock repositories
- Multi-symbol processing with real data
- Error propagation and recovery
- Performance validation (small dataset)

### 4.3 Effort Estimation

| Activity | Hours | Notes |
|----------|-------|-------|
| DTOs | 2 | Simple dataclasses |
| Symbol Resolution | 2 | Query logic |
| BatchScanUseCase | 4 | Core orchestration |
| Error Handling | 1 | Validation and exceptions |
| Unit Tests | 3 | 85%+ coverage |
| Integration Tests | 2 | E2E scenarios |
| **Total** | **14** | ~2 days |

---

## 5. File Structure and Locations

### 5.1 Directory Layout

```
src/
├── application/
│   ├── dto/
│   │   ├── __init__.py
│   │   └── batch_scan.py                    # NEW: BatchScanRequest, BatchScanResult
│   └── use_cases/
│       ├── __init__.py
│       └── batch_scan_use_case.py           # NEW: BatchScanUseCase

tests/
├── unit/
│   └── application/
│       └── use_cases/
│           └── test_batch_scan_use_case.py  # NEW: Unit tests
└── integration/
    └── application/
        └── use_cases/
            └── test_batch_scan_integration.py # NEW: Integration tests
```

### 5.2 Module Organization

**Application Layer Structure:**
```python
# src/application/__init__.py
from .dto.batch_scan import BatchScanRequest, BatchScanResult
from .use_cases.batch_scan_use_case import BatchScanUseCase

__all__ = [
    'BatchScanRequest',
    'BatchScanResult',
    'BatchScanUseCase',
]
```

---

## 6. Key Interfaces and Contracts

### 6.1 Public API

**BatchScanUseCase Interface:**
```python
class BatchScanUseCase:
    """Execute formula scan across multiple symbols"""

    def __init__(
        self,
        engine: ProcessingEngine,
        symbol_repo: ISymbolRepository,
        aggregator: SignalAggregator
    ):
        """Initialize use case with dependencies"""
        pass

    async def execute(
        self,
        request: BatchScanRequest,
        progress_callback: Optional[Callable[[int, int], None]] = None
    ) -> BatchScanResult:
        """
        Execute batch scan operation

        Args:
            request: Scan parameters and configuration
            progress_callback: Optional callback for progress updates (completed, total)

        Returns:
            BatchScanResult with signals, statistics, and errors

        Raises:
            ValueError: Invalid request parameters
            RepositoryError: Symbol resolution failed
        """
        pass
```

### 6.2 Internal Methods

```python
async def _resolve_symbols(self, request: BatchScanRequest) -> list[str]:
    """Resolve symbol list from request"""
    pass

def _validate_request(self, request: BatchScanRequest) -> None:
    """Validate request parameters"""
    pass

def _create_job(
    self,
    symbols: list[str],
    request: BatchScanRequest
) -> ProcessingJob:
    """Create ProcessingJob from request"""
    pass

def _build_result(
    self,
    job_id: str,
    results: list[ProcessingResult],
    processing_time: float
) -> BatchScanResult:
    """Build final result from processing results"""
    pass
```

### 6.3 Progress Callback Contract

```python
ProgressCallback = Callable[[int, int], None]
# Args: (completed: int, total: int)
# Returns: None
# Example: lambda completed, total: print(f"{completed}/{total}")
```

---

## 7. Testing Strategy

### 7.1 Unit Testing Approach

**Test Framework:** pytest with pytest-asyncio

**Test Coverage Targets:**
- Line coverage: >85%
- Branch coverage: >80%
- All error paths tested

**Mock Strategy:**
- Mock `ProcessingEngine` to control results
- Mock `ISymbolRepository` for symbol resolution
- Mock `SignalAggregator` for aggregation logic
- Use fixtures for common test data

**Key Test Cases:**

1. **Happy Path Tests**
   - Execute with valid symbol list
   - Execute with symbol criteria
   - Progress callback invoked correctly
   - Result contains expected data

2. **Error Handling Tests**
   - Empty symbol list raises error
   - Invalid formula raises error
   - Partial failures handled gracefully
   - All failures return empty result

3. **Edge Cases**
   - Single symbol scan
   - Large symbol list (1000+)
   - No matches found
   - Formula returns no signals

### 7.2 Integration Testing Approach

**Test Setup:**
- Use in-memory repositories
- Real ProcessingEngine instance
- Real SignalAggregator instance
- Small test dataset (10-20 symbols)

**Test Scenarios:**

1. **End-to-End Scan**
   - Load test data
   - Execute scan
   - Verify results
   - Check statistics accuracy

2. **Error Recovery**
   - Simulate missing data for some symbols
   - Verify partial results returned
   - Check error reporting

3. **Performance Validation**
   - Measure execution time
   - Verify parallel processing
   - Check memory usage

### 7.3 Test Data Requirements

**Mock Data:**
- 20 test symbols with OHLCV data
- 100 candles per symbol (daily)
- Date range: 2024-01-01 to 2024-12-31
- Test formulas: simple crossover, RSI threshold

**Fixtures:**
```python
@pytest.fixture
def sample_request():
    return BatchScanRequest(
        symbol_list=["TEST1", "TEST2", "TEST3"],
        timeframe="1d",
        date_range=DateRange(date(2024, 1, 1), date(2024, 12, 31)),
        formula=Formula(id=1, name="Test", expression="close > sma(close, 20)")
    )

@pytest.fixture
def mock_engine():
    engine = MagicMock(spec=ProcessingEngine)
    # Configure mock behavior
    return engine
```

---

## 8. Risks and Mitigations

### 8.1 Technical Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Symbol resolution performance with large criteria | High | Medium | Implement caching, add pagination support |
| ProcessingEngine not ready | High | Low | Use mock in tests, coordinate with F02 team |
| SignalAggregator interface changes | Medium | Low | Define contract early, use adapter if needed |
| Memory issues with large result sets | Medium | Medium | Stream results, implement pagination |
| Timeout handling complexity | Low | Medium | Use existing ProcessingEngine timeout mechanism |

### 8.2 Integration Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Dependency version mismatches | Medium | Low | Pin versions in requirements, integration tests |
| Repository interface changes | Medium | Low | Use abstract interfaces, adapter pattern |
| Formula evaluation errors | Medium | Medium | Comprehensive error handling, validation |

### 8.3 Schedule Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| F02 or F04 delayed | High | Low | Implement with mocks first, integrate later |
| Complex edge cases emerge | Medium | Medium | TDD approach, incremental development |
| Test data preparation overhead | Low | Medium | Reuse E06 test fixtures |

### 8.4 Mitigation Strategies

**Risk 1: Large Symbol Sets**
- **Current scope**: Support up to 2,500 symbols (per PRD)
- **Mitigation**: Validate symbol list size, add warning for >1000 symbols
- **Future**: Implement batching if needed

**Risk 2: Partial Failures**
- **Approach**: Continue processing on individual failures
- **Reporting**: Collect all errors, return with partial results
- **UX**: UI can display warnings but show available results

**Risk 3: Progress Callback Overhead**
- **Solution**: Throttle callbacks (update every 10 symbols)
- **Testing**: Verify callback doesn't slow processing

**Risk 4: Memory Management**
- **Solution**: ProcessingEngine handles parallelization
- **Monitoring**: Track memory in integration tests
- **Limit**: Fail fast if result set exceeds reasonable size

---

## 9. Success Criteria

### 9.1 Functional Requirements

- [ ] BatchScanUseCase accepts valid BatchScanRequest
- [ ] Symbol resolution works for both list and criteria
- [ ] Creates and executes ProcessingJob correctly
- [ ] Aggregates results using SignalAggregator
- [ ] Returns BatchScanResult with complete statistics
- [ ] Progress callback invoked during processing
- [ ] Handles empty symbol list gracefully
- [ ] Handles invalid formula gracefully
- [ ] Returns partial results on processing errors
- [ ] All error messages are clear and actionable

### 9.2 Non-Functional Requirements

- [ ] Code coverage >85%
- [ ] All tests pass
- [ ] Type hints on all public methods
- [ ] Docstrings follow Google style
- [ ] No pylint errors or warnings
- [ ] Integration tests run in <5 seconds

### 9.3 Quality Gates

**Before PR Creation:**
1. All unit tests pass
2. All integration tests pass
3. Coverage report shows >85%
4. Manual testing with sample data
5. Code review with team lead

**Acceptance Checklist:**
- [ ] DTOs defined and documented
- [ ] BatchScanUseCase implemented
- [ ] Symbol resolution logic complete
- [ ] Error handling comprehensive
- [ ] Unit tests written and passing
- [ ] Integration tests written and passing
- [ ] Documentation complete
- [ ] Code reviewed and approved

---

## 10. Future Considerations

### 10.1 Extensibility Points

**Additional Use Cases (Out of Scope for F07):**
- `BacktestUseCase` (E10) - similar structure, different orchestration
- `PatternDiscoveryUseCase` (E08) - ML-based pattern detection
- `LiveScanUseCase` (E07) - real-time streaming variant

**Design Considerations:**
- Use case base class for common functionality
- Shared validation logic
- Reusable result formatting

### 10.2 Performance Optimization Opportunities

**Future Enhancements:**
- Result caching for repeated scans
- Symbol list pre-validation
- Async symbol resolution
- Result streaming for very large datasets

### 10.3 Monitoring and Observability

**Future Additions:**
- Execution time metrics
- Success/failure rates
- Symbol count distribution
- Error categorization
- Usage patterns analytics

---

## 11. References

### 11.1 Related Specifications

- E06.spec.md - Epic overview and architecture
- E06-F02.spec.md - Processing Engine Core
- E06-F04.spec.md - Signal Aggregator
- E06-F07.spec.md - This feature specification

### 11.2 External Resources

- [Clean Architecture Use Cases](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Python asyncio documentation](https://docs.python.org/3/library/asyncio.html)
- [pytest-asyncio](https://pytest-asyncio.readthedocs.io/)

### 11.3 Design Patterns

- **Use Case Pattern**: Application service layer
- **DTO Pattern**: Data transfer objects for API boundaries
- **Dependency Injection**: Constructor injection for testability
- **Strategy Pattern**: Pluggable symbol resolution strategies

---

## Document Changelog

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2025-12-28 | System | Initial pre-implementation planning document |
