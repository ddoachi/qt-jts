# Spec: E06-F01-T01 - Define ProcessingJob and ProcessingResult

---

## Frontmatter

```yaml
id: E06-F01-T01
clickup_task_id: ''
title: Define ProcessingJob and ProcessingResult
type: task
parent: E06-F01
children: []
epic: E06
feature: F01
task: T01
domain: Domain Model
status: draft
priority: medium
created: '2024-12-28'
updated: '2024-12-28'
due_date: ''
estimated_hours: 0
actual_hours: 0
tags: []
effort: S
risk: low
```

---

## Status

**Current Status**: Draft
**Last Updated**: 2024-12-28

---

## Executive Summary

Define the core domain entities `ProcessingJob` and `ProcessingResult` that represent a batch processing job and its outcome. These are the fundamental building blocks for all processing operations in the JTS processing layer.

**Objectives:**
1. Define ProcessingJob dataclass with job configuration
2. Define ProcessingResult dataclass with processing outcome
3. Define supporting types (JobType, SignalType, SignalMatch, DateRange)
4. Ensure proper type hints and immutability where appropriate

---

## Execution Flow

1. Create domain model structure under `libs/processing/src/jts_processing/domain/`
2. Implement enum classes: JobType, SignalType
3. Implement value objects: DateRange, SignalMatch
4. Implement entity classes: ProcessingJob, ProcessingResult
5. Export all types from domain `__init__.py`
6. Write unit tests for entity creation and behavior
7. Validate immutability constraints

---

## User Stories

As a **processing engine developer**, I want to have well-defined domain entities so that I can build processing logic on a stable, type-safe foundation.

As a **system architect**, I want clear separation between mutable job configuration and immutable results so that I can ensure data integrity throughout the processing pipeline.

---

## Acceptance Scenarios

**Scenario 1: Create a ProcessingJob**
- Given: A job request with scan parameters
- When: Creating a ProcessingJob instance
- Then: Job should have all required fields (id, job_type, symbols, timeframe, date_range)

**Scenario 2: ProcessingResult Immutability**
- Given: A ProcessingResult instance with signal matches
- When: Attempting to modify result fields
- Then: The operation should fail with FrozenInstanceError

**Scenario 3: Type Enumeration Validation**
- Given: Domain entity definitions
- When: Creating entities with enum values
- Then: Only valid enum values (SCAN, BACKTEST, PATTERN_DISCOVERY) should be accepted for JobType

---

## Requirements

### Functional Requirements

1. **ProcessingJob Entity**
   - Must have fields: id, job_type, symbols, timeframe, date_range
   - Must support optional formula and parameters fields
   - Must track creation timestamp
   - Must be mutable to allow parameter updates

2. **ProcessingResult Entity**
   - Must have fields: symbol, matches, computed_indicators, processing_time_ms
   - Must be immutable (frozen dataclass)
   - Must support optional error field for failure cases
   - Matches must be stored as tuples for immutability

3. **Supporting Types**
   - JobType enum: SCAN, BACKTEST, PATTERN_DISCOVERY
   - SignalType enum: ENTRY, EXIT, SCAN_HIT
   - DateRange value object with start and end dates
   - SignalMatch value object with timestamp, candle, signal_type, indicator_values

### Non-Functional Requirements

1. Type safety: All classes must have proper type hints
2. Immutability: ProcessingResult must be frozen; DateRange and SignalMatch must be frozen
3. Mutability: ProcessingJob must allow parameter updates
4. Code organization: Clear separation of concerns (entities, value objects, enums)

### Technical Constraints

1. Must use Python dataclasses (frozen and unfrozen variants)
2. Must use typing module for proper type hints
3. Must integrate with Candle entity from E02 (Storage Layer)
4. Must follow domain-driven design patterns

---

## Key Entities

### ProcessingJob (Entity - Mutable)
```python
@dataclass(frozen=False)
class ProcessingJob:
    """A batch processing job"""
    id: str
    job_type: JobType
    symbols: list[str]
    timeframe: str
    date_range: DateRange
    formula: Optional[Formula] = None
    parameters: dict[str, Any] = field(default_factory=dict)
    created_at: datetime = field(default_factory=datetime.utcnow)
```

### ProcessingResult (Entity - Immutable)
```python
@dataclass(frozen=True)
class ProcessingResult:
    """Result from processing a single symbol"""
    symbol: str
    matches: tuple[SignalMatch, ...]
    computed_indicators: dict[str, Any]
    processing_time_ms: float
    error: Optional[str] = None
```

### Supporting Value Objects & Enums
- **JobType**: Enum with SCAN, BACKTEST, PATTERN_DISCOVERY
- **SignalType**: Enum with ENTRY, EXIT, SCAN_HIT
- **DateRange**: Value object with start and end dates (frozen)
- **SignalMatch**: Value object with timestamp, candle, signal_type, indicator_values (frozen)

---

## Dependencies

- **E02 (Storage Layer)**: Provides Candle entity
- **E06-F01 (Domain Model)**: Parent feature
- **E06 (Processing Core)**: Parent epic

---

## Gate Checks

- [ ] All type hints are present and correct
- [ ] ProcessingJob is mutable (not frozen)
- [ ] ProcessingResult is immutable (frozen=True)
- [ ] All supporting types are properly defined
- [ ] No circular dependencies
- [ ] Code follows project style guide

---

## Tasks Preview

This task has no subtasks. It is a leaf task in the feature decomposition.

---

## Success Criteria

- [ ] ProcessingJob dataclass created with all required fields
- [ ] ProcessingResult dataclass created as immutable (frozen)
- [ ] JobType enumeration with SCAN, BACKTEST, PATTERN_DISCOVERY
- [ ] SignalType enumeration with ENTRY, EXIT, SCAN_HIT
- [ ] DateRange value object implemented
- [ ] SignalMatch value object implemented
- [ ] Unit tests cover entity creation
- [ ] Unit tests verify ProcessingResult immutability
- [ ] All types exported from domain `__init__.py`
- [ ] Code passes linting and type checking

---

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|-----------|
| Type hint errors cause runtime issues | Low | Medium | Use mypy type checking in CI |
| Immutability constraints cause friction | Low | Medium | Document mutable vs immutable design |
| Missing Candle entity reference | Low | High | Verify E02 Storage Layer integration |
| Performance impact of frozen dataclasses | Very Low | Low | Benchmark if needed later |

---

## Notes and Clarifications

### Design Decisions

1. **ProcessingJob Mutability**: Made mutable to allow parameter adjustments before job execution
2. **ProcessingResult Immutability**: Made immutable to prevent accidental modification of results
3. **Tuple for Matches**: Using tuple instead of list for immutability guarantee
4. **Default Factories**: Used for collections to avoid mutable default arguments

### Implementation Path

1. Create directory structure under `libs/processing/src/jts_processing/domain/`
2. Implement enums first: `job_type.py`, `signal_type.py`
3. Implement value objects: `date_range.py`, `signal_match.py`
4. Implement entities: `processing_job.py`, `processing_result.py`
5. Update `__init__.py` files to export all types
6. Write comprehensive unit tests

---

## Artifacts

### File Structure
```
libs/processing/src/jts_processing/domain/
├── __init__.py
├── entities/
│   ├── __init__.py
│   ├── processing_job.py
│   └── processing_result.py
├── value_objects/
│   ├── __init__.py
│   ├── date_range.py
│   └── signal_match.py
└── enums/
    ├── __init__.py
    ├── job_type.py
    └── signal_type.py
```

### Test File
```
libs/processing/tests/unit/domain/test_entities.py
libs/processing/tests/unit/domain/test_value_objects.py
```

---

## Metadata

| Property | Value |
|----------|-------|
| Task ID | E06-F01-T01 |
| Feature | E06-F01: Domain Model |
| Epic | E06: Processing Core |
| Effort Estimate | S (Small) |
| Status | Draft |
| Created | 2024-12-28 |
| Updated | 2024-12-28 |
| Dependencies | E02 (Storage Layer), E06-F01 (parent) |
