# Pre-Implementation Planning: E06-F01 Domain Model

## 1. Overview and Objectives

### 1.1 Purpose
Implement the core domain entities for the Processing Engine (E06) that will serve as the foundational data structures for batch processing, signal generation, and result aggregation. These entities establish clear contracts between processing components and enable type-safe operations throughout the system.

### 1.2 Key Objectives
- Define strongly-typed domain entities representing processing jobs, results, and execution contexts
- Establish clear boundaries between mutable state (jobs, contexts) and immutable results
- Enable serialization-ready structures for caching and persistence
- Provide intuitive APIs for indicator management during processing
- Ensure compatibility with existing E02 Storage Layer entities (Symbol, Candle, Formula)

### 1.3 Success Criteria
- All domain entities are implemented with proper type hints
- Immutability is enforced where appropriate (ProcessingResult, value objects)
- Unit test coverage exceeds 85%
- All entities are properly exported from domain module
- Documentation includes usage examples

## 2. Technical Approach

### 2.1 Design Principles

**Domain-Driven Design (DDD)**
- Entities: `ProcessingJob`, `ProcessingContext` (mutable, identity-based)
- Value Objects: `ProcessingResult`, `SignalMatch`, `DateRange` (immutable, value-based)
- Enumerations: `JobType`, `SignalType` (type-safe constants)

**Type Safety Strategy**
- Python 3.10+ type hints throughout
- Use `frozen=True` for immutable dataclasses
- Use `tuple` instead of `list` for immutable collections in frozen dataclasses
- Leverage `Optional` and `Union` types appropriately

**Immutability Patterns**
- `ProcessingResult`: Frozen to prevent modification after creation
- `SignalMatch`: Frozen to ensure signal data integrity
- `DateRange`: Frozen value object representing a time period
- `ProcessingJob`: Mutable to allow parameter updates before execution
- `ProcessingContext`: Mutable to accumulate indicators during processing

### 2.2 Module Architecture

```
libs/processing/src/jts_processing/domain/
├── __init__.py                  # Public API exports
├── entities/
│   ├── __init__.py
│   ├── processing_job.py        # ProcessingJob entity
│   ├── processing_result.py     # ProcessingResult value object
│   └── processing_context.py    # ProcessingContext entity
├── value_objects/
│   ├── __init__.py
│   ├── date_range.py            # DateRange value object
│   └── signal_match.py          # SignalMatch value object
└── enums/
    ├── __init__.py
    ├── job_type.py              # JobType enumeration
    └── signal_type.py           # SignalType enumeration
```

### 2.3 Integration Points

**Dependencies from E02 Storage Layer:**
- `Symbol` entity: Used in ProcessingContext
- `Candle` value object: Used in SignalMatch
- `Formula` entity: Referenced in ProcessingJob
- Repository interfaces: For future persistence

**Data Flow:**
```
ProcessingJob (Configuration)
    └─> ProcessingEngine
        └─> ProcessingContext (Per-symbol state)
            └─> ProcessingResult (Per-symbol outcome)
                └─> SignalMatch[] (Individual signals)
```

## 3. Dependencies and Prerequisites

### 3.1 External Dependencies
- **Python 3.10+**: Required for dataclass features and type hints
- **pandas**: For indicator series storage in ProcessingContext
- **Python Standard Library**: `dataclasses`, `enum`, `datetime`, `typing`

### 3.2 Internal Dependencies
- **E02 Storage Layer**: Must be implemented first
  - `Symbol` entity for context
  - `Candle` value object for signal matches
  - `Formula` entity for job configuration
  - Enums: `Market`, `Timeframe` (if needed)

### 3.3 Development Prerequisites
- Project structure: `libs/processing/src/jts_processing/` directory exists
- Testing framework: pytest configured
- Type checking: mypy or similar configured (recommended)
- Code formatting: black/ruff configured (recommended)

## 4. Implementation Plan

### 4.1 Phase 1: Enumerations and Value Objects (T01 - Part 1)

**Step 1.1: Create JobType enumeration**
- File: `enums/job_type.py`
- Define: `SCAN`, `BACKTEST`, `PATTERN_DISCOVERY` values
- Add docstrings explaining each type

**Step 1.2: Create SignalType enumeration**
- File: `enums/signal_type.py`
- Define: `ENTRY`, `EXIT`, `SCAN_HIT` values
- Document signal semantics

**Step 1.3: Create DateRange value object**
- File: `value_objects/date_range.py`
- Implement frozen dataclass with `start` and `end` dates
- Add validation: `end >= start`
- Include helper methods: `days()`, `contains(date)`, `overlaps(other)`

**Step 1.4: Create SignalMatch value object**
- File: `value_objects/signal_match.py`
- Implement frozen dataclass
- Fields: `timestamp`, `candle`, `signal_type`, `indicator_values`, `metadata`
- Import `Candle` from E02

### 4.2 Phase 2: Core Entities (T01 - Part 2)

**Step 2.1: Create ProcessingJob entity**
- File: `entities/processing_job.py`
- Implement mutable dataclass (no `frozen=True`)
- Fields: `id`, `job_type`, `symbols`, `timeframe`, `date_range`, `formula`, `parameters`, `created_at`
- Add method: `with_parameters(**kwargs)` to update parameters
- Add validation: symbols list not empty

**Step 2.2: Create ProcessingResult value object**
- File: `entities/processing_result.py`
- Implement frozen dataclass
- Fields: `symbol`, `matches` (tuple), `computed_indicators`, `processing_time_ms`, `error`
- Add properties: `success`, `match_count`
- Add factory method: `from_error(symbol, error_msg)`

### 4.3 Phase 3: ProcessingContext Entity (T02)

**Step 3.1: Create ProcessingContext entity**
- File: `entities/processing_context.py`
- Implement mutable dataclass
- Fields: `symbol`, `candles`, `indicators` (dict)
- Methods: `add_indicator()`, `get_indicator()`, `has_indicator()`, `get_latest_values()`
- Handle pandas Series for indicators

**Step 3.2: Define CandleSeries type alias**
- Support both `pd.DataFrame` and `list[Candle]`
- Add type alias for flexibility

### 4.4 Phase 4: Module Integration

**Step 4.1: Create __init__.py exports**
- Export all public entities, value objects, and enums
- Create logical groupings
- Add module-level docstring

**Step 4.2: Documentation**
- Add docstrings to all classes and methods
- Include usage examples in module docstrings
- Document field meanings and constraints

### 4.5 Phase 5: Testing

**Step 5.1: Unit tests for enumerations**
- Test all enum values exist
- Test string conversion

**Step 5.2: Unit tests for value objects**
- DateRange: creation, validation, helper methods
- SignalMatch: creation, immutability

**Step 5.3: Unit tests for entities**
- ProcessingJob: creation, parameter updates
- ProcessingResult: creation, properties, factory methods
- ProcessingContext: indicator management, latest values

**Step 5.4: Integration tests**
- End-to-end entity creation flow
- Serialization/deserialization (if needed)

## 5. File Structure and Locations

### 5.1 Directory Layout
```
libs/processing/
├── src/
│   └── jts_processing/
│       ├── __init__.py
│       └── domain/
│           ├── __init__.py                    # Public exports
│           ├── entities/
│           │   ├── __init__.py
│           │   ├── processing_job.py          # ~80 lines
│           │   ├── processing_result.py       # ~60 lines
│           │   └── processing_context.py      # ~70 lines
│           ├── value_objects/
│           │   ├── __init__.py
│           │   ├── date_range.py              # ~50 lines
│           │   └── signal_match.py            # ~40 lines
│           └── enums/
│               ├── __init__.py
│               ├── job_type.py                # ~20 lines
│               └── signal_type.py             # ~20 lines
└── tests/
    └── domain/
        ├── test_processing_job.py
        ├── test_processing_result.py
        ├── test_processing_context.py
        ├── test_date_range.py
        ├── test_signal_match.py
        └── test_enums.py
```

### 5.2 Estimated File Sizes
- Total production code: ~340 lines
- Total test code: ~500-600 lines (comprehensive coverage)

## 6. Key Interfaces and Contracts

### 6.1 ProcessingJob Interface

```python
@dataclass
class ProcessingJob:
    """
    Represents a batch processing job configuration.

    Mutable entity allowing parameter updates before execution.
    """
    id: str
    job_type: JobType
    symbols: list[str]
    timeframe: str
    date_range: DateRange
    formula: Optional[Formula] = None
    parameters: dict[str, Any] = field(default_factory=dict)
    created_at: datetime = field(default_factory=datetime.utcnow)

    def with_parameters(self, **kwargs) -> 'ProcessingJob':
        """Create copy with updated parameters"""
        ...
```

**Contract:**
- `id`: Unique identifier (UUID recommended)
- `job_type`: Type of processing operation
- `symbols`: Non-empty list of symbol codes
- `timeframe`: Valid timeframe string ("1d", "1h", etc.)
- `date_range`: Valid date range (end >= start)
- `formula`: Optional formula for scan/backtest
- `parameters`: Flexible parameter dictionary
- `created_at`: Auto-populated creation timestamp

### 6.2 ProcessingResult Interface

```python
@dataclass(frozen=True)
class ProcessingResult:
    """
    Immutable result from processing a single symbol.

    Represents either successful processing with matches
    or an error condition.
    """
    symbol: str
    matches: tuple[SignalMatch, ...]
    computed_indicators: dict[str, Any]
    processing_time_ms: float
    error: Optional[str] = None

    @property
    def success(self) -> bool:
        """True if no error occurred"""
        return self.error is None

    @property
    def match_count(self) -> int:
        """Number of signal matches"""
        return len(self.matches)

    @staticmethod
    def from_error(symbol: str, error_msg: str) -> 'ProcessingResult':
        """Factory for error results"""
        ...
```

**Contract:**
- `symbol`: Symbol code that was processed
- `matches`: Tuple of signal matches (immutable)
- `computed_indicators`: Dictionary of indicator names to values
- `processing_time_ms`: Elapsed time in milliseconds
- `error`: None for success, error message for failure
- Immutable after creation (frozen)

### 6.3 ProcessingContext Interface

```python
@dataclass
class ProcessingContext:
    """
    Mutable context holding state during symbol processing.

    Accumulates computed indicators and provides access
    to candle data.
    """
    symbol: Symbol
    candles: Union[pd.DataFrame, list[Candle]]
    indicators: dict[str, pd.Series] = field(default_factory=dict)

    def add_indicator(self, name: str, values: pd.Series) -> None:
        """Add computed indicator to context"""
        ...

    def get_indicator(self, name: str) -> Optional[pd.Series]:
        """Retrieve indicator by name"""
        ...

    def has_indicator(self, name: str) -> bool:
        """Check if indicator exists"""
        ...

    def get_latest_values(self) -> dict[str, float]:
        """Get latest value for all indicators"""
        ...
```

**Contract:**
- `symbol`: Symbol entity being processed
- `candles`: Candle data (DataFrame or list)
- `indicators`: Dictionary of computed indicators
- Methods are side-effect free (get/has) or clearly mutating (add)

### 6.4 Value Objects and Enums

```python
class JobType(Enum):
    """Type of processing job"""
    SCAN = "scan"
    BACKTEST = "backtest"
    PATTERN_DISCOVERY = "pattern_discovery"

class SignalType(Enum):
    """Type of signal generated"""
    ENTRY = "entry"
    EXIT = "exit"
    SCAN_HIT = "scan_hit"

@dataclass(frozen=True)
class DateRange:
    """Immutable date range"""
    start: date
    end: date

    def __post_init__(self):
        if self.end < self.start:
            raise ValueError("end must be >= start")

    def days(self) -> int:
        """Number of days in range"""
        ...

@dataclass(frozen=True)
class SignalMatch:
    """Immutable signal match at a specific point"""
    timestamp: datetime
    candle: Candle
    signal_type: SignalType
    indicator_values: dict[str, float]
    metadata: dict[str, Any] = field(default_factory=dict)
```

## 7. Testing Strategy

### 7.1 Unit Testing Approach

**Test Coverage Targets:**
- Line coverage: > 85%
- Branch coverage: > 80%
- All public methods tested
- All edge cases covered

**Test Organization:**
```
tests/domain/
├── test_enums.py              # Enum value tests
├── test_date_range.py         # Value object tests
├── test_signal_match.py       # Value object tests
├── test_processing_job.py     # Entity tests
├── test_processing_result.py  # Entity tests
└── test_processing_context.py # Entity tests
```

### 7.2 Test Cases by Component

**Enumerations:**
- All values are defined
- String conversion works correctly
- Comparison and equality work

**DateRange:**
- Valid creation
- Validation rejects invalid ranges
- `days()` calculation is correct
- `contains()` boundary conditions
- `overlaps()` various scenarios

**SignalMatch:**
- Creation with all fields
- Immutability enforcement
- Default metadata dictionary

**ProcessingJob:**
- Creation with required fields
- Default values for optional fields
- Parameter updates
- Validation (non-empty symbols)
- Timestamp auto-generation

**ProcessingResult:**
- Success case creation
- Error case creation
- Factory method `from_error()`
- Properties: `success`, `match_count`
- Immutability enforcement
- Empty matches handling

**ProcessingContext:**
- Creation with symbol and candles
- Adding indicators
- Retrieving indicators
- Checking indicator existence
- Getting latest values (with NaN handling)
- Multiple indicator management

### 7.3 Test Examples

```python
# test_processing_job.py
def test_processing_job_creation():
    """Should create job with all required fields"""
    job = ProcessingJob(
        id="test-123",
        job_type=JobType.SCAN,
        symbols=["005930", "000660"],
        timeframe="1d",
        date_range=DateRange(date(2024, 1, 1), date(2024, 12, 31))
    )
    assert job.id == "test-123"
    assert job.job_type == JobType.SCAN
    assert len(job.symbols) == 2
    assert job.parameters == {}
    assert isinstance(job.created_at, datetime)

def test_processing_job_with_parameters():
    """Should allow parameter updates"""
    job = ProcessingJob(...)
    updated = job.with_parameters(threshold=0.7, min_volume=1000000)
    assert updated.parameters["threshold"] == 0.7

# test_processing_result.py
def test_processing_result_success():
    """Should create successful result"""
    match = SignalMatch(...)
    result = ProcessingResult(
        symbol="005930",
        matches=(match,),
        computed_indicators={"sma_20": [100, 101, 102]},
        processing_time_ms=15.5
    )
    assert result.success is True
    assert result.match_count == 1

def test_processing_result_from_error():
    """Should create error result via factory"""
    result = ProcessingResult.from_error("005930", "No data available")
    assert result.success is False
    assert result.error == "No data available"
    assert result.match_count == 0

def test_processing_result_immutability():
    """Should prevent modification after creation"""
    result = ProcessingResult(...)
    with pytest.raises(FrozenInstanceError):
        result.symbol = "different"

# test_processing_context.py
def test_processing_context_indicator_management():
    """Should manage indicators correctly"""
    symbol = Symbol(id=1, code="005930", name="Samsung", market=Market.KOSPI)
    df = pd.DataFrame({"close": [100, 101, 102]})
    context = ProcessingContext(symbol=symbol, candles=df)

    # Add indicator
    sma = pd.Series([100, 100.5, 101])
    context.add_indicator("sma_20", sma)

    # Verify
    assert context.has_indicator("sma_20")
    retrieved = context.get_indicator("sma_20")
    pd.testing.assert_series_equal(retrieved, sma)

def test_processing_context_latest_values():
    """Should get latest values correctly"""
    context = ProcessingContext(...)
    context.add_indicator("sma", pd.Series([100, 100.5, 101]))
    context.add_indicator("rsi", pd.Series([50, 55, 60]))
    context.add_indicator("bad", pd.Series([1, 2, np.nan]))  # NaN should be excluded

    latest = context.get_latest_values()
    assert latest["sma"] == 101
    assert latest["rsi"] == 60
    assert "bad" not in latest  # NaN excluded

# test_date_range.py
def test_date_range_validation():
    """Should reject invalid date ranges"""
    with pytest.raises(ValueError, match="end must be >= start"):
        DateRange(start=date(2024, 12, 31), end=date(2024, 1, 1))

def test_date_range_days_calculation():
    """Should calculate days correctly"""
    dr = DateRange(start=date(2024, 1, 1), end=date(2024, 1, 10))
    assert dr.days() == 9  # Inclusive
```

### 7.4 Test Data Fixtures

```python
# conftest.py
import pytest
from datetime import date, datetime
from decimal import Decimal

@pytest.fixture
def sample_symbol():
    return Symbol(id=1, code="005930", name="Samsung", market=Market.KOSPI)

@pytest.fixture
def sample_candle():
    return Candle(
        timestamp=datetime(2024, 1, 1, 9, 0),
        open=Decimal("100.0"),
        high=Decimal("105.0"),
        low=Decimal("99.0"),
        close=Decimal("103.0"),
        volume=1000000
    )

@pytest.fixture
def sample_date_range():
    return DateRange(start=date(2024, 1, 1), end=date(2024, 12, 31))

@pytest.fixture
def sample_processing_job(sample_date_range):
    return ProcessingJob(
        id="test-job-1",
        job_type=JobType.SCAN,
        symbols=["005930", "000660"],
        timeframe="1d",
        date_range=sample_date_range
    )
```

## 8. Risks and Mitigations

### 8.1 Type Safety Risks

**Risk:** Python's dynamic typing may allow invalid data
**Mitigation:**
- Use type hints consistently
- Configure mypy for strict type checking
- Add runtime validation in `__post_init__` methods
- Use pydantic if stronger validation is needed later

### 8.2 Serialization Challenges

**Risk:** Complex objects may not serialize easily for caching
**Mitigation:**
- Use simple types where possible (dict, tuple, primitives)
- Avoid circular references
- Consider adding `to_dict()` and `from_dict()` methods if needed
- Test serialization with pickle/json early

### 8.3 Pandas Dependency in Context

**Risk:** Tight coupling to pandas may limit flexibility
**Mitigation:**
- Use type alias `CandleSeries = Union[pd.DataFrame, list[Candle]]`
- Consider protocol/interface for indicator storage
- Keep pandas usage isolated to ProcessingContext
- Document pandas version requirements

### 8.4 Immutability Enforcement

**Risk:** Frozen dataclasses with mutable fields (dict) can still be modified
**Mitigation:**
- Document which fields should not be modified externally
- Use `tuple` instead of `list` for collections in frozen classes
- Consider using `frozendict` or similar for truly immutable dicts
- Add tests verifying immutability

### 8.5 Performance with Large Result Sets

**Risk:** Creating many ProcessingResult objects may be memory-intensive
**Mitigation:**
- Use `__slots__` in dataclasses if memory becomes an issue
- Consider generator patterns for streaming results
- Profile memory usage with realistic datasets
- Implement result pagination/batching if needed

### 8.6 Compatibility with E02 Entities

**Risk:** Changes to E02 entities may break domain model
**Mitigation:**
- Define clear dependency on E02 public API only
- Use abstract imports from E02's `__init__.py`
- Add integration tests with real E02 entities
- Version-pin E02 dependency

### 8.7 Testing Isolation

**Risk:** Tests may depend on E02 implementation details
**Mitigation:**
- Mock E02 entities in unit tests where possible
- Create test fixtures for Symbol, Candle, Formula
- Keep integration tests separate from unit tests
- Use in-memory repositories from E02 for testing

### 8.8 Date/Time Handling

**Risk:** Timezone issues with datetime objects
**Mitigation:**
- Standardize on UTC for all internal timestamps
- Document timezone requirements
- Use `datetime.utcnow()` consistently
- Consider timezone-aware datetimes if needed

## 9. Implementation Checklist

### Phase 1: Setup
- [ ] Create directory structure: `libs/processing/src/jts_processing/domain/`
- [ ] Create all `__init__.py` files
- [ ] Set up test directory: `libs/processing/tests/domain/`
- [ ] Configure pytest and test fixtures

### Phase 2: Enumerations
- [ ] Implement `JobType` enum
- [ ] Implement `SignalType` enum
- [ ] Write enum tests
- [ ] Export from enums `__init__.py`

### Phase 3: Value Objects
- [ ] Implement `DateRange` with validation
- [ ] Add `DateRange` helper methods: `days()`, `contains()`, `overlaps()`
- [ ] Write `DateRange` tests
- [ ] Implement `SignalMatch`
- [ ] Write `SignalMatch` tests
- [ ] Export from value_objects `__init__.py`

### Phase 4: Entities (T01)
- [ ] Implement `ProcessingJob`
- [ ] Add `ProcessingJob.with_parameters()` method
- [ ] Write `ProcessingJob` tests
- [ ] Implement `ProcessingResult`
- [ ] Add `ProcessingResult` properties and factory methods
- [ ] Write `ProcessingResult` tests
- [ ] Export from entities `__init__.py`

### Phase 5: ProcessingContext (T02)
- [ ] Implement `ProcessingContext`
- [ ] Add indicator management methods
- [ ] Add `get_latest_values()` method
- [ ] Write `ProcessingContext` tests
- [ ] Handle pandas Series edge cases (NaN, empty)
- [ ] Export from entities `__init__.py`

### Phase 6: Integration
- [ ] Update domain `__init__.py` with all exports
- [ ] Add module-level docstring
- [ ] Write integration tests
- [ ] Verify imports work correctly

### Phase 7: Documentation
- [ ] Add docstrings to all classes
- [ ] Add docstrings to all methods
- [ ] Create usage examples
- [ ] Update this pre-docs with any changes

### Phase 8: Quality Assurance
- [ ] Run type checker (mypy)
- [ ] Run linter (ruff/black)
- [ ] Verify test coverage > 85%
- [ ] Run all tests and ensure they pass
- [ ] Code review checklist

## 10. Success Metrics

### Code Quality
- [ ] All type hints are correct and pass mypy strict mode
- [ ] All classes have comprehensive docstrings
- [ ] All methods have docstrings with parameter descriptions
- [ ] Code follows project style guide (PEP 8)

### Testing
- [ ] Unit test coverage > 85%
- [ ] All edge cases have tests
- [ ] Tests run in < 5 seconds
- [ ] No test warnings or errors

### Functionality
- [ ] All acceptance criteria from spec are met
- [ ] Entities can be created and used correctly
- [ ] Immutability is enforced where specified
- [ ] All exports work from domain module

### Documentation
- [ ] README or usage guide exists
- [ ] All public APIs are documented
- [ ] Examples demonstrate common use cases
- [ ] Dependencies are clearly stated

## 11. Next Steps After Completion

Once E06-F01 is complete, the following features can proceed:

1. **E06-F02: Processing Engine** - Uses ProcessingJob, ProcessingResult, ProcessingContext
2. **E06-F03: Indicator Pipeline** - Populates ProcessingContext with indicators
3. **E06-F04: Signal Aggregator** - Consumes ProcessingResult[] and SignalMatch
4. **E06-F05: Caching Layer** - Serializes/deserializes these entities
5. **E06-F06: Stream Processor** - Uses ProcessingContext for real-time processing

## 12. Additional Notes

### Design Decisions

**Why separate entities and value objects?**
- Entities have identity (ProcessingJob has an ID)
- Value objects are compared by value (two DateRanges with same dates are equal)
- Different semantics for equality and mutability

**Why frozen dataclasses for results?**
- Results should be immutable once created
- Prevents accidental modification
- Enables safe sharing across threads
- Makes caching simpler

**Why mutable ProcessingContext?**
- Context accumulates state during processing
- Indicators are computed incrementally
- Mutable design is more natural for this use case
- Isolated to single-threaded processing workflow

**Why use pandas Series for indicators?**
- Natural fit for time-series data
- Integration with formula evaluation
- Rich ecosystem of operations
- Performance optimizations built-in

### Future Enhancements

Potential improvements after initial implementation:
- Add validation decorators for stricter runtime checks
- Implement serialization methods (`to_dict`, `from_dict`)
- Add builder pattern for complex ProcessingJob creation
- Create fluent API for ProcessingContext
- Add support for indicator caching within context
- Implement result streaming for very large batches
