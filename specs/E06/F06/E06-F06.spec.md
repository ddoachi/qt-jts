# Spec: E06-F06 - Stream Processing

---
id: E06-F06
clickup_task_id:
title: Stream Processing
type: feature
parent: E06
children: []
epic: E06
feature: F06
domain: processing
status: Draft
priority: High
dates:
  created:
  started:
  target:
hours:
tags: [streaming, real-time, buffer-management]
effort: High
risk: Medium
---

**Status**: Draft

## Executive Summary

Enable real-time processing of incoming candles as they arrive, maintaining rolling buffers of candle data and evaluating formulas on the latest values. This feature supports live market scanning and real-time alert generation with memory-efficient fixed-size rolling buffers per symbol.

## Execution Flow

### Stream Processing Pipeline

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      Stream Processing                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  Incoming Candle    ┌─────────────┐    ┌─────────────┐    ┌──────────┐ │
│  ───────────────────►   Rolling   │───►│  Formula    │───►│  Signal  │ │
│                     │   Buffer    │    │  Evaluator  │    │  Matches │ │
│                     └─────────────┘    └─────────────┘    └──────────┘ │
│                                                                          │
│  Buffer per Symbol:                                                      │
│  ┌─────────────────────────────────────────────────────────┐            │
│  │ [C-500] [C-499] ... [C-2] [C-1] [Latest]               │            │
│  └─────────────────────────────────────────────────────────┘            │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### Processing Steps

1. Receive incoming candle event
2. Update rolling buffer for the symbol
3. Check if buffer has minimum required data (200 candles)
4. Build DataFrame from current buffer
5. Evaluate all registered formulas
6. Extract latest indicator values
7. Emit signals for matching formulas

## User Stories

- As a trader, I want to receive real-time signals as new market candles arrive so I can act on opportunities immediately
- As a system, I want to efficiently manage memory by using fixed-size rolling buffers so I can handle continuous data streams
- As a formula engine, I want to evaluate multiple formulas on latest candle data so I can generate comprehensive market signals

## Acceptance Scenarios

### Buffer Management
- Rolling buffer maintains fixed size per symbol (500 candles, configurable)
- Efficient buffer updates with O(1) append operation
- Memory usage is controlled and predictable by buffer size
- Buffer correctly handles symbol isolation (each symbol has independent buffer)

### Processing
- New candle events are handled correctly
- DataFrame is built from current buffer state
- Multiple formulas can be evaluated against same data
- Signal matches are returned with timestamp and values

### Indicator Values
- Latest indicator values are extracted correctly
- NaN values are handled gracefully without crashes
- Indicator snapshot includes all required fields
- Signals are properly associated with indicator state

### Testing
- Unit tests for buffer management pass
- Tests for formula evaluation pass
- Integration tests with mock candle stream pass
- Test coverage exceeds 85%

## Requirements

### Functional Requirements

1. **Buffer Management**
   - Implement rolling buffer with configurable maximum size (default: 500 candles)
   - Use `collections.deque` with maxlen for efficient memory management
   - Maintain one buffer per symbol with isolation
   - Support efficient append operations (O(1) complexity)

2. **Processing**
   - Process new candle events immediately as they arrive
   - Build pandas DataFrame from buffer contents
   - Support evaluation of multiple formulas per symbol
   - Return list of matching signals with metadata

3. **Indicator Values**
   - Extract latest indicator values from completed calculations
   - Handle missing/NaN indicator values gracefully
   - Provide indicator snapshot for each processed candle
   - Associate signals with indicator state

4. **Data Requirements**
   - Maintain minimum 200 candles before indicator evaluation
   - Support configurable buffer sizes
   - Efficient memory usage with fixed-size buffers

### Non-Functional Requirements

- Real-time processing: Handle candle arrivals with minimal latency
- Memory Efficient: Fixed-size buffers prevent unbounded memory growth
- Formula Evaluation: Check multiple formulas efficiently on latest data
- Signal Generation: Emit signals when formulas match

## Key Entities

### StreamProcessor

Main class responsible for stream processing operations.

**Attributes:**
- `buffers`: Dict[str, deque] - rolling buffers per symbol
- `formula_registry`: List[Formula] - registered formulas to evaluate
- `buffer_size`: int - maximum candles per buffer (default: 500)
- `min_data`: int - minimum candles required (default: 200)

**Methods:**
- `process_candle(symbol, candle)` -> List[Signal] - process new candle
- `add_formula(formula)` -> None - register formula
- `get_buffer(symbol)` -> deque - retrieve buffer for symbol
- `build_dataframe(symbol)` -> DataFrame - create DataFrame from buffer

### Rolling Buffer

- Implemented as `collections.deque(maxlen=500)`
- Stores Candle objects in chronological order
- Automatically drops oldest candles when full
- One buffer per symbol

### Signal Match

Result of formula evaluation against latest candle data.

**Attributes:**
- `formula_id`: str - identifier of matching formula
- `symbol`: str - symbol being evaluated
- `timestamp`: datetime - candle timestamp
- `values`: Dict[str, float] - indicator values at match time
- `condition_met`: bool - whether condition was satisfied

## Dependencies

### Hard Dependencies

- **E06-F02 (Processing Engine)**: Formula evaluation engine
- **E06-F03 (Indicator Pipeline)**: Indicator calculation and value extraction

### Soft Dependencies

- WebSocket/Network integration (out of scope, but consumer)
- Alert delivery systems (out of scope, but consumer)

### External Libraries

- `pandas`: DataFrame creation and manipulation
- `collections`: deque for efficient rolling buffers
- `datetime`: timestamp handling

## Gate Checks

- [ ] Dependency E06-F02 (Processing Engine) API finalized
- [ ] Dependency E06-F03 (Indicator Pipeline) API finalized
- [ ] Design document approved by tech lead
- [ ] Buffer management approach validated

## Tasks Preview

| Task ID | Title | Effort | Dependencies | Status |
|---------|-------|--------|--------------|--------|
| E06-F06-T01 | Implement StreamProcessor class | Large | F02, F03 | Pending |
| E06-F06-T02 | Implement rolling buffer management | Medium | F02 | Pending |
| E06-F06-T03 | Implement formula evaluation on stream | Large | F02, F03 | Pending |

### Task Breakdown

**E06-F06-T01: Implement StreamProcessor class**
- Subtask 1: Create StreamProcessor base class with initialization
- Subtask 2: Implement buffer management methods
- Subtask 3: Implement formula registration interface

**E06-F06-T02: Implement rolling buffer management**
- Subtask 1: Implement rolling buffer using deque
- Subtask 2: Implement symbol-based buffer isolation
- Subtask 3: Add buffer lifecycle management

**E06-F06-T03: Implement formula evaluation on stream**
- Subtask 1: Implement candle processing pipeline
- Subtask 2: Build DataFrame from rolling buffer
- Subtask 3: Implement formula evaluation and signal emission

## Success Criteria

- StreamProcessor class successfully processes real-time candle streams
- Rolling buffers maintain fixed size with O(1) append operations
- Formula evaluation produces correct signal matches
- Memory usage remains bounded by buffer size configuration
- Test coverage exceeds 85% across all components
- Performance supports processing 1000+ candles per second per symbol
- Zero data loss in buffer updates

## Risk Assessment

### Medium Risks

1. **Memory Pressure**: If buffer size is too large or too many symbols are tracked
   - Mitigation: Implement configurable buffer size with defaults
   - Mitigation: Add memory monitoring and alerts

2. **Data Consistency**: Race conditions between buffer updates and formula evaluation
   - Mitigation: Use thread-safe buffer implementation
   - Mitigation: Add locking mechanisms for formula registration

3. **Performance Degradation**: Evaluating multiple formulas slowing down processing
   - Mitigation: Optimize formula evaluation order
   - Mitigation: Consider lazy evaluation for complex formulas

### Low Risks

1. **DataFrame Building**: Performance impact of creating DataFrame on each candle
   - Mitigation: Profile DataFrame creation performance
   - Mitigation: Consider incremental updates if needed

2. **Indicator Availability**: Missing or incomplete indicator values
   - Mitigation: Graceful handling of NaN values
   - Mitigation: Validation that minimum data threshold is met

## Notes and Clarifications

### Design Decisions

1. **Rolling Buffer Implementation**
   - Using `collections.deque(maxlen=N)` provides O(1) append and automatic old data removal
   - Alternative: Custom ring buffer implementation (rejected: added complexity)

2. **DataFrame Creation**
   - Creating DataFrame on each candle ensures latest data is always used
   - DataFrame is most compatible with existing formula evaluator from F02

3. **Symbol Isolation**
   - Each symbol maintains independent buffer and state
   - Allows symbols to have different data availability and processing states
   - Supports different buffer sizes per symbol if needed in future

### Future Enhancements

- Support for variable-length buffers per symbol (based on formula requirements)
- Async processing pipeline for better throughput
- Signal batching for batch processing downstream
- Real-time buffer statistics and monitoring

### Open Questions

- Should buffer size be configurable globally or per-symbol?
- What is expected maximum symbols count in production?
- Should signals be timestamped with arrival time or candle time?

## Artifacts

### Code Artifacts

- `stream_processor.py` - Main StreamProcessor class
- `tests/test_stream_processor.py` - Unit and integration tests
- `configs/stream_processing.yml` - Configuration defaults

### Documentation Artifacts

- Architecture documentation
- API documentation (generated from docstrings)
- Performance profiling results

### Test Artifacts

- Unit test suite (buffer management)
- Unit test suite (formula evaluation)
- Integration test suite (candle stream simulation)
- Performance benchmark results

## Metadata

| Field | Value |
|-------|-------|
| Feature ID | E06-F06 |
| Title | Stream Processing |
| Status | Draft |
| Epic | E06: Processing Engine |
| Type | Feature |
| Complexity | High |
| Primary Dependencies | E06-F02, E06-F03 |
| PRD References | Section 5.2 (real-time scanning) |
| Created | |
| Last Updated | |
