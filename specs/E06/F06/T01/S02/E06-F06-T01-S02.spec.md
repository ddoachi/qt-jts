# Spec: E06-F06-T01-S02 - Real-time Candle Processing

---

id: E06-F06-T01-S02
clickup_task_id: null
title: Real-time Candle Processing
type: subtask
parent: E06-F06-T01
children: []
epic: E06
feature: F06
task: T01
subtask: S02
domain: stream-processing
status: Draft
priority: Medium
dates:
  created: null
  updated: null
  due: null
hours:
  estimated: 8
  spent: 0
tags:
  - candle-processing
  - real-time
  - formula-evaluation
effort: M
risk: Medium

---

Status: **Draft**

---

## Executive Summary

Implement the `on_candle()` method that processes incoming candles in real-time, evaluating formulas and generating signals when matches occur. This is the core entry point for the StreamProcessor, handling the real-time data flow from market feeds through formula evaluation to signal generation.

---

## Execution Flow

1. **Candle Reception**: New candle arrives and is added to the symbol's buffer
2. **Validation**: Check if buffer has minimum required candles for evaluation
3. **DataFrame Construction**: Convert buffer to pandas DataFrame with OHLCV columns
4. **Formula Evaluation**: Evaluate each formula against the latest candle
5. **Signal Generation**: Create SignalMatch objects for formulas that match
6. **Error Handling**: Catch and log evaluation errors without stopping processing
7. **Return**: Return list of matches for the current candle

---

## User Stories

- As a trader, I want real-time signal generation when my formulas match market conditions
- As a system, I want to efficiently process incoming candles without waiting for batch processing
- As a developer, I want reliable error handling so one formula failure doesn't crash the system

---

## Acceptance Scenarios

- Scenario 1: Buffer below minimum candles - processing skipped, no formula evaluation
- Scenario 2: Single formula match - SignalMatch created with correct metadata
- Scenario 3: Single formula no match - empty list returned
- Scenario 4: Multiple formulas - all evaluated, only matches returned
- Scenario 5: Formula evaluation error - error logged, processing continues
- Scenario 6: Batch candle processing - backfilling works correctly, returns final matches only

---

## Requirements

### Functional Requirements

1. **FR1**: on_candle() must add new candle to the buffer for given symbol
2. **FR2**: on_candle() must check if buffer has minimum required candles before evaluation
3. **FR3**: DataFrame must be constructed from buffer with OHLCV columns indexed by timestamp
4. **FR4**: Each formula must be evaluated against the DataFrame
5. **FR5**: Only the latest candle value must be checked for formula match
6. **FR6**: SignalMatch must include timestamp, candle, signal type, indicator values, and formula metadata
7. **FR7**: Formula evaluation errors must be caught and logged without interrupting processing
8. **FR8**: process_batch_candles() must support backfilling with historical data

### Non-Functional Requirements

1. **NFR1**: Real-time processing must complete within latency budget (< 100ms per candle)
2. **NFR2**: Memory usage must remain bounded with fixed buffer size
3. **NFR3**: Error handling must ensure one bad formula doesn't affect others

---

## Key Entities

```python
# Input
- symbol: str (e.g., "005930")
- candle: Candle (OHLCV data with timestamp)
- formulas: list[Formula] (formulas to evaluate)

# Output
- SignalMatch: Result when formula matches
  - timestamp: datetime
  - candle: Candle
  - signal_type: SignalType.SCAN_HIT
  - indicator_values: dict[str, float]
  - metadata: dict[str, str]

# Internal
- buffer: dict[str, list[Candle]] (per-symbol candle buffers)
- df: pd.DataFrame (OHLCV data indexed by timestamp)
```

---

## Dependencies

- **E06-F06-T01-S01**: Rolling Buffer Management (add_candle, get_buffer, _buffer_to_dataframe)
- **E05**: DSL Parser & Evaluator (FormulaService._formula_service.evaluate)
- **External**: pandas (DataFrame), Python typing

---

## Gate Checks

- [ ] E06-F06-T01-S01 (Rolling Buffer Management) must be complete
- [ ] FormulaService.evaluate() must be implemented and tested
- [ ] SignalMatch data class must be defined
- [ ] Candle data model must be finalized

---

## Tasks Preview

1. Implement `on_candle()` method with buffer addition and validation
2. Implement `_buffer_to_dataframe()` helper for DataFrame construction
3. Implement `_evaluate_formula_latest()` helper for single formula evaluation
4. Implement `process_batch_candles()` for backfilling
5. Implement `_extract_latest_indicators()` helper for indicator value extraction
6. Add comprehensive error handling and logging
7. Write unit tests for all scenarios

---

## Success Criteria

1. on_candle() correctly processes new candles and returns SignalMatch objects
2. Minimum candle validation prevents premature formula evaluation
3. DataFrame construction preserves data integrity and proper indexing
4. Formula evaluation checks only the latest candle value
5. SignalMatch objects contain all required metadata
6. Error handling logs failures without interrupting processing
7. process_batch_candles() enables efficient historical backfilling
8. All unit tests pass with >95% code coverage for this module

---

## Risk Assessment

### Risk 1: Race Conditions in Multi-threaded Environment
- **Impact**: High (data corruption, missed signals)
- **Probability**: Medium
- **Mitigation**: Implement thread-safe buffer access with locks

### Risk 2: DataFrame Performance with Large Buffers
- **Impact**: Medium (latency increase)
- **Probability**: Medium
- **Mitigation**: Monitor DataFrame creation time, consider incremental updates

### Risk 3: Formula Evaluation Timeout
- **Impact**: High (missed candle processing)
- **Probability**: Low
- **Mitigation**: Add timeout wrapper to formula evaluation

### Risk 4: Indicator Extraction Failure
- **Impact**: Medium (incomplete SignalMatch)
- **Probability**: Low
- **Mitigation**: Graceful degradation with partial indicator data

---

## Notes and Clarifications

### Implementation Rationale

- **Real-time Focus**: The `on_candle()` method checks only the latest value rather than scanning the entire DataFrame for matches. This optimizes for the common case where formulas should only trigger on new data.

- **Batch Capability**: The `process_batch_candles()` method supports backfilling historical data efficiently by reusing the same evaluation logic.

- **Error Isolation**: Each formula evaluation is wrapped in a try-catch block to prevent one bad formula from affecting signal generation for others.

- **DataFrame per Symbol**: Maintaining separate buffers and DataFrames per symbol ensures multi-symbol processing doesn't cause interference.

### Key Design Decisions

1. **Latest Value Check Only**: Checking `result.iloc[-1]` ensures signals are only generated on the current candle, not historical matches.

2. **Buffer Minimum Check**: The minimum candle validation prevents evaluating on incomplete data that might produce false signals.

3. **Indicator Extraction**: Creating `indicator_values` dict provides context about the market state when the signal was generated.

4. **Metadata in SignalMatch**: Including `formula_id` and `formula_name` enables signal attribution and debugging.

---

## Artifacts

### Source Implementation

```python
class StreamProcessor:
    # ... buffer methods from S01 ...

    def on_candle(
        self,
        symbol: str,
        candle: Candle,
        formulas: list[Formula]
    ) -> list[SignalMatch]:
        """
        Process new candle and check formulas.

        This is the main entry point for real-time processing:
        1. Add candle to buffer
        2. Check if enough data for processing
        3. Build DataFrame from buffer
        4. Evaluate each formula
        5. Return matches for latest candle

        Args:
            symbol: Symbol code (e.g., "005930")
            candle: New candle to process
            formulas: List of formulas to evaluate

        Returns:
            List of SignalMatch for formulas that matched
        """
        # Add candle to buffer
        buffer_size = self.add_candle(symbol, candle)

        # Check minimum data requirement
        if buffer_size < self._min_candles:
            logger.debug(
                f"{symbol}: Buffer {buffer_size}/{self._min_candles}, "
                "skipping evaluation"
            )
            return []

        # Build DataFrame from buffer
        df = self._buffer_to_dataframe(symbol)

        if df is None or df.empty:
            return []

        # Evaluate formulas
        matches = []
        for formula in formulas:
            try:
                match = self._evaluate_formula_latest(
                    symbol, candle, df, formula
                )
                if match:
                    matches.append(match)
            except Exception as e:
                logger.error(
                    f"Error evaluating formula {formula.id} "
                    f"for {symbol}: {e}"
                )

        if matches:
            logger.info(
                f"{symbol}: {len(matches)} matches at "
                f"{candle.timestamp}"
            )

        return matches

    def _buffer_to_dataframe(self, symbol: str) -> Optional[pd.DataFrame]:
        """
        Convert symbol's buffer to pandas DataFrame.

        Creates DataFrame with OHLCV columns indexed by timestamp.
        """
        buffer = self.get_buffer(symbol)

        if not buffer:
            return None

        df = pd.DataFrame([
            {
                'timestamp': c.timestamp,
                'open': c.open,
                'high': c.high,
                'low': c.low,
                'close': c.close,
                'volume': c.volume
            }
            for c in buffer
        ])

        df.set_index('timestamp', inplace=True)
        return df

    def _evaluate_formula_latest(
        self,
        symbol: str,
        candle: Candle,
        df: pd.DataFrame,
        formula: Formula
    ) -> Optional[SignalMatch]:
        """
        Evaluate formula and check only the latest value.

        For real-time processing, we only care if the formula
        matches on the most recent candle.
        """
        # Evaluate formula across all data
        result = self._formula_service.evaluate(formula, df)

        # Check only the latest value
        if not result.iloc[-1]:
            return None

        # Formula matched - extract indicator values
        indicator_values = self._extract_latest_indicators(df)

        return SignalMatch(
            timestamp=candle.timestamp,
            candle=candle,
            signal_type=SignalType.SCAN_HIT,
            indicator_values=indicator_values,
            metadata={
                'formula_id': formula.id,
                'formula_name': formula.name
            }
        )

    def process_batch_candles(
        self,
        symbol: str,
        candles: list[Candle],
        formulas: list[Formula]
    ) -> list[SignalMatch]:
        """
        Process multiple candles at once.

        Useful for backfilling buffers with historical data.
        Returns matches only for the final candle.
        """
        matches = []

        for candle in candles:
            matches = self.on_candle(symbol, candle, formulas)

        return matches  # Only return matches from last candle
```

### Test Cases

```python
def test_on_candle_below_minimum():
    """Test processing skipped when below min candles"""
    mock_formula_service = MagicMock()

    processor = StreamProcessor(
        mock_formula_service,
        MagicMock(),
        buffer_size=500,
        min_candles=200
    )

    # Add only 50 candles
    for i in range(50):
        matches = processor.on_candle(
            "005930",
            mock_candle(i),
            [mock_formula]
        )
        assert matches == []

    # Formula service should not be called
    mock_formula_service.evaluate.assert_not_called()

def test_on_candle_formula_match():
    """Test signal generated on formula match"""
    mock_formula_service = MagicMock()
    mock_formula_service.evaluate.return_value = pd.Series([True])

    processor = StreamProcessor(
        mock_formula_service,
        MagicMock(),
        min_candles=1  # Low for testing
    )

    candle = mock_candle()
    matches = processor.on_candle("005930", candle, [mock_formula])

    assert len(matches) == 1
    assert matches[0].timestamp == candle.timestamp
    assert matches[0].signal_type == SignalType.SCAN_HIT

def test_on_candle_no_match():
    """Test no signal when formula doesn't match"""
    mock_formula_service = MagicMock()
    mock_formula_service.evaluate.return_value = pd.Series([False])

    processor = StreamProcessor(
        mock_formula_service,
        MagicMock(),
        min_candles=1
    )

    matches = processor.on_candle("005930", mock_candle(), [mock_formula])

    assert matches == []

def test_on_candle_multiple_formulas():
    """Test multiple formulas evaluated"""
    mock_formula_service = MagicMock()
    mock_formula_service.evaluate.side_effect = [
        pd.Series([True]),   # Formula 1 matches
        pd.Series([False]),  # Formula 2 doesn't
        pd.Series([True]),   # Formula 3 matches
    ]

    processor = StreamProcessor(
        mock_formula_service,
        MagicMock(),
        min_candles=1
    )

    formulas = [mock_formula, mock_formula, mock_formula]
    matches = processor.on_candle("005930", mock_candle(), formulas)

    assert len(matches) == 2
```
    # ... buffer methods from S01 ...

    def on_candle(
        self,
        symbol: str,
        candle: Candle,
        formulas: list[Formula]
    ) -> list[SignalMatch]:
        """
        Process new candle and check formulas.

        This is the main entry point for real-time processing:
        1. Add candle to buffer
        2. Check if enough data for processing
        3. Build DataFrame from buffer
        4. Evaluate each formula
        5. Return matches for latest candle

        Args:
            symbol: Symbol code (e.g., "005930")
            candle: New candle to process
            formulas: List of formulas to evaluate

        Returns:
            List of SignalMatch for formulas that matched
        """
        # Add candle to buffer
        buffer_size = self.add_candle(symbol, candle)

        # Check minimum data requirement
        if buffer_size < self._min_candles:
            logger.debug(
                f"{symbol}: Buffer {buffer_size}/{self._min_candles}, "
                "skipping evaluation"
            )
            return []

        # Build DataFrame from buffer
        df = self._buffer_to_dataframe(symbol)

        if df is None or df.empty:
            return []

        # Evaluate formulas
        matches = []
        for formula in formulas:
            try:
                match = self._evaluate_formula_latest(
                    symbol, candle, df, formula
                )
                if match:
                    matches.append(match)
            except Exception as e:
                logger.error(
                    f"Error evaluating formula {formula.id} "
                    f"for {symbol}: {e}"
                )

        if matches:
            logger.info(
                f"{symbol}: {len(matches)} matches at "
                f"{candle.timestamp}"
            )

        return matches

    def _buffer_to_dataframe(self, symbol: str) -> Optional[pd.DataFrame]:
        """
        Convert symbol's buffer to pandas DataFrame.

        Creates DataFrame with OHLCV columns indexed by timestamp.
        """
        buffer = self.get_buffer(symbol)

        if not buffer:
            return None

        df = pd.DataFrame([
            {
                'timestamp': c.timestamp,
                'open': c.open,
                'high': c.high,
                'low': c.low,
                'close': c.close,
                'volume': c.volume
            }
            for c in buffer
        ])

        df.set_index('timestamp', inplace=True)
        return df

    def _evaluate_formula_latest(
        self,
        symbol: str,
        candle: Candle,
        df: pd.DataFrame,
        formula: Formula
    ) -> Optional[SignalMatch]:
        """
        Evaluate formula and check only the latest value.

        For real-time processing, we only care if the formula
        matches on the most recent candle.
        """
        # Evaluate formula across all data
        result = self._formula_service.evaluate(formula, df)

        # Check only the latest value
        if not result.iloc[-1]:
            return None

        # Formula matched - extract indicator values
        indicator_values = self._extract_latest_indicators(df)

        return SignalMatch(
            timestamp=candle.timestamp,
            candle=candle,
            signal_type=SignalType.SCAN_HIT,
            indicator_values=indicator_values,
            metadata={
                'formula_id': formula.id,
                'formula_name': formula.name
            }
        )

    def process_batch_candles(
        self,
        symbol: str,
        candles: list[Candle],
        formulas: list[Formula]
    ) -> list[SignalMatch]:
        """
        Process multiple candles at once.

        Useful for backfilling buffers with historical data.
        Returns matches only for the final candle.
        """
        matches = []

        for candle in candles:
            matches = self.on_candle(symbol, candle, formulas)

        return matches  # Only return matches from last candle
```

---

## Metadata

| Field | Value |
|-------|-------|
| Specification ID | E06-F06-T01-S02 |
| Title | Real-time Candle Processing |
| Epic | E06 |
| Feature | F06 |
| Task | T01 |
| Subtask | S02 |
| Parent | E06-F06-T01 |
| Type | Subtask |
| Status | Draft |
| Domain | stream-processing |
| Priority | Medium |
| Effort | M (Medium) |
| Risk | Medium |
| Estimated Hours | 8 |
| Tags | candle-processing, real-time, formula-evaluation |
| Created | TBD |
| Updated | TBD |
| Due Date | TBD |

### Related Specifications

- **E06-F06-T01-S01**: Rolling Buffer Management
- **E05**: DSL Parser & Evaluator (FormulaService)

### Acceptance Checklist

- [ ] on_candle() adds candle and processes
- [ ] Minimum candle check before evaluation
- [ ] DataFrame creation from buffer
- [ ] Formula evaluation on latest candle only
- [ ] SignalMatch creation with metadata
- [ ] Error handling for formula evaluation
- [ ] process_batch_candles() for backfilling
- [ ] Unit tests for all scenarios
