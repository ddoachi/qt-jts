# Spec: E06-F06-T01-S03 - Indicator Value Extraction

---
id: E06-F06-T01-S03
clickup_task_id: null
title: Indicator Value Extraction
type: subtask
parent: E06-F06-T01
children: []
epic: E06
feature: F06
task: T01
subtask: S03
domain: stream-processing
status: draft
priority: medium
dates:
  created: null
  started: null
  completed: null
  deadline: null
hours:
  estimated: null
  actual: null
tags:
  - indicators
  - extraction
  - signal-context
effort: S
risk: low
---

**Status:** Draft

---

## Executive Summary

Implement indicator value extraction for signal matches. When a formula matches, we need to capture the current values of all relevant indicators to provide context for the signal. This subtask focuses on building extraction methods that handle NaN values gracefully, support configurable indicator selection, and provide indicator snapshots for signals.

---

## Execution Flow

1. Compute all registered indicators from the DataFrame
2. Extract the most recent value for each indicator
3. Filter out NaN values to ensure valid data
4. Support extraction at specific timestamps for historical analysis
5. Support selective indicator extraction for efficiency
6. Include OHLCV values in signal context
7. Return indicator values as a dictionary

---

## User Stories

- As a signal processor, I want to extract current indicator values when a formula matches so that I can provide context for the signal
- As a developer, I want efficient indicator extraction methods so that I can query specific indicators without computing all of them
- As a trader, I want clean indicator data so that NaN values don't pollute signal context

---

## Acceptance Scenarios

| Scenario | Given | When | Then |
|----------|-------|------|------|
| Extract Latest Values | DataFrame with 3 candles | _extract_latest_indicators() called | Latest value for each indicator returned, NaN excluded |
| Handle NaN Values | Indicator series with NaN at end | Extracting indicators | NaN values filtered out from results |
| Extract at Timestamp | DataFrame with indexed timestamps | _extract_indicators_at() with specific timestamp | Values at that timestamp returned |
| Selective Extraction | Multiple indicators available | _extract_selected_indicators() with specific names | Only requested indicators computed and returned |
| Public API | Symbol in buffer | get_current_indicators() called | Current indicator values returned without processing new candle |
| OHLCV Context | Formula matches | Signal created | OHLCV values included in indicator_values dict |

---

## Requirements

### Functional Requirements

1. **Indicator Extraction Methods**
   - Implement `_extract_latest_indicators()` to compute all indicators and extract most recent values
   - Implement `_extract_indicators_at(df, timestamp)` to get values at specific timestamps
   - Implement `_extract_selected_indicators(df, indicator_names)` for efficient selective extraction
   - Implement `get_current_indicators(symbol, indicator_names=None)` as public API

2. **NaN Handling**
   - Exclude NaN values from extraction results
   - Log warnings for missing data at specific timestamps

3. **Signal Context**
   - Include OHLCV values (open, high, low, close, volume) in indicator_values dict
   - Attach formula metadata to SignalMatch

4. **Formula Integration**
   - Extract indicators used by formula if available
   - Fall back to all indicators if formula indicators not available
   - Enhance `_evaluate_formula_latest()` to populate indicator context

### Non-Functional Requirements

1. Efficient computation (selective indicator extraction)
2. Graceful error handling (missing timestamps, empty DataFrames)
3. Type safety (float values in results)

---

## Key Entities

| Entity | Purpose |
|--------|---------|
| `StreamProcessor` | Main class containing extraction methods |
| `DataFrame` | Pandas DataFrame with OHLCV data and indicator series |
| `SignalMatch` | Signal match object with indicator context |
| `Formula` | Formula object defining signal conditions |
| `IndicatorPipeline` | Service computing indicators |

---

## Dependencies

- **E06-F06-T01-S02**: Real-time Candle Processing (provides candle data and DataFrame)
- **E06-F03**: Indicator Pipeline (provides indicator computation)
- pandas library (DataFrame operations)

---

## Gate Checks

- [ ] All extraction methods implement required signatures
- [ ] Unit tests written for all extraction scenarios
- [ ] NaN handling verified in tests
- [ ] OHLCV values correctly included in signal context
- [ ] Performance acceptable for selective extraction
- [ ] Integration with _evaluate_formula_latest verified

---

## Tasks Preview

1. Implement `_extract_latest_indicators()` method
2. Implement `_extract_indicators_at()` method
3. Implement `_extract_selected_indicators()` method
4. Implement `get_current_indicators()` public API
5. Enhance `_evaluate_formula_latest()` with indicator context
6. Implement `_get_formula_indicators()` helper
7. Write unit tests for extraction methods
8. Write integration tests with SignalMatch creation

---

## Success Criteria

- [ ] `_extract_latest_indicators()` computing all indicators
- [ ] NaN value handling (excluded from results)
- [ ] `_extract_indicators_at()` for specific timestamp
- [ ] `_extract_selected_indicators()` for efficiency
- [ ] `get_current_indicators()` public API
- [ ] OHLCV values included in signal context
- [ ] Unit tests for all extraction scenarios
- [ ] All tests passing
- [ ] Code review approved

---

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|-----------|
| Missing indicator in formula | Medium | Low | Implement formula indicator parsing |
| NaN propagation to signals | Low | High | Rigorous NaN filtering tests |
| Performance with many indicators | Low | Medium | Selective extraction option |
| Timestamp mismatch in historical queries | Medium | Medium | Proper timestamp validation and logging |

---

## Notes and Clarifications

### Implementation Notes

1. **Formula Indicator Detection**: The `_get_formula_indicators()` method is a placeholder. Ideally, the FormulaService should provide the list of indicators used by a formula.

2. **Type Conversion**: All extracted values are converted to Python floats for consistency and JSON serializability.

3. **Error Handling**: Missing timestamps log warnings but return empty dicts rather than raising exceptions, allowing graceful degradation.

4. **Selective Extraction**: The `_extract_selected_indicators()` method may optimize by only computing requested indicators if IndicatorPipeline supports it.

### Design Decisions

- Extraction methods return empty dicts for missing data rather than raising exceptions
- NaN values are silently excluded rather than included with special handling
- OHLCV values are always included in signal context for full candle information
- Public API (`get_current_indicators`) does not process new candles, only queries existing buffer

---

## Artifacts

### Code Samples

**Indicator Extraction Methods:**
```python
class StreamProcessor:
    # ... existing methods ...

    def _extract_latest_indicators(
        self,
        df: pd.DataFrame
    ) -> dict[str, float]:
        """
        Get indicator values at latest candle.

        Computes all registered indicators and extracts the
        most recent value for each.

        Args:
            df: DataFrame with OHLCV data

        Returns:
            Dict of indicator name -> value (NaN values excluded)
        """
        # Compute all indicators
        indicators = self._indicators.compute(df)

        # Extract latest value for each
        result = {}
        for name, series in indicators.items():
            if series is not None and len(series) > 0:
                latest = series.iloc[-1]
                if not pd.isna(latest):
                    result[name] = float(latest)

        return result

    def _extract_indicators_at(
        self,
        df: pd.DataFrame,
        timestamp: datetime
    ) -> dict[str, float]:
        """
        Get indicator values at specific timestamp.

        Args:
            df: DataFrame with OHLCV data
            timestamp: Target timestamp

        Returns:
            Dict of indicator name -> value at timestamp
        """
        if timestamp not in df.index:
            logger.warning(f"Timestamp {timestamp} not in DataFrame")
            return {}

        indicators = self._indicators.compute(df)

        result = {}
        for name, series in indicators.items():
            if series is not None and timestamp in series.index:
                value = series.loc[timestamp]
                if not pd.isna(value):
                    result[name] = float(value)

        return result

    def _extract_selected_indicators(
        self,
        df: pd.DataFrame,
        indicator_names: list[str]
    ) -> dict[str, float]:
        """
        Extract only specific indicators.

        More efficient when only certain indicators are needed.

        Args:
            df: DataFrame with OHLCV data
            indicator_names: List of indicator names to extract

        Returns:
            Dict of indicator name -> latest value
        """
        indicators = self._indicators.compute(df, indicator_names)

        result = {}
        for name in indicator_names:
            if name in indicators:
                series = indicators[name]
                if series is not None and len(series) > 0:
                    latest = series.iloc[-1]
                    if not pd.isna(latest):
                        result[name] = float(latest)

        return result

    def get_current_indicators(
        self,
        symbol: str,
        indicator_names: list[str] = None
    ) -> dict[str, float]:
        """
        Get current indicator values for symbol.

        Public method for querying indicator state without
        processing a new candle.

        Args:
            symbol: Symbol code
            indicator_names: Optional list of specific indicators

        Returns:
            Dict of indicator name -> current value
        """
        df = self._buffer_to_dataframe(symbol)

        if df is None or df.empty:
            return {}

        if indicator_names:
            return self._extract_selected_indicators(df, indicator_names)
        else:
            return self._extract_latest_indicators(df)
```

**Enhanced SignalMatch Creation:**
```python
def _evaluate_formula_latest(
    self,
    symbol: str,
    candle: Candle,
    df: pd.DataFrame,
    formula: Formula
) -> Optional[SignalMatch]:
    """
    Evaluate formula with indicator context.
    """
    result = self._formula_service.evaluate(formula, df)

    if not result.iloc[-1]:
        return None

    # Extract indicators used by formula (if available)
    used_indicators = self._get_formula_indicators(formula)

    if used_indicators:
        indicator_values = self._extract_selected_indicators(
            df, used_indicators
        )
    else:
        indicator_values = self._extract_latest_indicators(df)

    # Add OHLCV values for context
    indicator_values.update({
        'open': float(df['open'].iloc[-1]),
        'high': float(df['high'].iloc[-1]),
        'low': float(df['low'].iloc[-1]),
        'close': float(df['close'].iloc[-1]),
        'volume': float(df['volume'].iloc[-1])
    })

    return SignalMatch(
        timestamp=candle.timestamp,
        candle=candle,
        signal_type=SignalType.SCAN_HIT,
        indicator_values=indicator_values,
        metadata={
            'formula_id': formula.id,
            'formula_name': formula.name,
            'symbol': symbol
        }
    )

def _get_formula_indicators(self, formula: Formula) -> list[str]:
    """
    Get list of indicators used by formula.

    TODO: This should be provided by FormulaService.
    """
    # Placeholder - would parse formula expression
    # to identify used indicators
    return []
```

### Test Cases

```python
def test_extract_latest_indicators():
    """Test indicator extraction"""
    mock_indicators = MagicMock()
    mock_indicators.compute.return_value = {
        'sma_20': pd.Series([100, 101, 102]),
        'rsi_14': pd.Series([50, 55, np.nan]),  # Last value NaN
        'ema_12': pd.Series([99, 100, 101])
    }

    processor = StreamProcessor(MagicMock(), mock_indicators)

    df = pd.DataFrame({'close': [100, 101, 102]})
    result = processor._extract_latest_indicators(df)

    assert result['sma_20'] == 102
    assert result['ema_12'] == 101
    assert 'rsi_14' not in result  # NaN excluded

def test_extract_indicators_at_timestamp():
    """Test extraction at specific timestamp"""
    mock_indicators = MagicMock()
    ts = datetime(2024, 1, 15)

    mock_indicators.compute.return_value = {
        'sma_20': pd.Series(
            [100, 101, 102],
            index=[
                datetime(2024, 1, 14),
                datetime(2024, 1, 15),
                datetime(2024, 1, 16)
            ]
        )
    }

    processor = StreamProcessor(MagicMock(), mock_indicators)
    df = pd.DataFrame(
        {'close': [100, 101, 102]},
        index=[
            datetime(2024, 1, 14),
            datetime(2024, 1, 15),
            datetime(2024, 1, 16)
        ]
    )

    result = processor._extract_indicators_at(df, ts)

    assert result['sma_20'] == 101

def test_get_current_indicators():
    """Test public API for current indicators"""
    mock_indicators = MagicMock()
    mock_indicators.compute.return_value = {
        'rsi_14': pd.Series([50, 55, 60])
    }

    processor = StreamProcessor(
        MagicMock(),
        mock_indicators,
        min_candles=1
    )

    # Add some candles to buffer
    for i in range(3):
        processor.add_candle("005930", mock_candle(i))

    result = processor.get_current_indicators("005930", ['rsi_14'])

    assert 'rsi_14' in result
    mock_indicators.compute.assert_called_once()
```

---

## Metadata

| Property | Value |
|----------|-------|
| Created | 2024 |
| Modified | 2024 |
| Author | System |
| Version | 1.0 |
| Related Specs | E06-F06-T01, E06-F06-T01-S02, E06-F03 |
