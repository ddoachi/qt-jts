# Spec: E06-F06-T01 - Implement StreamProcessor

---

## Frontmatter

```yaml
id: E06-F06-T01
clickup_task_id: null
title: Implement StreamProcessor
type: task
parent: E06-F06
children:
  - E06-F06-T01-S01
  - E06-F06-T01-S02
  - E06-F06-T01-S03
epic: E06
feature: F06
task: T01
domain: stream-processing
status: draft
priority: high
dates:
  created: null
  updated: null
  started: null
  completed: null
hours:
  estimated: 16
  spent: 0
tags:
  - stream-processing
  - real-time
  - candle-processing
effort: L
risk: medium
```

---

## Status

**Current Status:** Draft
**Priority:** High
**Effort:** Large (L)

---

## Executive Summary

Implement the `StreamProcessor` class that handles real-time candle processing. This component maintains rolling buffers of candle data per symbol and evaluates formulas on incoming candles. The processor is essential for real-time signal detection and indicator calculation across multiple market symbols.

**Key Responsibilities:**
- Maintain efficient rolling buffers per symbol
- Process new candles in real-time with thread safety
- Evaluate multiple formulas against latest data
- Extract latest indicator values for signals

---

## Execution Flow

### High-Level Process

1. **Initialization**: Create StreamProcessor with dependencies (FormulaService, IndicatorPipeline) and configuration (buffer_size, min_candles)
2. **Candle Reception**: Accept new candle via `on_candle()` method
3. **Buffer Management**: Add candle to symbol-specific rolling buffer
4. **Validation**: Check if minimum candles threshold is met
5. **Formula Evaluation**: Evaluate all provided formulas against current buffer data
6. **Indicator Extraction**: Extract latest indicator values when formula matches
7. **Result Return**: Return list of SignalMatch objects

### Thread Safety

- Uses `threading.RLock()` for all buffer operations
- DataFrame creation occurs outside lock to prevent deadlocks
- Buffer access is synchronized across multiple symbols

---

## User Stories

### US01: Real-time Candle Processing
**As a** signal detection system
**I want to** process incoming candles in real-time
**So that** I can evaluate trading signals immediately upon new data arrival

### US02: Multi-Symbol Buffer Management
**As a** market data consumer
**I want to** maintain separate buffers for different symbols
**So that** I can process multiple symbols concurrently without data collision

### US03: Formula Evaluation on Latest Data
**As a** formula evaluation engine
**I want to** evaluate formulas against the complete buffer context
**So that** I can detect valid signal matches with full indicator history

### US04: Indicator Value Extraction
**As a** signal matching system
**I want to** extract latest indicator values when signals match
**So that** I can include indicator context in signal results

---

## Acceptance Scenarios

### Scenario 1: Basic Candle Processing
**Given** StreamProcessor is initialized with default configuration
**When** a candle is added to an empty buffer
**Then** the buffer size increases by 1

### Scenario 2: Minimum Candle Threshold
**Given** StreamProcessor with min_candles = 200
**When** fewer than 200 candles are in the buffer
**Then** no formula evaluation occurs and empty matches are returned

### Scenario 3: Buffer Size Limit
**Given** StreamProcessor with buffer_size = 100
**When** 150 candles are added
**Then** the buffer contains only the last 100 candles

### Scenario 4: Formula Match Detection
**Given** StreamProcessor with a formula that matches on the latest candle
**When** the matching candle is added to the buffer
**Then** a SignalMatch is returned with indicator values

### Scenario 5: Multiple Symbols
**Given** StreamProcessor processing multiple symbols
**When** candles are added for different symbols
**Then** each symbol maintains its own independent buffer

### Scenario 6: Thread Safety
**Given** StreamProcessor receiving concurrent candles
**When** multiple threads add candles simultaneously
**Then** buffer integrity is maintained and no data corruption occurs

---

## Requirements

### Functional Requirements

#### REQ-F01: StreamProcessor Class Structure
- Implement `StreamProcessor` class with dependency injection
- Accept `FormulaService` and `IndicatorPipeline` in constructor
- Support configurable `buffer_size` (default: 500) and `min_candles` (default: 200)

#### REQ-F02: Rolling Buffer Implementation
- Use `collections.deque` with `maxlen` for memory efficiency
- Create buffer per symbol on first candle arrival
- Maintain separate buffers for each symbol in `_buffers` dictionary

#### REQ-F03: Candle Processing Method
- Implement `on_candle(symbol, candle, formulas)` method
- Add candle to appropriate symbol buffer
- Return empty list if minimum candles not reached
- Evaluate all provided formulas on latest buffer data
- Return list of `SignalMatch` objects

#### REQ-F04: Indicator Value Extraction
- Implement `_extract_latest_indicators()` method
- Get latest values from indicator computation results
- Skip NaN values in extraction
- Return dictionary of indicator names to float values

#### REQ-F05: Buffer Management Methods
- Implement `clear_buffer(symbol)` to clear specific symbol buffer
- Implement `clear_all_buffers()` to clear all buffers
- Implement `get_buffer_size(symbol)` to retrieve current buffer size
- Implement `get_tracked_symbols()` to list active symbols

#### REQ-F06: Thread Safety
- Use `threading.RLock()` for all shared state access
- Protect all buffer operations with lock
- Ensure DataFrame creation occurs outside critical section

#### REQ-F07: DataFrame Conversion
- Implement `_buffer_to_dataframe()` method
- Convert deque of candles to pandas DataFrame
- Set timestamp as index
- Ensure data integrity during conversion

### Non-Functional Requirements

#### REQ-NF01: Performance
- Process candles with minimal latency (<100ms per candle)
- Efficiently manage buffers up to 500 candles per symbol
- Support concurrent processing of multiple symbols

#### REQ-NF02: Memory Management
- Use deque with maxlen to prevent unbounded growth
- Default buffer_size of 500 candles per symbol
- Efficient DataFrame creation from buffer data

#### REQ-NF03: Thread Safety
- All shared state protected by locks
- Lock held for minimum duration
- No deadlock scenarios

---

## Key Entities

### StreamProcessor
**Responsibility:** Main class for real-time candle processing
**Attributes:**
- `_formula_service`: FormulaService instance for formula evaluation
- `_indicators`: IndicatorPipeline instance for indicator calculation
- `_buffer_size`: Maximum number of candles per symbol buffer (int)
- `_min_candles`: Minimum candles before evaluation (int)
- `_buffers`: Dictionary of symbol -> deque[Candle]
- `_lock`: threading.RLock for thread safety

**Key Methods:**
- `on_candle(symbol, candle, formulas) -> list[SignalMatch]`
- `clear_buffer(symbol) -> None`
- `clear_all_buffers() -> None`
- `get_buffer_size(symbol) -> int`
- `get_tracked_symbols() -> list[str]`
- `_buffer_to_dataframe(symbol) -> pd.DataFrame`
- `_extract_latest_indicators(df) -> dict[str, float]`

### Candle
**Source:** E06-F02 (Processing Engine)
**Fields:** timestamp, open, high, low, close, volume

### Formula
**Source:** E06-F02 (Processing Engine)
**Purpose:** Represents technical analysis formulas to evaluate

### SignalMatch
**Purpose:** Result object containing matched signal with indicator values
**Fields:** timestamp, candle, signal_type, indicator_values

### IndicatorPipeline
**Source:** E06-F03 (Indicator Pipeline)
**Purpose:** Computes indicators for given DataFrame

### FormulaService
**Source:** E06-F02 (Processing Engine)
**Purpose:** Evaluates formulas against DataFrames

---

## Dependencies

### Internal Dependencies
- **E06-F02**: Processing Engine (FormulaService, Candle, Formula entities)
- **E06-F03**: Indicator Pipeline (IndicatorPipeline, indicator calculation)

### External Dependencies
- **pandas**: DataFrame operations for formula evaluation
- **collections**: deque for efficient buffer management
- **threading**: RLock for thread-safe operations
- **dataclasses**: asdict for converting candles to dict

### File Dependencies
```
libs/processing/src/jts_processing/
├── application/
│   └── services/
│       └── stream_processor.py          (Main implementation)
├── domain/
│   ├── interfaces/
│   │   └── i_stream_processor.py        (Protocol definition)
│   └── entities/
│       └── signal_match.py              (SignalMatch class)
└── tests/
    └── application/
        └── services/
            └── test_stream_processor.py (Unit tests)
```

---

## Gate Checks

### Pre-Implementation Gate
- [ ] Dependency modules (E06-F02, E06-F03) are available
- [ ] Candle, Formula, SignalMatch entities are defined
- [ ] FormulaService interface is finalized
- [ ] IndicatorPipeline interface is finalized

### Implementation Gate
- [ ] StreamProcessor class structure is complete
- [ ] All methods are implemented
- [ ] Thread safety is implemented with RLock
- [ ] Code follows project conventions

### Testing Gate
- [ ] All unit tests pass
- [ ] 90%+ code coverage
- [ ] Thread safety tests pass
- [ ] Integration with dependencies verified

### Review Gate
- [ ] Code review approved
- [ ] Documentation is complete
- [ ] Performance requirements verified

---

## Tasks Preview

### Subtask S01: Rolling Buffer Management
**Description:** Implement symbol buffers with deque
**Status:** Pending
**Deliverable:** Rolling buffer infrastructure with deque per symbol

### Subtask S02: Real-time Candle Processing
**Description:** Implement on_candle() method
**Status:** Pending
**Deliverable:** Core candle processing logic with formula evaluation

### Subtask S03: Indicator Value Extraction
**Description:** Extract latest values for signals
**Status:** Pending
**Deliverable:** Indicator extraction and SignalMatch creation

---

## Success Criteria

### Functional Success
- [ ] StreamProcessor successfully processes candles in real-time
- [ ] Buffers maintain correct size constraints per symbol
- [ ] Formulas evaluate correctly on latest data
- [ ] Indicator values are accurately extracted
- [ ] Thread safety is verified under concurrent load

### Code Quality Success
- [ ] Code follows PEP 8 style guidelines
- [ ] All public methods have docstrings
- [ ] Type hints are complete and accurate
- [ ] No pylint/flake8 violations

### Testing Success
- [ ] All unit tests pass (100% pass rate)
- [ ] Code coverage ≥ 90%
- [ ] Thread safety verified with stress tests
- [ ] Integration tests with E06-F02 and E06-F03 pass

### Documentation Success
- [ ] This spec is complete and accurate
- [ ] Code docstrings are clear and helpful
- [ ] No TODO comments remain in code

---

## Risk Assessment

### Risk 1: Thread Safety Issues
**Probability:** Medium
**Impact:** High (data corruption, missed signals)
**Mitigation:** Use RLock for all shared state, test under concurrent load

### Risk 2: Performance Degradation
**Probability:** Low
**Impact:** High (delayed signal detection)
**Mitigation:** Profile code with large buffers, optimize DataFrame creation

### Risk 3: Memory Leaks
**Probability:** Low
**Impact:** Medium (system instability)
**Mitigation:** Use deque with maxlen, implement proper cleanup

### Risk 4: Dependency Changes
**Probability:** Medium
**Impact:** Medium (requires refactoring)
**Mitigation:** Depend on interfaces not implementations, design for extensibility

### Risk 5: Formula Evaluation Errors
**Probability:** Medium
**Impact:** High (incorrect signals)
**Mitigation:** Comprehensive testing, validate formula results, handle edge cases

---

## Notes and Clarifications

### Implementation Notes

1. **DataFrame Outside Lock**: Creating DataFrame outside the lock prevents long-held locks during expensive operations
2. **Deque Over List**: Deque with maxlen is more efficient for circular buffers than manually managing list indices
3. **Latest Value Only**: Only the latest candle value is checked in formula evaluation to detect new signals
4. **Minimum Candles Logic**: Waiting for minimum candles ensures indicators have sufficient data for accuracy

### Design Decisions

1. **Per-Symbol Buffers**: Separate buffer per symbol allows independent processing without interference
2. **RLock Choice**: Recursive lock allows same thread to acquire lock multiple times if needed
3. **SignalMatch Return**: Returning objects allows callers to access full context (indicator values, timestamp, etc.)
4. **Configurable Parameters**: buffer_size and min_candles are configurable to support different strategies

### Known Limitations

1. **No Backfill**: Processor doesn't backfill historical data; it starts with incoming candles
2. **No Persistence**: Buffers are in-memory only; clearing is permanent
3. **No Validation**: Processor assumes valid Candle and Formula objects

### Future Enhancements

1. **Buffer Persistence**: Add option to persist buffers to disk
2. **Statistics**: Track buffer health metrics and processing times
3. **Batch Processing**: Support batch candle processing for efficiency
4. **Custom Buffer Strategies**: Allow custom buffer implementations beyond deque

---

## Artifacts

### Code Artifacts

**Primary Implementation:** `/libs/processing/src/jts_processing/application/services/stream_processor.py`

**Interface Definition:** `/libs/processing/src/jts_processing/domain/interfaces/i_stream_processor.py`

**Test Suite:** `/libs/processing/src/jts_processing/tests/application/services/test_stream_processor.py`

### Test Cases

**test_stream_processor_basic**: Verify basic buffer and size tracking
**test_stream_processor_min_candles**: Verify minimum candle threshold enforcement
**test_stream_processor_buffer_limit**: Verify buffer size limit enforcement
**test_stream_processor_formula_match**: Verify formula evaluation and SignalMatch creation
**test_stream_processor_thread_safety**: Verify concurrent access safety
**test_stream_processor_multiple_symbols**: Verify independent symbol buffers

### Reference Implementation

```python
class StreamProcessor(IStreamProcessor):
    """Process incoming candles in real-time"""

    def __init__(
        self,
        formula_service: FormulaService,
        indicator_pipeline: IndicatorPipeline,
        buffer_size: int = 500,
        min_candles: int = 200
    ):
        self._formula_service = formula_service
        self._indicators = indicator_pipeline
        self._buffer_size = buffer_size
        self._min_candles = min_candles
        self._buffers: dict[str, deque] = {}
        self._lock = threading.RLock()

    def on_candle(
        self,
        symbol: str,
        candle: Candle,
        formulas: list[Formula]
    ) -> list[SignalMatch]:
        """Process new candle and check formulas"""
        with self._lock:
            # Update buffer
            if symbol not in self._buffers:
                self._buffers[symbol] = deque(maxlen=self._buffer_size)
            self._buffers[symbol].append(candle)

            # Need minimum candles for indicators
            if len(self._buffers[symbol]) < self._min_candles:
                return []

        # Create DataFrame from buffer (outside lock)
        df = self._buffer_to_dataframe(symbol)

        # Check formulas on latest candle
        matches = []
        for formula in formulas:
            result = self._formula_service.evaluate(formula, df)

            # Check only the latest value
            if result.iloc[-1]:
                indicator_values = self._extract_latest_indicators(df)
                matches.append(SignalMatch(
                    timestamp=candle.timestamp,
                    candle=candle,
                    signal_type=SignalType.SCAN_HIT,
                    indicator_values=indicator_values
                ))

        return matches

    def _buffer_to_dataframe(self, symbol: str) -> pd.DataFrame:
        """Convert buffer to DataFrame"""
        with self._lock:
            candles = list(self._buffers[symbol])

        df = pd.DataFrame([asdict(c) for c in candles])
        df.set_index('timestamp', inplace=True)
        return df

    def _extract_latest_indicators(self, df: pd.DataFrame) -> dict[str, float]:
        """Get indicator values at latest candle"""
        indicators = self._indicators.compute(df)
        return {
            name: float(series.iloc[-1])
            for name, series in indicators.items()
            if not pd.isna(series.iloc[-1])
        }

    def clear_buffer(self, symbol: str) -> None:
        """Clear buffer for symbol"""
        with self._lock:
            if symbol in self._buffers:
                self._buffers[symbol].clear()

    def clear_all_buffers(self) -> None:
        """Clear all buffers"""
        with self._lock:
            self._buffers.clear()

    def get_buffer_size(self, symbol: str) -> int:
        """Get current buffer size for symbol"""
        with self._lock:
            if symbol in self._buffers:
                return len(self._buffers[symbol])
            return 0

    def get_tracked_symbols(self) -> list[str]:
        """Get list of symbols with active buffers"""
        with self._lock:
            return list(self._buffers.keys())
```

---

## Metadata

### Document Info
- **Spec ID:** E06-F06-T01
- **Epic:** E06 (Stream Processing Architecture)
- **Feature:** F06 (Real-time Processing)
- **Task:** T01
- **Document Version:** 1.0
- **Last Updated:** 2025-12-28

### Classification
- **Domain:** Stream Processing
- **Component:** StreamProcessor
- **Type:** Implementation Task
- **Complexity:** Medium-High

### Related Specs
- **Parent Spec:** E06-F06.spec.md (Feature: Real-time Processing)
- **Epic Spec:** E06.spec.md (Stream Processing Architecture)
- **Related Features:** E06-F02 (Processing Engine), E06-F03 (Indicator Pipeline)
- **Blocking Tasks:** None
- **Blocked By:** E06-F02-T01, E06-F03-T01

### Contacts & Responsibility
- **Owner:** [To be assigned]
- **Reviewer:** [To be assigned]
- **Domain Expert:** [Processing Architecture Team]
