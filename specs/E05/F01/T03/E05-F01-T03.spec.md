---
# ============================================================================
# SPEC METADATA
# ============================================================================

# === IDENTIFICATION ===
id: E05-F01-T03
clickup_task_id: '86ew020fh'
title: Implement Parser (Recursive Descent)
type: task

# === HIERARCHY ===
parent: E05-F01
children:
  - E05-F01-T03-S01
  - E05-F01-T03-S02
  - E05-F01-T03-S03
  - E05-F01-T03-S04
  - E05-F01-T03-S05
  - E05-F01-T03-S06
  - E05-F01-T03-S07
epic: E05
feature: F01
task: T03
domain: dsl

# === WORKFLOW ===
status: draft
priority: high

# === TRACKING ===
created: '2025-01-15'
updated: '2025-12-28'
due_date: ''
estimated_hours: 12
actual_hours: 0

# === METADATA ===
tags:
  - parser
  - recursive-descent
  - grammar
effort: large
risk: medium
---

# Spec: E05-F01-T03 - Implement Parser (Recursive Descent)

**Status**: Draft
**Type**: Task
**Parent**: E05-F01
**Created**: 2025-01-15
**Updated**: 2025-12-28

## Executive Summary

Implement a recursive descent parser that converts a token stream into an Abstract Syntax Tree (AST) following the EBNF grammar defined in the DSL specification. The parser handles operator precedence correctly, supports function calls with arguments, and provides helpful error messages with context for debugging.

## Execution Flow

```
1. Initialize parser with token list
   -> Set position to 0
   -> If tokens is empty or only EOF: ERROR "Empty expression"
2. Parse expression (entry point)
   -> Call logical_or() to start grammar rule chain
   -> If not at EOF after parsing: ERROR "Unexpected token after expression"
3. Apply precedence rules
   -> OR (lowest) -> AND -> Comparison -> Term -> Factor -> Unary -> Call -> Primary (highest)
   -> Each level calls the next higher level
4. Handle specific constructs
   -> Primary: literals, identifiers, parameters, parenthesized expressions
   -> Call: function calls with argument lists
   -> Operators: binary and unary with proper precedence
5. Build AST nodes
   -> Create appropriate ASTNode for each construct
   -> Return: SUCCESS with root ASTNode
```

## User Stories

### Primary User Story
**As a** DSL evaluator developer
**I want to** parse DSL expressions into AST
**So that** I can evaluate and analyze trading conditions

### Additional Stories
- **As a** DSL user, **I want to** write complex expressions with correct precedence, **So that** my conditions evaluate as expected
- **As a** developer, **I want to** receive helpful parse errors, **So that** I can quickly fix malformed expressions

## Acceptance Scenarios

### Scenario 1: Operator Precedence
**Given** the expression "1 + 2 * 3"
**When** I parse the expression
**Then** I get BinaryOp(1, +, BinaryOp(2, *, 3)) respecting * before +

### Scenario 2: Comparison with Arithmetic
**Given** the expression "close > sma(close, 20)"
**When** I parse the expression
**Then** I get BinaryOp(Identifier(close), >, FunctionCall(sma, ...))

### Scenario 3: Logical Combination
**Given** the expression "rsi(14) < 30 AND close > open"
**When** I parse the expression
**Then** I get BinaryOp(comparison1, AND, comparison2)

### Scenario 4: Crosses Operator
**Given** the expression "sma(close, 20) crosses_above sma(close, 60)"
**When** I parse the expression
**Then** I get CrossesAbove(FunctionCall(...), FunctionCall(...))

### Scenario 5: Parse Error
**Given** the expression "close >"
**When** I parse the expression
**Then** I get error indicating expected operand after >

## Requirements

### Functional Requirements
- **FR-001**: System MUST parse primary expressions (NUMBER, STRING, IDENTIFIER, PARAMETER)
- **FR-002**: System MUST parse parenthesized expressions
- **FR-003**: System MUST parse function calls with zero or more arguments
- **FR-004**: System MUST parse unary operators (-, NOT)
- **FR-005**: System MUST parse binary arithmetic operators (+, -, *, /)
- **FR-006**: System MUST parse comparison operators (>, <, >=, <=, ==, !=)
- **FR-007**: System MUST parse crosses operators (crosses_above, crosses_below)
- **FR-008**: System MUST parse logical operators (AND, OR)
- **FR-009**: System MUST enforce correct operator precedence

### Non-Functional Requirements
- **NFR-001**: Parse time MUST be O(n) for expression length n
- **NFR-002**: Error messages MUST include expected vs found token info
- **NFR-003**: Parser MUST be maintainable with one method per grammar rule

### Technical Constraints
- **TC-001**: Must implement recursive descent parsing
- **TC-002**: Must follow EBNF grammar exactly
- **TC-003**: Must use AST nodes from E05-F01-T01

## Key Entities

### Entity: Parser
- **Description**: Recursive descent parser that builds AST from tokens
- **Key Attributes**: tokens (list[Token]), position (int)
- **Relationships**: Consumes Tokens, produces ASTNode tree

### Entity: ParseError
- **Description**: Exception for parse failures
- **Key Attributes**: message (str), token (Token), expected (str)
- **Relationships**: Raised by Parser on syntax errors

## Dependencies

### Upstream Dependencies
- [ ] E05-F01-T01: AST node classes (NumberLiteral, BinaryOp, FunctionCall, etc.)
- [ ] E05-F01-T02: Lexer provides Token stream with TokenType enum

### Downstream Impact
- [ ] E05-F02: Semantic analyzer validates resulting AST
- [ ] E05-F03: Evaluator interprets resulting AST

## Gate Checks

### Pre-Implementation Gates
- [ ] No [NEEDS CLARIFICATION] markers remain
- [ ] EBNF grammar finalized
- [ ] Precedence table verified
- [ ] PRD compliance verified

### Quality Gates
- [ ] All PRD example formulas parse correctly
- [ ] Operator precedence verified with test cases
- [ ] Error messages are helpful and accurate
- [ ] Unit tests cover all grammar rules

## Subtasks Preview

| Subtask ID | Title | Effort | Status |
|------------|-------|--------|--------|
| E05-F01-T03-S01 | Create Parser class with token navigation utilities | S | pending |
| E05-F01-T03-S02 | Implement primary expression parsing | M | pending |
| E05-F01-T03-S03 | Implement call expression parsing | M | pending |
| E05-F01-T03-S04 | Implement unary expression parsing | S | pending |
| E05-F01-T03-S05 | Implement binary expression parsing (arithmetic) | M | pending |
| E05-F01-T03-S06 | Implement comparison and logical expression parsing | M | pending |
| E05-F01-T03-S07 | Add parser error recovery and reporting | M | pending |

## Success Criteria

### Acceptance Criteria
- [ ] Parse all example formulas from PRD Section 7.4
- [ ] Correct operator precedence (arithmetic before comparison before logical)
- [ ] Handle nested expressions with parentheses
- [ ] Handle function calls with multiple arguments
- [ ] Error messages include token position

### Definition of Done
- [ ] Code reviewed and approved
- [ ] Tests passing (unit tests)
- [ ] All grammar rules documented
- [ ] File created at libs/dsl/parser.py

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| Precedence bugs | Medium | High | Comprehensive test cases |
| Left recursion issues | Low | High | Proper grammar design |
| Error recovery complexity | Medium | Medium | Panic mode recovery |
| Grammar ambiguity | Low | High | Careful EBNF design |

## Artifacts

### Input Documents
- [Parent Feature](../E05-F01.spec.md)
- [Dependencies: T01](../T01/E05-F01-T01.spec.md), [T02](../T02/E05-F01-T02.spec.md)
- [Epic Spec](../../E05.spec.md) Section 4.2
- [Pratt Parser Reference](https://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/)

### Output Artifacts
- [ ] `libs/dsl/parser.py` - Parser class implementation
- [ ] Unit tests for all grammar rules

### Grammar Reference (EBNF)

```ebnf
expression     = logical_or ;
logical_or     = logical_and ( "OR" logical_and )* ;
logical_and    = comparison ( "AND" comparison )* ;
comparison     = term ( ( ">" | "<" | ">=" | "<=" | "==" | "!=" |
                          "crosses_above" | "crosses_below" ) term )? ;
term           = factor ( ( "+" | "-" ) factor )* ;
factor         = unary ( ( "*" | "/" ) unary )* ;
unary          = ( "-" | "NOT" )? call ;
call           = primary ( "(" arguments? ")" )? ;
primary        = NUMBER | STRING | IDENTIFIER | "(" expression ")" | parameter ;
parameter      = ":" IDENTIFIER ;
arguments      = expression ( "," expression )* ;
```

### Precedence Table (Low to High)

| Precedence | Operators |
|------------|-----------|
| 1 (lowest) | OR |
| 2 | AND |
| 3 | >, <, >=, <=, ==, !=, crosses_above, crosses_below |
| 4 | +, - |
| 5 | *, / |
| 6 (highest) | - (unary), NOT |

### Reference Implementation

```python
class Parser:
    def __init__(self, tokens: list[Token]):
        self._tokens = tokens
        self._pos = 0

    def parse(self) -> ASTNode:
        """Entry point - parse expression"""
        expr = self._expression()
        if not self._at_end():
            raise ParseError(f"Unexpected token: {self._current()}")
        return expr

    # Grammar rule methods
    def _expression(self) -> ASTNode: ...
    def _logical_or(self) -> ASTNode: ...
    def _logical_and(self) -> ASTNode: ...
    def _comparison(self) -> ASTNode: ...
    def _term(self) -> ASTNode: ...
    def _factor(self) -> ASTNode: ...
    def _unary(self) -> ASTNode: ...
    def _call(self) -> ASTNode: ...
    def _primary(self) -> ASTNode: ...
    def _arguments(self) -> list[ASTNode]: ...

    # Helper methods
    def _match(self, *types: TokenType) -> bool: ...
    def _check(self, type: TokenType) -> bool: ...
    def _advance(self) -> Token: ...
    def _consume(self, type: TokenType, message: str) -> Token: ...
```

### Test Cases

```python
# Operator precedence
"1 + 2 * 3" -> BinaryOp(1, +, BinaryOp(2, *, 3))

# Comparison with arithmetic
"close > sma(close, 20)" -> BinaryOp(Identifier(close), >, FunctionCall(sma, ...))

# Logical combination
"rsi(14) < 30 AND close > open" -> BinaryOp(BinaryOp(...), AND, BinaryOp(...))

# Crosses operator
"sma(close, 20) crosses_above sma(close, 60)" -> CrossesAbove(FunctionCall(...), FunctionCall(...))
```

---
*Template Version: 2.0.0 - Enhanced with Speckit features*
