---
# ============================================================================
# SPEC METADATA
# ============================================================================

# === IDENTIFICATION ===
id: E05-F01-T01
clickup_task_id: '86ew020f7'
title: Define AST Node Classes and Type System
type: task

# === HIERARCHY ===
parent: E05-F01
children:
  - E05-F01-T01-S01
  - E05-F01-T01-S02
  - E05-F01-T01-S03
  - E05-F01-T01-S04
epic: E05
feature: F01
task: T01
domain: dsl

# === WORKFLOW ===
status: draft
priority: high

# === TRACKING ===
created: '2025-01-15'
updated: '2025-12-28'
due_date: ''
estimated_hours: 4
actual_hours: 0

# === METADATA ===
tags:
  - ast
  - type-system
  - foundation
effort: medium
risk: low
---

# Spec: E05-F01-T01 - Define AST Node Classes and Type System

**Status**: Draft
**Type**: Task
**Parent**: E05-F01
**Created**: 2025-01-15
**Updated**: 2025-12-28

## Executive Summary

Define the Abstract Syntax Tree (AST) node classes that represent parsed DSL expressions. These classes form the foundation for parsing, semantic analysis, and evaluation. The implementation uses Python dataclasses with frozen (immutable) instances for thread safety and proper equality semantics.

## Execution Flow

```
1. Create base ASTNode abstract class
   -> Define as frozen dataclass for immutability
   -> If not properly inheritable: ERROR "Base class must support extension"
2. Implement literal node classes
   -> NumberLiteral, StringLiteral, Identifier, Parameter
   -> Validate type hints for all fields
3. Implement operator node classes
   -> BinaryOp, UnaryOp with proper operand types
   -> Ensure left/right/operand accept ASTNode type
4. Implement function and cross detection nodes
   -> FunctionCall with tuple of arguments
   -> CrossesAbove/CrossesBelow with left/right operands
5. Verify all nodes work correctly
   -> Return: SUCCESS with complete AST node hierarchy
```

## User Stories

### Primary User Story
**As a** DSL parser developer
**I want to** have well-defined AST node classes
**So that** I can represent parsed expressions in a type-safe, immutable structure

### Additional Stories
- **As a** DSL evaluator, **I want to** traverse AST nodes with visitor pattern, **So that** I can evaluate expressions cleanly
- **As a** code maintainer, **I want to** have frozen dataclasses, **So that** thread safety is guaranteed

## Acceptance Scenarios

### Scenario 1: Node Creation
**Given** the AST node classes are defined
**When** I create a NumberLiteral with value Decimal("100")
**Then** the node should be immutable and have correct repr

### Scenario 2: Binary Operation Tree
**Given** BinaryOp and NumberLiteral classes exist
**When** I create BinaryOp(NumberLiteral(1), "+", NumberLiteral(2))
**Then** the AST correctly represents "1 + 2"

### Scenario 3: Function Call with Arguments
**Given** FunctionCall and Identifier classes exist
**When** I create FunctionCall("sma", (Identifier("close"), NumberLiteral(20)))
**Then** the AST correctly represents "sma(close, 20)"

### Scenario 4: Equality Comparison
**Given** two identical NumberLiteral nodes
**When** I compare them with ==
**Then** they should be equal (dataclass default behavior)

## Requirements

### Functional Requirements
- **FR-001**: System MUST define base ASTNode as abstract frozen dataclass
- **FR-002**: System MUST implement NumberLiteral with Decimal value
- **FR-003**: System MUST implement StringLiteral with str value
- **FR-004**: System MUST implement Identifier with name field
- **FR-005**: System MUST implement Parameter with name field (for :param syntax)
- **FR-006**: System MUST implement BinaryOp with left, operator, right fields
- **FR-007**: System MUST implement UnaryOp with operator, operand fields
- **FR-008**: System MUST implement FunctionCall with name and arguments tuple
- **FR-009**: System MUST implement CrossesAbove and CrossesBelow with left/right

### Non-Functional Requirements
- **NFR-001**: All nodes MUST be frozen (immutable) for thread safety
- **NFR-002**: All fields MUST have proper type hints
- **NFR-003**: Node creation MUST have minimal overhead (<1ms)

### Technical Constraints
- **TC-001**: Must use Python dataclasses (frozen=True)
- **TC-002**: Must use Decimal for numeric precision
- **TC-003**: Must use tuple (not list) for function arguments

## Key Entities

### Entity: ASTNode
- **Description**: Base abstract class for all AST nodes
- **Key Attributes**: None (abstract base)
- **Relationships**: Parent of all node types

### Entity: NumberLiteral
- **Description**: Represents numeric literals in expressions
- **Key Attributes**: value (Decimal)
- **Relationships**: Extends ASTNode

### Entity: BinaryOp
- **Description**: Represents binary operations (+, -, *, /, comparisons)
- **Key Attributes**: left (ASTNode), operator (str), right (ASTNode)
- **Relationships**: Extends ASTNode, contains ASTNode children

### Entity: FunctionCall
- **Description**: Represents function invocations like sma(close, 20)
- **Key Attributes**: name (str), arguments (tuple[ASTNode, ...])
- **Relationships**: Extends ASTNode, contains ASTNode arguments

## Dependencies

### Upstream Dependencies
- [ ] None - This is a foundational component

### Downstream Impact
- [ ] E05-F01-T02: Lexer will tokenize for Parser that creates these nodes
- [ ] E05-F01-T03: Parser will create instances of these node classes
- [ ] E05-F02: Semantic analyzer will validate these nodes
- [ ] E05-F03: Evaluator will interpret these nodes

## Gate Checks

### Pre-Implementation Gates
- [ ] No [NEEDS CLARIFICATION] markers remain
- [ ] All node types identified from DSL grammar
- [ ] Decimal precision requirements understood
- [ ] PRD compliance verified

### Quality Gates
- [ ] All nodes are frozen dataclasses
- [ ] Type hints on all fields
- [ ] Unit tests for node creation and equality
- [ ] __repr__ provides readable output

## Subtasks Preview

| Subtask ID | Title | Effort | Status |
|------------|-------|--------|--------|
| E05-F01-T01-S01 | Create base ASTNode class and common infrastructure | S | pending |
| E05-F01-T01-S02 | Implement literal nodes (Number, String, Identifier, Parameter) | S | pending |
| E05-F01-T01-S03 | Implement operator nodes (BinaryOp, UnaryOp) | S | pending |
| E05-F01-T01-S04 | Implement function and cross nodes (FunctionCall, CrossesAbove/Below) | S | pending |

## Success Criteria

### Acceptance Criteria
- [ ] All node types defined with frozen dataclasses
- [ ] Type hints for all fields
- [ ] `__eq__` and `__hash__` work correctly (dataclass default)
- [ ] `__repr__` provides readable output
- [ ] Unit tests for node creation and equality

### Definition of Done
- [ ] Code reviewed and approved
- [ ] Tests passing (unit tests)
- [ ] All node types documented
- [ ] File created at libs/dsl/ast_nodes.py

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| Incomplete node types | Low | High | Review DSL grammar thoroughly |
| Circular imports | Low | Medium | Keep ast_nodes.py dependency-free |
| Type hint issues | Low | Low | Use Python 3.10+ typing features |

## Artifacts

### Input Documents
- [Parent Feature](../E05-F01.spec.md)
- [Epic Spec](../../E05.spec.md) Section 3.2

### Output Artifacts
- [ ] `libs/dsl/ast_nodes.py` - AST node class definitions
- [ ] Unit tests for all node types

### Reference Implementation

```python
from abc import ABC
from dataclasses import dataclass
from typing import Union
from decimal import Decimal

@dataclass(frozen=True)
class ASTNode(ABC):
    """Base AST node - immutable for safety"""
    pass

# Literal nodes
@dataclass(frozen=True)
class NumberLiteral(ASTNode):
    value: Decimal

@dataclass(frozen=True)
class StringLiteral(ASTNode):
    value: str

@dataclass(frozen=True)
class Identifier(ASTNode):
    name: str

@dataclass(frozen=True)
class Parameter(ASTNode):
    """Parameterized value like :period"""
    name: str

# Operator nodes
@dataclass(frozen=True)
class BinaryOp(ASTNode):
    left: ASTNode
    operator: str
    right: ASTNode

@dataclass(frozen=True)
class UnaryOp(ASTNode):
    operator: str
    operand: ASTNode

# Function nodes
@dataclass(frozen=True)
class FunctionCall(ASTNode):
    name: str
    arguments: tuple[ASTNode, ...]

# Cross detection nodes
@dataclass(frozen=True)
class CrossesAbove(ASTNode):
    left: ASTNode
    right: ASTNode

@dataclass(frozen=True)
class CrossesBelow(ASTNode):
    left: ASTNode
    right: ASTNode
```

---
*Template Version: 2.0.0 - Enhanced with Speckit features*
