---
# ============================================================================
# SPEC METADATA
# ============================================================================

# === IDENTIFICATION ===
id: E05
clickup_task_id: ''
title: DSL Parser & Evaluator
type: epic

# === HIERARCHY ===
parent: null
children: [E05-F01, E05-F02, E05-F03, E05-F04]
epic: E05
domain: dsl

# === WORKFLOW ===
status: split
priority: high

# === TRACKING ===
created: '2025-12-28'
updated: '2025-12-28'
due_date: ''
estimated_hours: 160
actual_hours: 0

# === METADATA ===
tags: [dsl, parser, evaluator, trading-formulas]
effort: epic
risk: medium
---

# Spec: E05 - DSL Parser & Evaluator

**Status**: Split
**Type**: Epic
**Parent**: PRD Section 7.0
**Created**: 2025-12-28
**Updated**: 2025-12-28

## Executive Summary

Implement a Domain Specific Language (DSL) for defining trading formulas that enables users to create scan conditions, entry/exit rules, and technical indicators with parameterizable expressions. The DSL provides an expressive, safe, and fast way to evaluate formulas on historical candle data using vectorized pandas operations.

## Execution Flow

```
1. User enters formula expression in editor
   → If syntax error: ERROR "Invalid syntax at line:column"
   → If valid: Continue to parsing
2. Lexer tokenizes the expression
   → Process: Convert text to token stream
   → Validate: All characters recognized
3. Parser builds AST from tokens
   → Process: Recursive descent parsing
   → Validate: Grammar compliance
4. Semantic analyzer validates AST
   → If unknown function: ERROR "Unknown function: {name}"
   → If wrong arg count: ERROR "{fn} expects {n} arguments"
5. Evaluator processes AST on DataFrame
   → Process: Vectorized evaluation
   → Return: pd.Series with results
6. FormulaService returns matches
   → Return: SUCCESS with list[FormulaMatch]
```

## User Stories

### Primary User Story
**As a** trader
**I want to** define custom scanning formulas using a simple DSL
**So that** I can find stocks matching my technical criteria

### Additional Stories
- **As a** trader, **I want to** parameterize my formulas, **So that** I can optimize strategy parameters
- **As a** developer, **I want to** add new technical indicators, **So that** I can extend the DSL capabilities
- **As a** trader, **I want to** see syntax highlighting, **So that** I can easily read and debug formulas

## Acceptance Scenarios

### Scenario 1: Parse Simple Comparison
**Given** the expression "close > 100"
**When** the formula is parsed
**Then** an AST with BinaryOp(Identifier(close), >, NumberLiteral(100)) is produced

### Scenario 2: Evaluate Technical Indicator
**Given** the expression "rsi(14) < 30"
**When** evaluated on 100 candles of data
**Then** a boolean Series of length 100 is returned with True where RSI < 30

### Scenario 3: Syntax Error Handling
**Given** an invalid expression "close >"
**When** the formula is parsed
**Then** a ParseError with line/column information is raised

## Requirements

### Functional Requirements
- **FR-001**: System MUST parse all EBNF grammar constructs
- **FR-002**: System MUST evaluate formulas on pandas DataFrames
- **FR-003**: System MUST support parameterized formulas with :param syntax
- **FR-004**: System MUST provide helpful error messages with positions
- **FR-005**: Users MUST be able to use all 12 built-in functions (sma, ema, rsi, macd, atr, highest, lowest, average, std, lag, crosses_above, crosses_below)

### Non-Functional Requirements
- **NFR-001**: Performance: Parse 100 formulas in < 100ms
- **NFR-002**: Performance: Evaluate formula on 1M candles in < 1 second
- **NFR-003**: Performance: Syntax highlighting without UI lag
- **NFR-004**: Reliability: Test coverage > 90%

### Technical Constraints
- **TC-001**: Must use pandas for vectorized operations
- **TC-002**: Must integrate with E02 Storage layer (IFormulaRepository)
- **TC-003**: UI components must use PyQt6 (dependency on E01)

## Key Entities

### Entity: Formula
- **Description**: Parsed and validated trading formula
- **Key Attributes**: id, name, expression, category, parameters[]
- **Relationships**: Has many FormulaParameter, stored in IFormulaRepository

### Entity: ASTNode
- **Description**: Abstract Syntax Tree node representing parsed expression
- **Key Attributes**: type-specific (value, operator, name, arguments)
- **Relationships**: Tree structure with parent/children

### Entity: FormulaMatch
- **Description**: Candle that matched a formula condition
- **Key Attributes**: timestamp, candle, values
- **Relationships**: References Candle from CandleSeries

## Dependencies

### Upstream Dependencies
- [ ] E02: IFormulaRepository interface for storage
- [ ] E01: PyQt6 UI framework for editor widgets
- [ ] pandas: DataFrame operations
- [ ] numpy: Numerical computations

### Downstream Impact
- [ ] E06 (Backtesting): Will use FormulaService for strategy evaluation
- [ ] E07 (Scanning): Will use find_matches() for market scanning

## Gate Checks

### Pre-Implementation Gates
- [x] Grammar specification complete (EBNF)
- [x] All 12 functions specified
- [x] Performance requirements defined
- [ ] E02 interface finalized

### Quality Gates
- [ ] All requirements testable
- [ ] Dependencies identified
- [x] Risk assessment complete
- [x] Wave analysis for parallelization

## Hierarchical Split Structure

### Features Overview

| Feature ID | Title | Effort | Wave | Tasks | Subtasks |
|------------|-------|--------|------|-------|----------|
| [E05-F01](F01/E05-F01.spec.md) | Lexer & Parser Infrastructure | L | 1-2 | 3 | 18 |
| [E05-F02](F02/E05-F02.spec.md) | Expression Evaluator & Technical Indicators | XL | 3-4 | 5 | 17 |
| [E05-F03](F03/E05-F03.spec.md) | Formula Service & Validation | L | 5 | 4 | 8 |
| [E05-F04](F04/E05-F04.spec.md) | Formula Editor UI Components | L | 6 | 3 | 12 |

**Total: 4 Features, 15 Tasks, 55 Subtasks**

### Wave Analysis (Parallelization)

```
Wave 1: Foundation (Sequential)
├── E05-F01-T01: Define AST node classes
│
Wave 2: Parsing (Parallel)
├── E05-F01-T02: Implement Lexer
└── E05-F01-T03: Implement Parser
│
Wave 3: Evaluator Base (Sequential)
├── E05-F02-T01: Implement base Evaluator infrastructure
│
Wave 4: Technical Indicators (Maximum Parallelism - 4 streams)
├── E05-F02-T02: Core moving average functions (SMA, EMA)
├── E05-F02-T03: Momentum and volatility indicators (RSI, MACD, ATR)
├── E05-F02-T04: Range and lag functions (highest, lowest, lag)
└── E05-F02-T05: Cross detection operators
│
Wave 5: Service Layer (Partial Parallel)
├── E05-F03-T01: FormulaService core → Then parallel:
│   ├── E05-F03-T02: Parameter extraction
│   ├── E05-F03-T03: Formula validation
│   └── E05-F03-T04: find_matches() implementation
│
Wave 6: UI Components (Partial Parallel)
├── E05-F04-T01: FormulaEditorWidget → Then parallel:
│   ├── E05-F04-T02: FormulaSyntaxHighlighter
│   └── E05-F04-T03: Function reference dialog
```

## Success Criteria

### Acceptance Criteria
- [ ] Parse all example formulas from PRD Section 7.4
- [ ] Evaluate formulas on 100,000+ candles without error
- [ ] Support parameterized formulas with substitution
- [ ] Provide helpful error messages for syntax errors
- [ ] All technical indicators match TA-Lib reference values

### Definition of Done
- [ ] All features implemented and tested
- [ ] Performance targets met
- [ ] Documentation complete
- [ ] Code reviewed and approved
- [ ] Deployed to staging

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Parser complexity | Medium | Medium | Consider Lark/PLY parser generator |
| Indicator accuracy | Low | High | Compare with TA-Lib test cases |
| UI responsiveness | Medium | Medium | Debounce validation, async worker |
| E01/E02 dependency delays | Medium | High | Mock interfaces early |

## Notes and Clarifications

### Decisions Made
- 2025-12-28: Split into 4 features with 6-wave parallelization strategy
- 2025-12-28: Using recursive descent parser (not parser generator)
- 2025-12-28: Frozen dataclasses for AST nodes (immutability)

### Research Needed
- [ ] Benchmark RSI/MACD against TA-Lib
- [ ] Evaluate Lark vs custom parser performance

## Artifacts

### Input Documents
- [Product Requirements](../../docs/product-requirements-document.md) Section 7.0

### Output Artifacts
- [ ] `E05.context.md` - Implementation context
- [ ] `E05.pre-docs.md` - Pre-implementation planning
- [ ] `E05.post-docs.md` - Post-implementation learnings

## Language Specification

### Grammar (EBNF)

```ebnf
expression     = logical_or ;
logical_or     = logical_and ( "OR" logical_and )* ;
logical_and    = comparison ( "AND" comparison )* ;
comparison     = term ( ( ">" | "<" | ">=" | "<=" | "==" | "!=" ) term )? ;
term           = factor ( ( "+" | "-" ) factor )* ;
factor         = unary ( ( "*" | "/" ) unary )* ;
unary          = ( "-" | "NOT" )? call ;
call           = primary ( "(" arguments? ")" )? ;
primary        = NUMBER | STRING | IDENTIFIER | "(" expression ")" | parameter ;
parameter      = ":" IDENTIFIER ;
arguments      = expression ( "," expression )* ;
```

### Available Fields

| Field | Description | Type |
|-------|-------------|------|
| `open` | Opening price | Decimal |
| `high` | High price | Decimal |
| `low` | Low price | Decimal |
| `close` | Closing price | Decimal |
| `volume` | Volume | Integer |

### Built-in Functions

| Function | Description | Example |
|----------|-------------|---------|
| `sma(field, period)` | Simple Moving Average | `sma(close, 20)` |
| `ema(field, period)` | Exponential Moving Average | `ema(close, 12)` |
| `rsi(period)` | RSI (0-100) | `rsi(14)` |
| `macd(fast, slow, signal)` | MACD Histogram | `macd(12, 26, 9)` |
| `atr(period)` | Average True Range | `atr(14)` |
| `highest(field, period)` | Rolling Maximum | `highest(high, 52)` |
| `lowest(field, period)` | Rolling Minimum | `lowest(low, 20)` |
| `average(field, period)` | SMA Alias | `average(volume, 20)` |
| `std(field, period)` | Standard Deviation | `std(close, 20)` |
| `lag(field, n)` | N periods ago | `lag(close, 1)` |
| `crosses_above` | Golden Cross | `sma(close, 20) crosses_above sma(close, 60)` |
| `crosses_below` | Death Cross | `sma(close, 20) crosses_below sma(close, 60)` |

### Example Formulas

```python
# Volume surge
volume > average(volume, 20) * 2.5

# RSI oversold + bullish candle
rsi(14) < 30 AND close > open

# Golden cross
sma(close, 20) crosses_above sma(close, 60)

# 52-week high breakout
close > highest(high, 252) AND volume > average(volume, 20) * 1.5

# Bollinger Band lower touch
close < sma(close, 20) - 2 * std(close, 20)

# Parameterized formula
rsi(:rsi_period) < :oversold_threshold AND volume > average(volume, :vol_period) * :vol_multiplier
```

---
*Template Version: 2.0.0 - Enhanced with Speckit features*
