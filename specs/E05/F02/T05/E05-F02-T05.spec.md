---
# ============================================================================
# SPEC METADATA
# ============================================================================

# === IDENTIFICATION ===
id: E05-F02-T05
clickup_task_id: '86ew020fy'
title: Implement Cross Detection Operators
type: task

# === HIERARCHY ===
parent: E05-F02
children:
  - E05-F02-T05-S01
  - E05-F02-T05-S02
  - E05-F02-T05-S03
epic: E05
feature: F02
task: T05
domain: dsl

# === WORKFLOW ===
status: draft
priority: high

# === TRACKING ===
created: '2025-01-15'
updated: '2025-01-15'
due_date: ''
estimated_hours: 8
actual_hours: 0

# === METADATA ===
tags: [cross-detection, golden-cross, death-cross, crossover, trading-signals]
effort: medium
risk: medium
---

# Spec: E05-F02-T05 - Implement Cross Detection Operators

**Status**: Draft
**Type**: Task
**Parent**: E05-F02
**Created**: 2025-01-15
**Updated**: 2025-01-15

## Executive Summary

Implement the cross detection operators (`crosses_above`, `crosses_below`) that detect when one series crosses another. These are critical for trend-following strategies like moving average crossovers (golden cross, death cross). The implementation uses precise vectorized comparison with efficient edge case handling for equal values, NaN, and first bar scenarios.

## Execution Flow

```
1. Receive CrossesAbove/CrossesBelow AST node
   → Extract left and right child nodes
2. Evaluate both operand series
   → Recursively evaluate left child -> left Series
   → Recursively evaluate right child -> right Series
3. Apply cross detection logic
   → For crosses_above: (left > right) & (left.shift(1) <= right.shift(1))
   → For crosses_below: (left < right) & (left.shift(1) >= right.shift(1))
4. Handle edge cases
   → First bar: Always False (no previous to compare)
   → Equal values: Not a cross (must cross, not touch)
   → NaN values: Result is False
5. Return boolean pd.Series
   → Return: SUCCESS with cross detection Series
```

## User Stories

### Primary User Story
**As a** trend-following trader
**I want to** detect when one moving average crosses another
**So that** I can generate buy/sell signals based on crossover patterns

### Additional Stories
- **As a** momentum trader, **I want to** detect price crossing above resistance, **So that** I can enter breakout trades
- **As a** mean reversion trader, **I want to** detect price crossing below support, **So that** I can identify oversold conditions

## Acceptance Scenarios

### Scenario 1: Golden Cross Detection
**Given** SMA(20) crosses from below to above SMA(60)
**When** formula `sma(close, 20) crosses_above sma(close, 60)` is evaluated
**Then** result is True only on the bar where crossover occurs

### Scenario 2: Death Cross Detection
**Given** SMA(20) crosses from above to below SMA(60)
**When** formula `sma(close, 20) crosses_below sma(close, 60)` is evaluated
**Then** result is True only on the bar where crossover occurs

### Scenario 3: First Bar Handling
**Given** any cross detection formula
**When** evaluated on the first bar of data
**Then** result is False (no previous data to compare)

### Scenario 4: Equal Values No Cross
**Given** two series with equal values [10, 10, 12] and [10, 10, 10]
**When** crosses_above is evaluated
**Then** result is [False, False, True] - only last bar is true cross

## Requirements

### Functional Requirements
- **FR-001**: System MUST implement `crosses_above` detecting upward crossing
- **FR-002**: System MUST implement `crosses_below` detecting downward crossing
- **FR-003**: System MUST return False for first bar (no previous data)
- **FR-004**: System MUST return False when values are equal (touch but not cross)
- **FR-005**: System MUST work with any two comparable Series

### Non-Functional Requirements
- **NFR-001**: Accuracy: Precise crossover point detection
- **NFR-002**: Performance: Vectorized comparison operations
- **NFR-003**: Robustness: Handle NaN values without errors

### Technical Constraints
- **TC-001**: Must integrate with base Evaluator from E05-F02-T01
- **TC-002**: Must handle AST CrossesAbove/CrossesBelow nodes
- **TC-003**: File location: `libs/dsl/functions/cross.py`

## Key Entities

### Entity: crosses_above Operator
- **Description**: Detects when left series crosses from below to above right series
- **Logic**: Current bar: A > B AND Previous bar: A <= B
- **Typical Use**: Golden cross, breakout above resistance

### Entity: crosses_below Operator
- **Description**: Detects when left series crosses from above to below right series
- **Logic**: Current bar: A < B AND Previous bar: A >= B
- **Typical Use**: Death cross, breakdown below support

## Dependencies

### Upstream Dependencies
- [ ] E05-F02-T01: Base Evaluator infrastructure for node dispatch
- [ ] E05-F01-T01: AST CrossesAbove/CrossesBelow node definitions
- [ ] E05-F02-T02: Moving average functions (commonly used with crossovers)

### Downstream Impact
- [ ] Trading strategies using golden/death cross signals
- [ ] Alert systems based on crossover events
- [ ] Backtesting frameworks using crossover entries/exits

## Gate Checks

### Pre-Implementation Gates
- [ ] Base Evaluator dispatch working for operator nodes
- [ ] CrossesAbove/CrossesBelow AST nodes defined
- [ ] Test scenarios for edge cases documented

### Quality Gates
- [ ] crosses_above detects upward crossing correctly
- [ ] crosses_below detects downward crossing correctly
- [ ] First bar always returns False
- [ ] Equal values don't trigger cross
- [ ] Works with any two series (not just moving averages)

## Subtasks Preview

| Subtask ID | Title | Effort | Status |
|------------|-------|--------|--------|
| E05-F02-T05-S01 | Implement crosses_above() golden cross detection | M | pending |
| E05-F02-T05-S02 | Implement crosses_below() death cross detection | M | pending |
| E05-F02-T05-S03 | Add edge case handling for cross detection | S | pending |

## Success Criteria

### Acceptance Criteria
- [ ] crosses_above detects upward crossing correctly
- [ ] crosses_below detects downward crossing correctly
- [ ] First bar always False
- [ ] Equal values don't trigger cross
- [ ] Works with any two series (not just moving averages)

### Definition of Done
- [ ] Code reviewed and approved
- [ ] Unit tests passing for all edge cases
- [ ] Integration tests with moving average formulas
- [ ] Documentation updated
- [ ] Performance validated

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Off-by-one error in shift logic | Medium | High | Careful testing with known data |
| NaN handling causing false positives | Low | Medium | Explicit NaN check in logic |
| Edge case: simultaneous crossover | Low | Low | Document expected behavior |
| Performance with large datasets | Low | Medium | Use vectorized pandas operations |

## Notes and Clarifications

### Technical Details

#### Cross Detection Logic
```python
def _eval_CrossesAbove(self, node: CrossesAbove) -> pd.Series:
    """Detect when left series crosses above right series

    A crosses above B when:
    - Current bar: A > B
    - Previous bar: A <= B
    """
    left = self.evaluate(node.left)
    right = self.evaluate(node.right)

    return (left > right) & (left.shift(1) <= right.shift(1))

def _eval_CrossesBelow(self, node: CrossesBelow) -> pd.Series:
    """Detect when left series crosses below right series

    A crosses below B when:
    - Current bar: A < B
    - Previous bar: A >= B
    """
    left = self.evaluate(node.left)
    right = self.evaluate(node.right)

    return (left < right) & (left.shift(1) >= right.shift(1))
```

### Use Cases

| Formula | Description |
|---------|-------------|
| `sma(close, 20) crosses_above sma(close, 60)` | Golden cross (bullish) |
| `sma(close, 20) crosses_below sma(close, 60)` | Death cross (bearish) |
| `close crosses_above sma(close, 200)` | Price breaks above 200 SMA |
| `rsi(14) crosses_below 30` | RSI enters oversold |

### Edge Cases

| Case | Behavior |
|------|----------|
| First bar | False (no previous to compare) |
| Equal values | Not a cross (must cross, not touch) |
| Both NaN | False |
| One NaN | False |

### Visual Example
```
          Bar 1   Bar 2   Bar 3   Bar 4   Bar 5
SMA(20):   45      48      52      56      60
SMA(60):   50      50      50      50      50
                          ^
                    CROSS ABOVE
                    (Bar 3: 52 > 50 AND Bar 2: 48 <= 50)

Result:   False   False   True    False   False
```

### Test Cases
```python
def test_crosses_above():
    # SMA20 crosses above SMA60
    df = pd.DataFrame({
        'close': [100, 101, 102, 103, 104, 105, 106, 107]
    })
    # When short-term average rises above long-term, should detect cross

def test_equal_values_no_cross():
    # When values are equal, should not trigger
    left = pd.Series([10, 10, 12])
    right = pd.Series([10, 10, 10])
    # Result should be [False, False, True] - only last bar is true cross

def test_first_bar_always_false():
    # First bar cannot have a cross (no previous data)
    result = evaluate("sma(close, 5) crosses_above sma(close, 20)")
    assert result.iloc[0] == False
```

### Decisions Made
- Cross requires strict inequality (not equal values)
- First bar always False (conservative approach)
- NaN propagates to False (no false positives)
- Operators work with any numeric Series, not limited to moving averages

## Artifacts

### Input Documents
- [Parent Feature](../E05-F02.spec.md)
- [Dependency: Base Evaluator](../T01/E05-F02-T01.spec.md)

### Output Artifacts
- [ ] `libs/dsl/functions/cross.py` - Function implementations
- [ ] `tests/dsl/functions/test_cross.py` - Unit tests

---
*Template Version: 2.0.0 - Enhanced with Speckit features*
