# Spec: E13-F04-T06 - Create OrderHistoryWidget

---
id: E13-F04-T06
clickup_task_id: '86ew0fpkx'
title: Create OrderHistoryWidget
type: task
parent: E13-F04
epic: E13
feature: F04
domain: live-trading
status: draft
priority: medium
created: '2025-12-30'
updated: '2025-12-30'
estimated_hours: 2
actual_hours: 0
tags: [ui, order-history, table, pyside6]
effort: small
risk: low
parallel: false
---

**Status**: Draft | **Type**: Task | **Parent**: E13-F04 | **Parallel**: No

## Summary

Create the `OrderHistoryWidget` that displays order history with status icons, timestamps, and details. Orders are sorted by time with newest first.

## Implementation Details

### File Location
`src/presentation/live_trading/widgets/order_history.py`

### OrderHistoryWidget Implementation

```python
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QTableWidget, QTableWidgetItem,
    QHeaderView, QAbstractItemView
)
from PySide6.QtCore import Qt
from PySide6.QtGui import QColor, QIcon

class OrderHistoryWidget(QWidget):
    """
    Table showing order history.

    Layout:
    ┌────────────────────────────────────────────────────────────┐
    │ Time   │ Symbol │ Side │ Qty  │ Price    │ Status         │
    ├────────┼────────┼──────┼──────┼──────────┼────────────────┤
    │ 09:45  │ 000660 │ BUY  │ 100  │ ₩125,000 │ ✓ Filled       │
    │ 09:15  │ 005930 │ BUY  │ 500  │ ₩71,000  │ ✓ Filled       │
    │ 09:10  │ 035720 │ BUY  │ 200  │ ₩52,000  │ ✗ Rejected     │
    └────────────────────────────────────────────────────────────┘
    """

    MAX_ORDERS = 100  # Limit for performance

    def __init__(self, parent=None):
        super().__init__(parent)
        self._orders: list[LiveOrder] = []
        self._setup_ui()

    def _setup_ui(self):
        """Set up the UI layout"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        self._table = QTableWidget()
        self._table.setColumnCount(6)
        self._table.setHorizontalHeaderLabels([
            "Time", "Symbol", "Side", "Qty", "Price", "Status"
        ])

        # Configure table
        header = self._table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.Fixed)
        header.setSectionResizeMode(1, QHeaderView.Fixed)
        header.setSectionResizeMode(2, QHeaderView.Fixed)
        header.setSectionResizeMode(3, QHeaderView.Fixed)
        header.setSectionResizeMode(4, QHeaderView.Stretch)
        header.setSectionResizeMode(5, QHeaderView.Stretch)

        self._table.setColumnWidth(0, 60)   # Time
        self._table.setColumnWidth(1, 80)   # Symbol
        self._table.setColumnWidth(2, 50)   # Side
        self._table.setColumnWidth(3, 60)   # Qty

        self._table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self._table.setEditTriggers(QAbstractItemView.NoEditTriggers)

        layout.addWidget(self._table)

    def add_order(self, order: LiveOrder):
        """Add or update an order in the history"""
        # Check if order already exists
        existing_idx = self._find_order_index(order.id)

        if existing_idx is not None:
            self._update_row(existing_idx, order)
        else:
            self._insert_order(order)

    def _find_order_index(self, order_id: str) -> int | None:
        """Find index of order by ID"""
        for i, o in enumerate(self._orders):
            if o.id == order_id:
                return i
        return None

    def _insert_order(self, order: LiveOrder):
        """Insert new order at top (sorted by time)"""
        # Add to internal list
        self._orders.insert(0, order)

        # Limit list size
        if len(self._orders) > self.MAX_ORDERS:
            self._orders = self._orders[:self.MAX_ORDERS]

        # Insert row at top
        self._table.insertRow(0)
        self._populate_row(0, order)

        # Remove excess rows
        while self._table.rowCount() > self.MAX_ORDERS:
            self._table.removeRow(self._table.rowCount() - 1)

    def _update_row(self, row: int, order: LiveOrder):
        """Update existing row with order data"""
        self._orders[row] = order
        self._populate_row(row, order)

    def _populate_row(self, row: int, order: LiveOrder):
        """Populate a row with order data"""
        # Time
        time_str = order.created_at.strftime("%H:%M") if order.created_at else ""
        self._table.setItem(row, 0, QTableWidgetItem(time_str))

        # Symbol
        self._table.setItem(row, 1, QTableWidgetItem(order.symbol))

        # Side
        side_item = QTableWidgetItem(order.side.value.upper())
        side_color = QColor("#27ae60") if order.side == OrderSide.BUY else QColor("#c0392b")
        side_item.setForeground(side_color)
        self._table.setItem(row, 2, side_item)

        # Quantity
        qty_text = f"{order.filled_quantity}/{order.quantity}" if order.filled_quantity else str(order.quantity)
        self._table.setItem(row, 3, QTableWidgetItem(qty_text))

        # Price
        price = order.filled_price or order.price or 0
        self._table.setItem(row, 4, QTableWidgetItem(f"₩{price:,.0f}"))

        # Status with icon
        status_item = self._create_status_item(order)
        self._table.setItem(row, 5, status_item)

    def _create_status_item(self, order: LiveOrder) -> QTableWidgetItem:
        """Create status item with icon and text"""
        status = order.status

        icon_text = {
            OrderStatus.PENDING: "○",
            OrderStatus.SUBMITTED: "◐",
            OrderStatus.PARTIAL: "◐",
            OrderStatus.FILLED: "✓",
            OrderStatus.CANCELLED: "⊘",
            OrderStatus.REJECTED: "✗",
            OrderStatus.FAILED: "✗",
        }

        colors = {
            OrderStatus.PENDING: "#7f8c8d",
            OrderStatus.SUBMITTED: "#3498db",
            OrderStatus.PARTIAL: "#f39c12",
            OrderStatus.FILLED: "#27ae60",
            OrderStatus.CANCELLED: "#7f8c8d",
            OrderStatus.REJECTED: "#c0392b",
            OrderStatus.FAILED: "#c0392b",
        }

        item = QTableWidgetItem(f"{icon_text.get(status, '?')} {status.value.title()}")
        item.setForeground(QColor(colors.get(status, "#7f8c8d")))

        # Add tooltip for error orders
        if order.error_message:
            item.setToolTip(order.error_message)

        return item

    def clear(self):
        """Clear all orders"""
        self._orders.clear()
        self._table.setRowCount(0)

    @property
    def orders(self) -> list[LiveOrder]:
        """Get all orders in history"""
        return self._orders.copy()
```

## Acceptance Criteria

- [ ] Table shows order history with 6 columns
- [ ] Orders sorted by time (newest first)
- [ ] Maximum 100 orders displayed (performance)
- [ ] Side color coded (BUY green, SELL red)
- [ ] Status shows icon + text
- [ ] Filled orders show green checkmark
- [ ] Rejected/failed orders show red X
- [ ] Error message shown in tooltip for failed orders
- [ ] Partial fills show filled/total quantity
- [ ] Existing orders updated when status changes
- [ ] Table not editable

## Dependencies

- **Upstream**: E13-F01 (LiveOrder, OrderStatus)
- **Downstream**: E13-F04-T04 (used in Dashboard)

## Testing

```python
def test_order_history_adds_order(qtbot):
    widget = OrderHistoryWidget()
    order = create_order(status=OrderStatus.FILLED)
    widget.add_order(order)
    assert widget._table.rowCount() == 1
    assert "✓" in widget._table.item(0, 5).text()

def test_order_history_updates_existing(qtbot):
    widget = OrderHistoryWidget()
    order = create_order(status=OrderStatus.SUBMITTED)
    widget.add_order(order)

    order.status = OrderStatus.FILLED
    widget.add_order(order)

    assert widget._table.rowCount() == 1
    assert "Filled" in widget._table.item(0, 5).text()

def test_order_history_limits_size(qtbot):
    widget = OrderHistoryWidget()
    for i in range(150):
        widget.add_order(create_order())
    assert widget._table.rowCount() == OrderHistoryWidget.MAX_ORDERS
```

---
*Estimated: 2 hours | Risk: Low*
