# Spec: E13-F03-T02 - Implement Order Status Tracking

---
id: E13-F03-T02
clickup_task_id: '86ew0fpju'
title: Implement Order Status Tracking
type: task
parent: E13-F03
epic: E13
feature: F03
domain: live-trading
status: draft
priority: high
created: '2025-12-30'
updated: '2025-12-30'
estimated_hours: 3
actual_hours: 0
tags: [order-tracking, status, monitoring]
effort: medium
risk: medium
parallel: false
---

**Status**: Draft | **Type**: Task | **Parent**: E13-F03 | **Parallel**: No

## Summary

Implement order status tracking that monitors submitted orders for status updates. This includes polling broker for order status, handling partial fills, and timeout handling for orders that don't complete.

## Implementation Details

### File Location
`src/application/live_trading/order_tracker.py`

### OrderTracker Implementation

```python
import asyncio
from datetime import datetime, timedelta

class OrderTracker:
    """
    Track and update order statuses.

    Monitors orders in SUBMITTED or PARTIAL status
    and polls broker for updates until terminal status.
    """

    def __init__(
        self,
        broker: IBrokerGateway,
        order_repo: IOrderRepository,
        poll_interval: float = 0.5,
        timeout: timedelta = timedelta(minutes=5)
    ):
        self._broker = broker
        self._order_repo = order_repo
        self._poll_interval = poll_interval
        self._timeout = timeout
        self._tracked_orders: dict[str, LiveOrder] = {}
        self._is_running = False
        self._logger = logging.getLogger(__name__)

        # Event handlers
        self._status_handlers: list[Callable[[LiveOrder, OrderStatus], None]] = []

    async def start(self):
        """Start the order tracking loop"""
        self._is_running = True
        asyncio.create_task(self._tracking_loop())

    async def stop(self):
        """Stop tracking"""
        self._is_running = False

    def track(self, order: LiveOrder):
        """Add order to tracking"""
        if order.broker_order_id:
            self._tracked_orders[order.id] = order
            self._logger.debug(f"Tracking order: {order.id}")

    async def _tracking_loop(self):
        """Main tracking loop"""
        while self._is_running:
            await self._check_orders()
            await asyncio.sleep(self._poll_interval)

    async def _check_orders(self):
        """Check status of all tracked orders"""
        orders_to_remove = []

        for order_id, order in self._tracked_orders.items():
            try:
                await self._check_order_status(order)

                if order.is_terminal:
                    orders_to_remove.append(order_id)

                # Check timeout
                if self._is_timed_out(order):
                    self._logger.warning(f"Order timeout: {order_id}")
                    order.fail("Order timeout - no broker update received")
                    await self._order_repo.save(order)
                    orders_to_remove.append(order_id)

            except Exception as e:
                self._logger.error(f"Error checking order {order_id}: {e}")

        # Remove completed/failed orders
        for order_id in orders_to_remove:
            del self._tracked_orders[order_id]

    async def _check_order_status(self, order: LiveOrder):
        """Check broker for order status update"""
        if not order.broker_order_id:
            return

        broker_status = await self._broker.get_order_status(
            order.broker_order_id
        )

        if not broker_status:
            return

        old_status = order.status

        if broker_status.status == "filled":
            order.fill(
                filled_price=Decimal(str(broker_status.filled_price)),
                commission=Decimal(str(broker_status.commission))
            )
        elif broker_status.status == "partial":
            order.partial_fill(
                broker_status.filled_quantity,
                Decimal(str(broker_status.filled_price))
            )
        elif broker_status.status == "cancelled":
            order.status = OrderStatus.CANCELLED
        elif broker_status.status == "rejected":
            order.reject(broker_status.error_message or "Unknown rejection")

        if order.status != old_status:
            await self._order_repo.save(order)
            await self._emit_status_change(order, old_status)

    def _is_timed_out(self, order: LiveOrder) -> bool:
        """Check if order has exceeded timeout"""
        if not order.submitted_at:
            return False
        return datetime.utcnow() - order.submitted_at > self._timeout

    async def _emit_status_change(self, order: LiveOrder, old_status: OrderStatus):
        """Emit status change event"""
        self._logger.info(
            f"Order status change: {order.id} "
            f"{old_status.value} -> {order.status.value}"
        )
        for handler in self._status_handlers:
            try:
                handler(order, old_status)
            except Exception as e:
                self._logger.error(f"Status handler error: {e}")

    def add_status_handler(
        self,
        handler: Callable[[LiveOrder, OrderStatus], None]
    ):
        """Add handler for status changes"""
        self._status_handlers.append(handler)

    @property
    def pending_orders(self) -> list[LiveOrder]:
        """Get list of orders being tracked"""
        return list(self._tracked_orders.values())
```

## Acceptance Criteria

- [ ] OrderTracker polls broker for status updates
- [ ] Configurable poll interval (default 0.5s)
- [ ] Configurable timeout (default 5 minutes)
- [ ] Orders in terminal status removed from tracking
- [ ] Timed out orders marked as failed
- [ ] Status change events emitted
- [ ] Partial fills tracked correctly
- [ ] Cancellations handled
- [ ] Rejections handled with error message

## Dependencies

- **Upstream**: E13-F03-T01, E03 (Broker)
- **Downstream**: E13-F04 (UI displays order status)

## Testing

```python
async def test_order_tracking_fill():
    tracker = create_test_tracker()
    order = create_submitted_order(broker_order_id="BROKER123")
    tracker.track(order)

    mock_broker.get_order_status.return_value = BrokerOrderStatus(
        status="filled",
        filled_price=72000,
        commission=100
    )

    await tracker._check_order_status(order)

    assert order.status == OrderStatus.FILLED
    assert order.id not in tracker._tracked_orders

async def test_order_tracking_timeout():
    tracker = create_test_tracker(timeout=timedelta(seconds=1))
    order = create_submitted_order()
    order.submitted_at = datetime.utcnow() - timedelta(seconds=2)
    tracker.track(order)

    await tracker._check_orders()

    assert order.status == OrderStatus.FAILED
    assert "timeout" in order.error_message.lower()
```

---
*Estimated: 3 hours | Risk: Medium*
