# E13-F03: Order Execution - Pre-Implementation Documentation

## Feature Overview

| Field | Value |
|-------|-------|
| Feature ID | E13-F03 |
| Title | Order Execution |
| Parent Epic | E13 (Live Trading) |
| Estimated Hours | 12 |
| Tasks | 3 |
| Risk Level | High |

---

## 1. Implementation Strategy

### 1.1 Approach

This feature implements the order execution layer that bridges the trading engine with broker APIs. We use crash recovery patterns (persist before submit), exponential backoff for retries, and rate limiting to respect broker constraints.

### 1.2 Key Patterns

- **Crash Recovery**: Save order before submission
- **Exponential Backoff**: Retry with increasing delays
- **Rate Limiting**: Queue orders to respect limits
- **Observer Pattern**: Emit status change events

### 1.3 Implementation Order

```
T01 (Submission) ──┬──→ T02 (Tracking)
                   └──→ T03 (Retry)
```

---

## 2. File Structure

```
src/application/live_trading/
├── order_executor.py    # T01: Order submission
├── order_tracker.py     # T02: Status tracking
├── retry.py             # T03: Retry logic
└── rate_limiter.py      # Rate limit handling
```

---

## 3. Task Implementation Details

### 3.1 T01: Order Submission (4 hours)

**File**: `src/application/live_trading/runner.py` (add method)

```python
async def _execute_order(self, signal: TradingSignal) -> LiveOrder:
    """
    Execute order through broker.

    Flow:
    1. Create LiveOrder from signal
    2. Save to repository (crash recovery)
    3. Submit to broker
    4. Handle response
    5. Update position
    6. Emit events

    Example:
        >>> order = await runner._execute_order(signal)
        >>> print(f"Order {order.id}: {order.status}")
    """
    # Create order entity
    order = LiveOrder(
        session_id=self._session.id,
        symbol=signal.symbol,
        symbol_name=signal.symbol_name,
        side=OrderSide.BUY if signal.direction == TradeDirection.BUY else OrderSide.SELL,
        order_type=OrderType.MARKET,
        quantity=signal.quantity
    )

    try:
        # Save before submission (crash recovery)
        await self._order_repo.save(order)
        self._logger.info(f"Order created: {order.id}")

        # Submit to broker
        order.submit()
        await self._order_repo.save(order)

        result = await self._broker.place_order(
            account_id=self._session.account_id,
            symbol=order.symbol,
            side=order.side.value,
            quantity=order.quantity,
            order_type=order.order_type.value
        )

        # Handle response
        if result.status == "filled":
            order.broker_order_id = result.order_id
            order.fill(
                filled_price=Decimal(str(result.filled_price)),
                commission=Decimal(str(result.commission))
            )

            # Update position
            if order.side == OrderSide.BUY:
                await self._open_position(order)
            else:
                await self._close_position(order)

        elif result.status == "rejected":
            order.reject(result.error_message)

        elif result.status == "partial":
            order.partial_fill(result.filled_quantity, Decimal(str(result.filled_price)))

    except BrokerConnectionError as e:
        order.fail(f"Connection error: {e}")

    except BrokerRateLimitError as e:
        order.fail(f"Rate limit: {e}")

    except Exception as e:
        order.fail(str(e))

    # Save final state
    await self._order_repo.save(order)
    await self._emit_order_update(order)

    return order


async def _open_position(self, order: LiveOrder):
    """Open position after BUY fill"""
    position = Position(
        symbol=order.symbol,
        symbol_name=order.symbol_name,
        quantity=order.filled_quantity,
        entry_price=order.filled_price,
        current_price=order.filled_price,
        opened_at=order.filled_at
    )
    self._positions[order.symbol] = position


async def _close_position(self, order: LiveOrder):
    """Close position after SELL fill"""
    if order.symbol not in self._positions:
        return

    position = self._positions[order.symbol]
    realized_pnl = (order.filled_price - position.entry_price) * order.filled_quantity
    realized_pnl -= order.commission

    self.update_daily_pnl(realized_pnl)
    del self._positions[order.symbol]
```

---

### 3.2 T02: Order Status Tracking (3 hours)

**File**: `src/application/live_trading/order_tracker.py`

```python
import asyncio
from datetime import datetime, timedelta


class OrderTracker:
    """
    Track and update order statuses.

    Polls broker for updates on submitted orders.
    Handles partial fills and timeouts.

    Example:
        >>> tracker = OrderTracker(broker, order_repo)
        >>> tracker.add_status_handler(lambda o, s: print(f"{o.id}: {s}"))
        >>> tracker.track(order)
        >>> await tracker.start()
    """

    def __init__(
        self,
        broker: IBrokerGateway,
        order_repo: IOrderRepository,
        poll_interval: float = 0.5,
        timeout: timedelta = timedelta(minutes=5)
    ):
        self._broker = broker
        self._order_repo = order_repo
        self._poll_interval = poll_interval
        self._timeout = timeout
        self._tracked_orders: dict[str, LiveOrder] = {}
        self._is_running = False
        self._status_handlers: list[Callable] = []

    async def start(self):
        """Start tracking loop"""
        self._is_running = True
        asyncio.create_task(self._tracking_loop())

    async def stop(self):
        """Stop tracking"""
        self._is_running = False

    def track(self, order: LiveOrder):
        """Add order to tracking"""
        if order.broker_order_id and not order.is_terminal:
            self._tracked_orders[order.id] = order

    async def _tracking_loop(self):
        """Main tracking loop"""
        while self._is_running:
            await self._check_orders()
            await asyncio.sleep(self._poll_interval)

    async def _check_orders(self):
        """Check status of all tracked orders"""
        to_remove = []

        for order_id, order in self._tracked_orders.items():
            await self._check_order_status(order)

            if order.is_terminal or self._is_timed_out(order):
                to_remove.append(order_id)

        for order_id in to_remove:
            del self._tracked_orders[order_id]

    async def _check_order_status(self, order: LiveOrder):
        """Poll broker for order status"""
        if not order.broker_order_id:
            return

        status = await self._broker.get_order_status(order.broker_order_id)
        if not status:
            return

        old_status = order.status

        if status.status == "filled":
            order.fill(Decimal(str(status.filled_price)), Decimal(str(status.commission)))
        elif status.status == "partial":
            order.partial_fill(status.filled_quantity, Decimal(str(status.filled_price)))
        elif status.status == "cancelled":
            order.status = OrderStatus.CANCELLED
        elif status.status == "rejected":
            order.reject(status.error_message or "Unknown")

        if order.status != old_status:
            await self._order_repo.save(order)
            self._emit_status_change(order, old_status)

    def _is_timed_out(self, order: LiveOrder) -> bool:
        """Check if order exceeded timeout"""
        if not order.submitted_at:
            return False
        return datetime.utcnow() - order.submitted_at > self._timeout
```

---

### 3.3 T03: Retry Logic (3 hours)

**File**: `src/application/live_trading/retry.py`

```python
import asyncio
from dataclasses import dataclass
from functools import wraps


@dataclass
class RetryConfig:
    """Retry configuration"""
    max_attempts: int = 3
    initial_delay: float = 1.0
    max_delay: float = 30.0
    backoff_multiplier: float = 2.0

    retryable_exceptions: tuple = (
        BrokerConnectionError,
        BrokerTimeoutError,
        BrokerRateLimitError,
    )

    non_retryable_exceptions: tuple = (
        InsufficientBalanceError,
        InvalidSymbolError,
        OrderValidationError,
    )


async def with_retry(
    func,
    config: RetryConfig = None,
    logger = None
):
    """
    Execute function with retry logic.

    Uses exponential backoff: 1s → 2s → 4s → fail

    Example:
        >>> result = await with_retry(
        ...     lambda: broker.place_order(...),
        ...     config=RetryConfig(max_attempts=3)
        ... )
    """
    config = config or RetryConfig()
    logger = logger or logging.getLogger(__name__)

    last_exception = None
    delay = config.initial_delay

    for attempt in range(1, config.max_attempts + 1):
        try:
            return await func()

        except config.non_retryable_exceptions as e:
            # Fail immediately
            logger.warning(f"Non-retryable error: {e}")
            raise

        except config.retryable_exceptions as e:
            last_exception = e
            if attempt < config.max_attempts:
                logger.info(f"Attempt {attempt}/{config.max_attempts} failed: {e}. Retrying in {delay:.1f}s...")
                await asyncio.sleep(delay)
                delay = min(delay * config.backoff_multiplier, config.max_delay)
            else:
                logger.error(f"All {config.max_attempts} attempts failed: {e}")

        except Exception as e:
            logger.error(f"Unexpected error: {e}")
            raise

    raise OrderRetryExhaustedError(
        f"Failed after {config.max_attempts} attempts",
        original_error=last_exception
    )


class OrderRetryExhaustedError(Exception):
    """All retry attempts exhausted"""
    def __init__(self, message: str, original_error: Exception = None):
        super().__init__(message)
        self.original_error = original_error
```

---

## 4. Testing Strategy

### 4.1 Unit Tests

| Component | Coverage Target |
|-----------|-----------------|
| _execute_order | 90% |
| OrderTracker | 85% |
| Retry logic | 95% |

### 4.2 Mock Broker Responses

```python
class MockBrokerResponses:
    @staticmethod
    def filled():
        return OrderResult(status="filled", order_id="B123", filled_price=72000, commission=100)

    @staticmethod
    def rejected():
        return OrderResult(status="rejected", error_message="Insufficient balance")

    @staticmethod
    def partial():
        return OrderResult(status="partial", filled_quantity=50, filled_price=72000)
```

### 4.3 Key Test Scenarios

1. **Happy path**: Order submitted → filled → position opened
2. **Rejection**: Order submitted → rejected → error logged
3. **Retry success**: Connection error → retry → success
4. **Retry exhausted**: 3 connection errors → OrderRetryExhaustedError
5. **Non-retryable**: InsufficientBalance → immediate failure
6. **Timeout**: Order not filled in 5 minutes → marked failed

---

## 5. Integration Points

### 5.1 Upstream Dependencies

| Dependency | Component | Purpose |
|------------|-----------|---------|
| F01 | LiveOrder | Order entity |
| F02 | Runner | Order execution trigger |
| E03 | IBrokerGateway | Broker API |

### 5.2 Downstream Consumers

| Consumer | Usage |
|----------|-------|
| F04 | Order status display |

---

## 6. Error Handling

### 6.1 Exception Types

```python
# From E03 (Broker)
BrokerConnectionError  # Network issues
BrokerTimeoutError     # Request timeout
BrokerRateLimitError   # Rate limit exceeded
InsufficientBalanceError  # Not enough funds
InvalidSymbolError     # Symbol not tradable
OrderValidationError   # Invalid order params
```

### 6.2 Error Flow

```
Retryable Error        Non-Retryable Error
      │                       │
      ▼                       ▼
Retry (1s delay)        Immediate Failure
      │                       │
      ▼                       ▼
Retry (2s delay)        order.fail()
      │                       │
      ▼                       ▼
Retry (4s delay)        Emit Event
      │                       │
      ▼                       │
OrderRetryExhaustedError      │
      │                       │
      ▼                       ▼
order.fail()            UI Shows Error
```

---

## 7. Acceptance Checklist

- [ ] Orders created from signals correctly
- [ ] Orders saved before submission (crash recovery)
- [ ] Filled orders update positions
- [ ] Rejected orders logged with reason
- [ ] Retry uses exponential backoff
- [ ] Non-retryable errors fail immediately
- [ ] Order tracking polls broker
- [ ] Timeouts handled (5 minute default)
- [ ] P&L calculated on position close
- [ ] > 85% test coverage

---

## 8. Safety Notes

### NEVER Test with Real Money

```python
# All tests MUST use mock broker
@pytest.fixture
def mock_broker():
    broker = Mock(spec=IBrokerGateway)
    broker.place_order.return_value = MockBrokerResponses.filled()
    return broker

# Integration tests use paper trading account only
@pytest.fixture
def paper_account_config():
    return {"account_type": "paper", "broker_id": "KIS-PAPER"}
```

### Order ID Uniqueness

```python
# Ensure order IDs are unique to prevent duplicates
order = LiveOrder(id=str(uuid.uuid4()), ...)
```

---

*Pre-docs generated: 2025-12-30*
