# Spec: E13-F03-T03 - Implement Order Retry Logic

---
id: E13-F03-T03
clickup_task_id: '86ew0fpk4'
title: Implement Order Retry Logic
type: task
parent: E13-F03
epic: E13
feature: F03
domain: live-trading
status: draft
priority: high
created: '2025-12-30'
updated: '2025-12-30'
estimated_hours: 3
actual_hours: 0
tags: [retry-logic, error-handling, resilience]
effort: medium
risk: medium
parallel: false
---

**Status**: Draft | **Type**: Task | **Parent**: E13-F03 | **Parallel**: No

## Summary

Implement retry logic for transient order submission failures. This includes exponential backoff for connection errors, rate limit handling, and configuration for retry attempts.

## Implementation Details

### File Location
`src/application/live_trading/retry.py`

### OrderRetryHandler Implementation

```python
import asyncio
from functools import wraps
from typing import Callable, TypeVar

T = TypeVar('T')

class RetryConfig:
    """Configuration for retry behavior"""
    max_attempts: int = 3
    initial_delay: float = 1.0  # seconds
    max_delay: float = 30.0  # seconds
    backoff_multiplier: float = 2.0

    # Retryable exceptions
    retryable_exceptions: tuple = (
        BrokerConnectionError,
        BrokerTimeoutError,
        BrokerRateLimitError,
    )

    # Non-retryable exceptions (immediate failure)
    non_retryable_exceptions: tuple = (
        InsufficientBalanceError,
        InvalidSymbolError,
        OrderValidationError,
    )


async def with_retry(
    func: Callable[..., T],
    config: RetryConfig = None,
    logger = None
) -> T:
    """
    Execute function with retry logic.

    Uses exponential backoff for transient failures.
    Immediately fails for non-retryable errors.
    """
    config = config or RetryConfig()
    logger = logger or logging.getLogger(__name__)

    last_exception = None
    delay = config.initial_delay

    for attempt in range(1, config.max_attempts + 1):
        try:
            return await func()

        except config.non_retryable_exceptions as e:
            # Don't retry these - fail immediately
            logger.warning(f"Non-retryable error: {e}")
            raise

        except config.retryable_exceptions as e:
            last_exception = e
            if attempt < config.max_attempts:
                logger.info(
                    f"Retryable error (attempt {attempt}/{config.max_attempts}): {e}. "
                    f"Retrying in {delay:.1f}s..."
                )
                await asyncio.sleep(delay)
                delay = min(delay * config.backoff_multiplier, config.max_delay)
            else:
                logger.error(
                    f"All retry attempts exhausted ({config.max_attempts}): {e}"
                )

        except Exception as e:
            # Unknown exception - don't retry
            logger.error(f"Unexpected error: {e}")
            raise

    # All retries exhausted
    raise OrderRetryExhaustedError(
        f"Order failed after {config.max_attempts} attempts",
        original_error=last_exception
    )


def retry_decorator(config: RetryConfig = None):
    """Decorator for adding retry behavior to async functions"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            return await with_retry(
                lambda: func(*args, **kwargs),
                config
            )
        return wrapper
    return decorator


class OrderRetryExhaustedError(Exception):
    """Raised when all retry attempts are exhausted"""
    def __init__(self, message: str, original_error: Exception = None):
        super().__init__(message)
        self.original_error = original_error


# Rate limit queue for order submission
class RateLimitedSubmitter:
    """
    Rate-limited order submission queue.

    Ensures orders are submitted within broker rate limits.
    """

    def __init__(
        self,
        broker: IBrokerGateway,
        requests_per_second: int = 20
    ):
        self._broker = broker
        self._rate_limit = requests_per_second
        self._semaphore = asyncio.Semaphore(requests_per_second)
        self._queue: asyncio.Queue = asyncio.Queue()
        self._is_running = False
        self._logger = logging.getLogger(__name__)

    async def submit(self, order_request: OrderRequest) -> OrderResult:
        """Submit order with rate limiting"""
        async with self._semaphore:
            try:
                return await with_retry(
                    lambda: self._broker.place_order(**order_request.to_dict())
                )
            finally:
                # Release semaphore after rate limit window
                asyncio.create_task(self._release_after_delay())

    async def _release_after_delay(self):
        """Release semaphore slot after rate limit window"""
        await asyncio.sleep(1.0 / self._rate_limit)
```

### Integration with Order Execution

```python
# In runner.py, update _execute_order to use retry

async def _execute_order(self, signal: TradingSignal) -> LiveOrder:
    order = self._create_order_from_signal(signal)

    try:
        # Use retry logic for order submission
        result = await with_retry(
            lambda: self._broker.place_order(
                account_id=self._session.account_id,
                symbol=order.symbol,
                side=order.side.value,
                quantity=order.quantity,
                order_type=order.order_type.value,
                price=order.price
            ),
            config=self._retry_config,
            logger=self._logger
        )

        # Handle result...

    except OrderRetryExhaustedError as e:
        order.fail(f"Retry exhausted: {e.original_error}")

    except Exception as e:
        order.fail(str(e))

    return order
```

## Acceptance Criteria

- [ ] with_retry function with exponential backoff
- [ ] Configurable max attempts (default 3)
- [ ] Configurable initial delay (default 1s)
- [ ] Backoff multiplier (default 2x)
- [ ] Maximum delay cap (default 30s)
- [ ] Retryable exceptions defined (connection, timeout, rate limit)
- [ ] Non-retryable exceptions fail immediately
- [ ] OrderRetryExhaustedError raised after max attempts
- [ ] Rate limit queue for submission
- [ ] Retry attempts logged

## Dependencies

- **Upstream**: E13-F03-T01, E03 (Broker exceptions)
- **Downstream**: E13-F03-T01 (uses retry in _execute_order)

## Testing

```python
async def test_retry_success_on_second_attempt():
    call_count = 0
    async def flaky_function():
        nonlocal call_count
        call_count += 1
        if call_count < 2:
            raise BrokerConnectionError("Connection failed")
        return "success"

    result = await with_retry(flaky_function)
    assert result == "success"
    assert call_count == 2

async def test_retry_exhausted():
    async def always_fails():
        raise BrokerConnectionError("Always fails")

    with pytest.raises(OrderRetryExhaustedError) as exc_info:
        await with_retry(always_fails, RetryConfig(max_attempts=3))

    assert "3 attempts" in str(exc_info.value)

async def test_non_retryable_fails_immediately():
    call_count = 0
    async def invalid_order():
        nonlocal call_count
        call_count += 1
        raise InvalidSymbolError("Invalid symbol")

    with pytest.raises(InvalidSymbolError):
        await with_retry(invalid_order)

    assert call_count == 1  # No retries

async def test_exponential_backoff():
    delays = []
    original_sleep = asyncio.sleep
    async def mock_sleep(delay):
        delays.append(delay)

    # ... test that delays follow exponential pattern
    assert delays == [1.0, 2.0]  # For 3 attempts
```

---
*Estimated: 3 hours | Risk: Medium*
