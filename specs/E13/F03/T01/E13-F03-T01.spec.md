# Spec: E13-F03-T01 - Implement Order Submission to Broker

---
id: E13-F03-T01
clickup_task_id: '86ew0fpjp'
title: Implement Order Submission to Broker
type: task
parent: E13-F03
epic: E13
feature: F03
domain: live-trading
status: draft
priority: high
created: '2025-12-30'
updated: '2025-12-30'
estimated_hours: 4
actual_hours: 0
tags: [order-submission, broker-api, execution]
effort: large
risk: high
parallel: false
---

**Status**: Draft | **Type**: Task | **Parent**: E13-F03 | **Parallel**: No

## Summary

Implement the `_execute_order` method in `LiveTradingRunner` that submits orders to the broker API. This includes creating the order entity, submitting to broker, handling responses, and updating order status.

## Implementation Details

### File Location
`src/application/live_trading/runner.py` (add to existing class)

### Order Execution Implementation

```python
async def _execute_order(self, signal: TradingSignal) -> LiveOrder:
    """
    Execute order through broker.

    1. Create LiveOrder entity from signal
    2. Save to repository (pre-submission for crash recovery)
    3. Submit to broker API
    4. Handle response (fill, rejection, failure)
    5. Update position if filled
    6. Emit order events

    Returns the order with final status.
    """
    # Create order entity
    order = LiveOrder(
        id=str(uuid.uuid4()),
        session_id=self._session.id,
        symbol=signal.symbol,
        symbol_name=signal.symbol_name,
        side=OrderSide.BUY if signal.direction == TradeDirection.BUY else OrderSide.SELL,
        order_type=OrderType.MARKET,  # Default to market orders
        quantity=signal.quantity,
        price=signal.price if signal.order_type == OrderType.LIMIT else None
    )

    try:
        # Save order before submission (crash recovery)
        await self._order_repo.save(order)
        self._logger.info(f"Order created: {order.id} {order.symbol} {order.side.value} {order.quantity}")

        # Submit to broker
        order.submit()
        await self._order_repo.save(order)

        result = await self._broker.place_order(
            account_id=self._session.account_id,
            symbol=order.symbol,
            side=order.side.value,
            quantity=order.quantity,
            order_type=order.order_type.value,
            price=order.price
        )

        # Handle broker response
        if result.status == "filled":
            order.broker_order_id = result.order_id
            order.fill(
                filled_price=Decimal(str(result.filled_price)),
                commission=Decimal(str(result.commission))
            )

            # Update position
            if order.side == OrderSide.BUY:
                await self._open_position(order)
            else:
                await self._close_position(order)

            self._logger.info(
                f"Order filled: {order.id} @ {order.filled_price:,.0f} "
                f"(commission: {order.commission:,.0f})"
            )

        elif result.status == "rejected":
            order.reject(result.error_message)
            self._logger.warning(f"Order rejected: {order.id} - {result.error_message}")

        elif result.status == "partial":
            order.partial_fill(result.filled_quantity, Decimal(str(result.filled_price)))
            self._logger.info(
                f"Order partially filled: {order.id} "
                f"{order.filled_quantity}/{order.quantity}"
            )

    except BrokerConnectionError as e:
        order.fail(f"Broker connection error: {e}")
        self._logger.error(f"Order failed (connection): {order.id} - {e}")

    except BrokerRateLimitError as e:
        order.fail(f"Rate limit exceeded: {e}")
        self._logger.error(f"Order failed (rate limit): {order.id} - {e}")

    except Exception as e:
        order.fail(str(e))
        self._logger.error(f"Order failed (unexpected): {order.id} - {e}")

    # Save final order state
    await self._order_repo.save(order)

    # Emit order event
    await self._emit_order_update(order)

    return order


async def _open_position(self, order: LiveOrder):
    """Open a new position after BUY order filled"""
    position = Position(
        symbol=order.symbol,
        symbol_name=order.symbol_name,
        quantity=order.filled_quantity,
        entry_price=order.filled_price,
        current_price=order.filled_price,
        opened_at=order.filled_at
    )
    self._positions[order.symbol] = position
    self._logger.info(f"Position opened: {position.symbol} {position.quantity}주 @ {position.entry_price:,.0f}")


async def _close_position(self, order: LiveOrder):
    """Close existing position after SELL order filled"""
    if order.symbol not in self._positions:
        self._logger.warning(f"No position found to close for {order.symbol}")
        return

    position = self._positions[order.symbol]
    realized_pnl = (order.filled_price - position.entry_price) * order.filled_quantity
    realized_pnl -= order.commission

    self.update_daily_pnl(realized_pnl)

    del self._positions[order.symbol]
    self._logger.info(
        f"Position closed: {order.symbol} "
        f"P&L: {realized_pnl:+,.0f}원"
    )


async def _emit_order_update(self, order: LiveOrder):
    """Emit order update to registered handlers"""
    for handler in self._order_handlers:
        try:
            handler(order)
        except Exception as e:
            self._logger.error(f"Order handler error: {e}")
```

## Acceptance Criteria

- [ ] Order entity created from signal
- [ ] Order saved before submission (crash recovery)
- [ ] Order submitted to broker API
- [ ] Filled orders update positions
- [ ] Rejected orders logged with reason
- [ ] Partial fills tracked correctly
- [ ] Connection errors handled gracefully
- [ ] Rate limit errors handled gracefully
- [ ] Order events emitted to handlers
- [ ] P&L calculated on position close

## Dependencies

- **Upstream**: E13-F01 (LiveOrder), E13-F02-T03, E03 (Broker)
- **Downstream**: E13-F03-T02, E13-F04

## Testing

```python
async def test_execute_order_success():
    runner = create_test_runner()
    signal = create_test_signal(symbol="005930", quantity=100)

    mock_broker.place_order.return_value = OrderResult(
        status="filled",
        order_id="BROKER123",
        filled_price=72000,
        commission=100
    )

    order = await runner._execute_order(signal)

    assert order.status == OrderStatus.FILLED
    assert order.broker_order_id == "BROKER123"
    assert "005930" in runner._positions

async def test_execute_order_rejection():
    runner = create_test_runner()
    signal = create_test_signal()

    mock_broker.place_order.return_value = OrderResult(
        status="rejected",
        error_message="Insufficient balance"
    )

    order = await runner._execute_order(signal)

    assert order.status == OrderStatus.REJECTED
    assert "Insufficient balance" in order.error_message
```

---
*Estimated: 4 hours | Risk: High*
