# Spec: E13-F02-T01 - Implement LiveTradingSessionManager Core

---
id: E13-F02-T01
clickup_task_id: '86ew0fphn'
title: Implement LiveTradingSessionManager Core
type: task
parent: E13-F02
epic: E13
feature: F02
domain: live-trading
status: draft
priority: high
created: '2025-12-30'
updated: '2025-12-30'
estimated_hours: 4
actual_hours: 0
tags: [session-manager, engine, live-trading]
effort: medium
risk: medium
parallel: false
---

**Status**: Draft | **Type**: Task | **Parent**: E13-F02 | **Parallel**: No

## Summary

Implement the core `LiveTradingSessionManager` class that manages the lifecycle of live trading sessions. This includes session creation, start, pause, resume, and stop operations, as well as maintaining a registry of active sessions.

## Implementation Details

### File Location
`src/application/live_trading/session_manager.py`

### LiveTradingSessionManager

```python
from typing import Protocol
import asyncio
import uuid

class LiveTradingSessionManager:
    """
    Manage live trading sessions.

    Handles session lifecycle (create, start, pause, resume, stop)
    and maintains a registry of active sessions with their runners.
    """

    def __init__(
        self,
        broker_registry: IBrokerRegistry,
        processing_engine: ProcessingEngine,
        session_repo: ILiveTradingSessionRepository,
        order_repo: IOrderRepository,
        backtest_repo: IBacktestRepository,
        paper_session_repo: IPaperTradingSessionRepository
    ):
        self._broker_registry = broker_registry
        self._engine = processing_engine
        self._session_repo = session_repo
        self._order_repo = order_repo
        self._backtest_repo = backtest_repo
        self._paper_session_repo = paper_session_repo
        self._active_sessions: dict[str, LiveTradingRunner] = {}

    async def start_session(
        self,
        config: LiveSessionConfig
    ) -> LiveTradingSession:
        """Start a new live trading session"""
        # Verify prerequisites
        prereq = await self.check_prerequisites(config.strategy)
        if not prereq.all_passed:
            raise PreRequisiteNotMetError(prereq)

        # Get broker
        broker = self._broker_registry.get(config.broker_id)
        if not broker:
            raise BrokerNotFoundError(config.broker_id)

        # Create session entity
        session = LiveTradingSession(
            id=str(uuid.uuid4()),
            strategy_id=config.strategy.id,
            strategy_name=config.strategy.name,
            broker_id=config.broker_id,
            account_id=config.account_id,
            symbols=config.symbols,
            risk_controls=config.risk_controls,
            execution_mode=config.execution_mode,
            status=SessionStatus.CREATED
        )

        # Save session
        await self._session_repo.save(session)

        # Create and start runner
        runner = LiveTradingRunner(
            session=session,
            broker=broker,
            engine=self._engine,
            order_repo=self._order_repo
        )
        self._active_sessions[session.id] = runner

        # Start runner in background
        session.start()
        await self._session_repo.save(session)
        asyncio.create_task(runner.run())

        return session

    async def stop_session(self, session_id: str) -> LiveTradingSession:
        """Stop a running session"""
        if session_id not in self._active_sessions:
            raise SessionNotFoundError(session_id)

        runner = self._active_sessions[session_id]
        await runner.stop()

        del self._active_sessions[session_id]

        session = await self._session_repo.get(session_id)
        session.stop()
        await self._session_repo.save(session)

        return session

    async def pause_session(self, session_id: str) -> LiveTradingSession:
        """Pause a running session"""
        runner = self._active_sessions.get(session_id)
        if not runner:
            raise SessionNotFoundError(session_id)

        await runner.pause()

        session = await self._session_repo.get(session_id)
        session.pause()
        await self._session_repo.save(session)

        return session

    async def resume_session(self, session_id: str) -> LiveTradingSession:
        """Resume a paused session"""
        runner = self._active_sessions.get(session_id)
        if not runner:
            raise SessionNotFoundError(session_id)

        await runner.resume()

        session = await self._session_repo.get(session_id)
        session.resume()
        await self._session_repo.save(session)

        return session

    def get_active_sessions(self) -> list[LiveTradingSession]:
        """Get all active sessions"""
        return [
            runner.session
            for runner in self._active_sessions.values()
        ]
```

## Acceptance Criteria

- [ ] SessionManager constructor with all dependencies
- [ ] start_session creates and starts session
- [ ] stop_session stops and removes session
- [ ] pause_session pauses running session
- [ ] resume_session resumes paused session
- [ ] get_active_sessions returns list of active sessions
- [ ] Prerequisites verified before start
- [ ] Session persisted to repository
- [ ] Runner started in background task

## Dependencies

- **Upstream**: E13-F01 (Domain Models), E03 (Broker Registry)
- **Downstream**: E13-F02-T02, E13-F02-T03

## Testing

```python
async def test_start_session_success():
    manager = create_test_manager()
    config = create_test_config()
    session = await manager.start_session(config)
    assert session.status == SessionStatus.RUNNING
    assert session.id in manager._active_sessions

async def test_start_session_prerequisites_fail():
    manager = create_test_manager(backtest_passed=False)
    config = create_test_config()
    with pytest.raises(PreRequisiteNotMetError):
        await manager.start_session(config)
```

---
*Estimated: 4 hours | Risk: Medium*
