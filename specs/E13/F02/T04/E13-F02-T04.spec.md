# Spec: E13-F02-T04 - Implement Risk Control Enforcement

---
id: E13-F02-T04
clickup_task_id: '86ew0fpjb'
title: Implement Risk Control Enforcement
type: task
parent: E13-F02
epic: E13
feature: F02
domain: live-trading
status: draft
priority: high
created: '2025-12-30'
updated: '2025-12-30'
estimated_hours: 3
actual_hours: 0
tags: [risk-controls, validation, safety]
effort: medium
risk: high
parallel: false
---

**Status**: Draft | **Type**: Task | **Parent**: E13-F02 | **Parallel**: No

## Summary

Implement the risk control enforcement logic in `LiveTradingRunner`. This includes the `_passes_risk_check` method that validates each potential trade against configured limits before allowing order execution.

## Implementation Details

### File Location
`src/application/live_trading/runner.py` (add to existing class)

### Risk Control Methods

```python
def _passes_risk_check(self, quote) -> bool:
    """
    Check if a potential trade passes all risk controls.

    Validates:
    1. Max positions limit not exceeded
    2. Position size within portfolio percentage limit
    3. Daily loss limit not reached

    Returns True only if ALL checks pass.
    """
    controls = self._session.risk_controls

    # Check 1: Max positions limit
    if len(self._positions) >= controls.max_positions:
        self._logger.info(
            f"Risk check failed: max positions reached "
            f"({len(self._positions)}/{controls.max_positions})"
        )
        return False

    # Check 2: Position size percentage
    position_size = self._calculate_position_size(quote.price)
    position_value = quote.price * position_size
    portfolio_value = self._get_portfolio_value()

    if portfolio_value > 0:
        position_pct = (position_value / portfolio_value) * 100
        if position_pct > controls.max_position_size_pct:
            self._logger.info(
                f"Risk check failed: position size {position_pct:.1f}% "
                f"exceeds max {controls.max_position_size_pct}%"
            )
            return False

    # Check 3: Daily loss limit (already checked in main loop, but double-check)
    if self._is_daily_limit_reached():
        self._logger.info("Risk check failed: daily loss limit reached")
        return False

    # All checks passed
    return True


def update_daily_pnl(self, pnl_change: Decimal):
    """
    Update daily P&L tracking.

    Called after each order fill to track running daily P&L.
    """
    self._daily_pnl += pnl_change
    self._logger.info(f"Daily P&L updated: {self._daily_pnl:,.0f}")

    # Emit event if approaching limit
    controls = self._session.risk_controls
    portfolio_value = self._get_portfolio_value()
    max_loss = portfolio_value * Decimal(controls.max_daily_loss_pct / 100)

    if self._daily_pnl <= -max_loss * Decimal("0.8"):
        self._logger.warning(
            f"Warning: Approaching daily loss limit "
            f"(current: {self._daily_pnl:,.0f}, limit: {-max_loss:,.0f})"
        )


def get_risk_status(self) -> RiskStatus:
    """
    Get current risk status for UI display.

    Returns summary of risk control usage.
    """
    controls = self._session.risk_controls
    portfolio_value = self._get_portfolio_value()
    max_loss = portfolio_value * Decimal(controls.max_daily_loss_pct / 100)

    return RiskStatus(
        current_positions=len(self._positions),
        max_positions=controls.max_positions,
        daily_pnl=self._daily_pnl,
        daily_loss_limit=-max_loss,
        daily_pnl_pct=float(self._daily_pnl / portfolio_value * 100) if portfolio_value else 0,
        is_within_trading_hours=self._is_within_trading_hours(),
        is_daily_limit_reached=self._is_daily_limit_reached()
    )


@dataclass
class RiskStatus:
    """Current risk control status for display"""
    current_positions: int
    max_positions: int
    daily_pnl: Decimal
    daily_loss_limit: Decimal
    daily_pnl_pct: float
    is_within_trading_hours: bool
    is_daily_limit_reached: bool

    @property
    def positions_available(self) -> int:
        return max(0, self.max_positions - self.current_positions)

    @property
    def daily_loss_remaining(self) -> Decimal:
        return self.daily_loss_limit - self.daily_pnl
```

## Acceptance Criteria

- [ ] _passes_risk_check validates max_positions limit
- [ ] _passes_risk_check validates position_size_pct limit
- [ ] _passes_risk_check validates daily_loss limit
- [ ] All check failures are logged with details
- [ ] update_daily_pnl tracks running P&L
- [ ] Warning emitted when approaching daily limit (80%)
- [ ] get_risk_status returns current status for UI
- [ ] RiskStatus includes all relevant fields
- [ ] All calculations use Decimal for precision

## Dependencies

- **Upstream**: E13-F02-T03, E13-F01-T02 (RiskControls)
- **Downstream**: E13-F03, E13-F04 (UI displays risk status)

## Testing

```python
def test_passes_risk_check_max_positions():
    runner = create_test_runner(max_positions=2)
    runner._positions = {"A": pos1, "B": pos2}  # 2 positions
    quote = create_quote(symbol="C", price=50000)
    assert runner._passes_risk_check(quote) == False

def test_passes_risk_check_position_size():
    runner = create_test_runner(
        max_position_size_pct=10,
        portfolio_value=10000000
    )
    quote = create_quote(price=100000)  # Would be > 10%
    runner._calculate_position_size = lambda p: 15  # 1.5M = 15%
    assert runner._passes_risk_check(quote) == False

def test_update_daily_pnl_warning():
    runner = create_test_runner(max_daily_loss_pct=5)
    runner._daily_pnl = Decimal(-400000)  # 4% of 10M
    # Update to -4.5% should trigger warning
    with capture_logs() as logs:
        runner.update_daily_pnl(Decimal(-50000))
    assert "Warning" in logs.output

def test_get_risk_status():
    runner = create_test_runner()
    runner._positions = {"A": pos1}
    runner._daily_pnl = Decimal(-100000)
    status = runner.get_risk_status()
    assert status.current_positions == 1
    assert status.positions_available == 4
    assert status.daily_pnl == Decimal(-100000)
```

---
*Estimated: 3 hours | Risk: High*
