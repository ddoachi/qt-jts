# Spec: E13-F02-T03 - Implement LiveTradingRunner with Main Loop

---
id: E13-F02-T03
clickup_task_id: '86ew0fpj5'
title: Implement LiveTradingRunner with Main Loop
type: task
parent: E13-F02
epic: E13
feature: F02
domain: live-trading
status: draft
priority: high
created: '2025-12-30'
updated: '2025-12-30'
estimated_hours: 5
actual_hours: 0
tags: [runner, main-loop, trading-engine]
effort: large
risk: high
parallel: false
---

**Status**: Draft | **Type**: Task | **Parent**: E13-F02 | **Parallel**: No

## Summary

Implement the `LiveTradingRunner` class that executes the main trading loop. This includes processing market data, evaluating entry/exit conditions, generating signals, and coordinating with the order execution layer. The runner is the core execution engine for live trading.

## Implementation Details

### File Location
`src/application/live_trading/runner.py`

### LiveTradingRunner

```python
import asyncio
import logging
from datetime import datetime
from decimal import Decimal
from typing import Callable

import pandas as pd

class LiveTradingRunner:
    """
    Execute live trading logic.

    Main trading loop that:
    1. Checks trading hours and daily limits
    2. Processes each symbol for entry/exit signals
    3. Applies risk controls
    4. Coordinates order execution
    """

    def __init__(
        self,
        session: LiveTradingSession,
        broker: IBrokerGateway,
        engine: ProcessingEngine,
        order_repo: IOrderRepository,
        tick_interval: float = 1.0
    ):
        self._session = session
        self._broker = broker
        self._engine = engine
        self._order_repo = order_repo
        self._tick_interval = tick_interval

        self._is_running = False
        self._is_paused = False
        self._daily_pnl = Decimal(0)
        self._positions: dict[str, Position] = {}

        # Signal handlers for UI updates
        self._signal_handlers: list[Callable[[TradingSignal], None]] = []
        self._order_handlers: list[Callable[[LiveOrder], None]] = []

        self._logger = logging.getLogger(__name__)

    @property
    def session(self) -> LiveTradingSession:
        return self._session

    async def run(self):
        """Main trading loop"""
        self._is_running = True
        self._logger.info(f"Starting live trading runner for session {self._session.id}")

        # Load existing positions
        await self._load_positions()

        while self._is_running:
            # Check if paused
            if self._is_paused:
                await asyncio.sleep(1)
                continue

            # Check if within trading hours
            if not self._is_within_trading_hours():
                self._logger.debug("Outside trading hours, sleeping...")
                await asyncio.sleep(60)
                continue

            # Check daily loss limit
            if self._is_daily_limit_reached():
                self._logger.warning("Daily loss limit reached, pausing trading")
                await asyncio.sleep(60)
                continue

            # Process each symbol
            for symbol in self._session.symbols:
                try:
                    await self._process_symbol(symbol)
                except Exception as e:
                    self._logger.error(f"Error processing {symbol}: {e}")

            await asyncio.sleep(self._tick_interval)

        self._logger.info(f"Live trading runner stopped for session {self._session.id}")

    async def stop(self):
        """Stop the trading loop"""
        self._is_running = False

    async def pause(self):
        """Pause trading"""
        self._is_paused = True

    async def resume(self):
        """Resume trading"""
        self._is_paused = False

    async def _load_positions(self):
        """Load existing positions from broker"""
        try:
            positions = await self._broker.get_positions(self._session.account_id)
            for pos in positions:
                if pos.symbol in self._session.symbols:
                    self._positions[pos.symbol] = pos
            self._logger.info(f"Loaded {len(self._positions)} existing positions")
        except Exception as e:
            self._logger.error(f"Failed to load positions: {e}")

    async def _process_symbol(self, symbol: str):
        """Process a single symbol for entry/exit"""
        quote = await self._broker.get_latest_quote(symbol)
        if not quote:
            return

        if symbol in self._positions:
            # Update position with current price
            self._positions[symbol].current_price = quote.price
            await self._check_exit(symbol, quote)
        else:
            await self._check_entry(symbol, quote)

    async def _check_entry(self, symbol: str, quote):
        """Check entry conditions and generate signal if triggered"""
        # Get recent candles for strategy evaluation
        candles = await self._broker.get_recent_candles(symbol, limit=100)
        if not candles or len(candles) < 20:  # Need minimum data
            return

        # Convert to DataFrame for formula evaluation
        df = pd.DataFrame([c.__dict__ for c in candles])

        # Evaluate entry rule
        strategy = self._session.strategy
        result = self._engine.evaluate_formula(
            strategy.entry_rule,
            df
        )

        # Check if entry signal triggered
        if not result.iloc[-1]:
            return

        # Run risk checks
        if not self._passes_risk_check(quote):
            self._logger.debug(f"Risk check failed for {symbol}")
            return

        # Calculate position size
        quantity = self._calculate_position_size(quote.price)

        # Generate signal
        signal = TradingSignal(
            id=str(uuid.uuid4()),
            session_id=self._session.id,
            symbol=symbol,
            symbol_name=quote.symbol_name,
            signal_type=SignalType.ENTRY,
            direction=TradeDirection.BUY,
            price=quote.price,
            quantity=quantity,
            reason="Entry rule triggered",
            timestamp=datetime.utcnow()
        )

        # Emit signal to handlers (for UI)
        await self._emit_signal(signal)

        # Handle based on execution mode
        if self._session.execution_mode == ExecutionMode.AUTO:
            await self._execute_order(signal)

    async def _check_exit(self, symbol: str, quote):
        """Check exit conditions for existing position"""
        # Similar pattern to _check_entry but for exit rules
        # ... implementation details ...
        pass

    def _is_within_trading_hours(self) -> bool:
        """Check if current time is within trading hours"""
        return self._session.risk_controls.is_within_trading_hours(
            datetime.now().time()
        )

    def _is_daily_limit_reached(self) -> bool:
        """Check if daily loss limit has been reached"""
        controls = self._session.risk_controls
        if not controls.max_daily_loss_pct:
            return False

        portfolio_value = self._get_portfolio_value()
        if portfolio_value <= 0:
            return False

        max_loss = portfolio_value * Decimal(controls.max_daily_loss_pct / 100)
        return self._daily_pnl <= -max_loss

    def _get_portfolio_value(self) -> Decimal:
        """Get current portfolio value"""
        # Implementation depends on broker API
        return Decimal(10000000)  # Placeholder

    def _calculate_position_size(self, price: Decimal) -> int:
        """Calculate position size based on risk controls"""
        controls = self._session.risk_controls
        portfolio_value = self._get_portfolio_value()

        max_position_value = portfolio_value * Decimal(controls.max_position_size_pct / 100)
        return int(max_position_value / price)

    async def _emit_signal(self, signal: TradingSignal):
        """Emit signal to registered handlers"""
        for handler in self._signal_handlers:
            try:
                handler(signal)
            except Exception as e:
                self._logger.error(f"Signal handler error: {e}")

    def add_signal_handler(self, handler: Callable[[TradingSignal], None]):
        """Add a signal handler"""
        self._signal_handlers.append(handler)

    def add_order_handler(self, handler: Callable[[LiveOrder], None]):
        """Add an order handler"""
        self._order_handlers.append(handler)
```

## Acceptance Criteria

- [ ] Main loop runs with configurable tick interval
- [ ] Trading hours check prevents processing outside hours
- [ ] Daily loss limit check pauses trading
- [ ] Each symbol processed for entry/exit
- [ ] Entry conditions evaluated using ProcessingEngine
- [ ] Position size calculated from risk controls
- [ ] Signals emitted to registered handlers
- [ ] AUTO mode executes orders immediately
- [ ] Pause/resume functionality works
- [ ] All errors logged and handled

## Dependencies

- **Upstream**: E13-F01, E13-F02-T01, E03 (Broker), E09 (ProcessingEngine)
- **Downstream**: E13-F02-T04, E13-F03

## Testing

```python
async def test_runner_respects_trading_hours():
    runner = create_test_runner(trading_hours=time(9,0)-time(15,30))
    # Mock current time to 16:00
    with mock_time(hour=16):
        processed = await runner._process_symbol("005930")
        assert processed == False  # Should not process

async def test_runner_daily_limit_check():
    runner = create_test_runner(max_daily_loss_pct=5.0)
    runner._daily_pnl = Decimal(-600000)  # > 5% of 10M
    assert runner._is_daily_limit_reached() == True

async def test_runner_emits_signals():
    runner = create_test_runner()
    signals_received = []
    runner.add_signal_handler(lambda s: signals_received.append(s))
    # ... trigger entry signal
    assert len(signals_received) == 1
```

---
*Estimated: 5 hours | Risk: High*
