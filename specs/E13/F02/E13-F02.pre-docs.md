# E13-F02: Live Trading Engine - Pre-Implementation Documentation

## Feature Overview

| Field | Value |
|-------|-------|
| Feature ID | E13-F02 |
| Title | Live Trading Engine |
| Parent Epic | E13 (Live Trading) |
| Estimated Hours | 16 |
| Tasks | 4 |
| Risk Level | High |

---

## 1. Implementation Strategy

### 1.1 Approach

This feature implements the core trading engine consisting of `LiveTradingSessionManager` and `LiveTradingRunner`. We use async/await patterns for concurrent operations and the observer pattern for signal emission to the UI layer.

### 1.2 Key Patterns

- **Async/Await**: For non-blocking broker operations
- **Repository Pattern**: For session and order persistence
- **Observer Pattern**: For signal and order event emission
- **Dependency Injection**: For broker, engine, and repository dependencies

### 1.3 Implementation Order

```
T01 (SessionManager) ──→ T02 (Prerequisites)
         │
         └──→ T03 (Runner) ──→ T04 (Risk Controls)
```

---

## 2. File Structure

```
src/application/live_trading/
├── __init__.py
├── session_manager.py   # T01, T02: SessionManager
├── runner.py            # T03, T04: LiveTradingRunner
├── config.py            # LiveSessionConfig dataclass
└── exceptions.py        # BrokerNotFoundError, SessionNotFoundError
```

---

## 3. Task Implementation Details

### 3.1 T01: SessionManager Core (4 hours)

**File**: `src/application/live_trading/session_manager.py`

```python
import asyncio
import uuid
from typing import Protocol

from domain.live_trading import (
    LiveTradingSession, SessionStatus, PreRequisiteCheck,
    PreRequisiteNotMetError, RiskControls
)


class LiveTradingSessionManager:
    """
    Manage live trading sessions.

    Handles session lifecycle (create, start, pause, resume, stop)
    and maintains a registry of active sessions.

    Example:
        >>> manager = LiveTradingSessionManager(...)
        >>> session = await manager.start_session(config)
        >>> await manager.pause_session(session.id)
        >>> await manager.stop_session(session.id)
    """

    def __init__(
        self,
        broker_registry: IBrokerRegistry,
        processing_engine: ProcessingEngine,
        session_repo: ILiveTradingSessionRepository,
        order_repo: IOrderRepository,
        backtest_repo: IBacktestRepository,
        paper_session_repo: IPaperTradingSessionRepository
    ):
        self._broker_registry = broker_registry
        self._engine = processing_engine
        self._session_repo = session_repo
        self._order_repo = order_repo
        self._backtest_repo = backtest_repo
        self._paper_session_repo = paper_session_repo
        self._active_sessions: dict[str, LiveTradingRunner] = {}

    async def start_session(self, config: LiveSessionConfig) -> LiveTradingSession:
        """
        Start a new live trading session.

        1. Verify prerequisites
        2. Get broker from registry
        3. Create session entity
        4. Save to repository
        5. Create and start runner

        Raises:
            PreRequisiteNotMetError: If prerequisites not met
            BrokerNotFoundError: If broker not available
        """
        # Implementation details...

    async def stop_session(self, session_id: str) -> LiveTradingSession:
        """Stop a running session permanently"""
        # Implementation details...

    async def pause_session(self, session_id: str) -> LiveTradingSession:
        """Pause a running session temporarily"""
        # Implementation details...

    async def resume_session(self, session_id: str) -> LiveTradingSession:
        """Resume a paused session"""
        # Implementation details...

    def get_active_sessions(self) -> list[LiveTradingSession]:
        """Get all currently active sessions"""
        return [r.session for r in self._active_sessions.values()]
```

---

### 3.2 T02: Prerequisite Checking (3 hours)

**Add to**: `src/application/live_trading/session_manager.py`

```python
async def check_prerequisites(self, strategy: Strategy) -> PreRequisiteCheck:
    """
    Check all prerequisites for live trading.

    Evaluates:
    1. Backtest performance (Sharpe >= threshold)
    2. Paper trading history (minimum days)
    3. Risk parameters configured
    4. Broker connected
    5. Account verified

    Example:
        >>> check = await manager.check_prerequisites(strategy)
        >>> if check.all_passed:
        ...     await manager.start_session(config)
        >>> else:
        ...     print(f"Failed: {check.failed_checks}")
    """
    # Get backtest results
    backtest = await self._backtest_repo.get_latest_by_strategy(strategy.id)
    backtest_passed = False
    backtest_sharpe = None

    if backtest:
        backtest_sharpe = backtest.metrics.sharpe_ratio
        threshold = strategy.risk_config.require_backtest_sharpe or 1.0
        backtest_passed = backtest_sharpe >= threshold

    # Get paper trading history
    paper_sessions = await self._paper_session_repo.get_by_strategy(strategy.id)
    paper_trading_days = len(paper_sessions)
    required_days = strategy.risk_config.require_paper_trading_days or 5
    paper_trading_passed = paper_trading_days >= required_days

    # Check configuration and connectivity
    risk_parameters_set = strategy.risk_config is not None
    healthy_brokers = self._broker_registry.get_healthy()
    broker_connected = len(healthy_brokers) > 0
    account_verified = True  # TODO: Implement verification

    return PreRequisiteCheck(
        strategy_id=strategy.id,
        backtest_passed=backtest_passed,
        backtest_sharpe=backtest_sharpe,
        paper_trading_passed=paper_trading_passed,
        paper_trading_days=paper_trading_days,
        risk_parameters_set=risk_parameters_set,
        broker_connected=broker_connected,
        account_verified=account_verified
    )
```

---

### 3.3 T03: LiveTradingRunner (5 hours)

**File**: `src/application/live_trading/runner.py`

```python
import asyncio
import logging
from datetime import datetime
from decimal import Decimal
from typing import Callable

import pandas as pd


class LiveTradingRunner:
    """
    Execute live trading logic.

    Main loop:
    1. Check trading hours
    2. Check daily loss limit
    3. Process each symbol for entry/exit
    4. Generate signals
    5. Execute orders (in AUTO mode)

    Example:
        >>> runner = LiveTradingRunner(session, broker, engine, order_repo)
        >>> runner.add_signal_handler(lambda s: print(f"Signal: {s}"))
        >>> await runner.run()  # Blocks until stopped
    """

    def __init__(
        self,
        session: LiveTradingSession,
        broker: IBrokerGateway,
        engine: ProcessingEngine,
        order_repo: IOrderRepository,
        tick_interval: float = 1.0
    ):
        self._session = session
        self._broker = broker
        self._engine = engine
        self._order_repo = order_repo
        self._tick_interval = tick_interval

        self._is_running = False
        self._is_paused = False
        self._daily_pnl = Decimal(0)
        self._positions: dict[str, Position] = {}

        self._signal_handlers: list[Callable] = []
        self._order_handlers: list[Callable] = []
        self._logger = logging.getLogger(__name__)

    async def run(self):
        """
        Main trading loop.

        Runs until stop() is called. Respects pause state.
        """
        self._is_running = True
        self._logger.info(f"Starting runner for session {self._session.id}")

        await self._load_positions()

        while self._is_running:
            if self._is_paused:
                await asyncio.sleep(1)
                continue

            if not self._is_within_trading_hours():
                await asyncio.sleep(60)
                continue

            if self._is_daily_limit_reached():
                self._logger.warning("Daily loss limit reached")
                await asyncio.sleep(60)
                continue

            for symbol in self._session.symbols:
                try:
                    await self._process_symbol(symbol)
                except Exception as e:
                    self._logger.error(f"Error processing {symbol}: {e}")

            await asyncio.sleep(self._tick_interval)

    async def _process_symbol(self, symbol: str):
        """Process a single symbol for entry/exit signals"""
        quote = await self._broker.get_latest_quote(symbol)
        if not quote:
            return

        if symbol in self._positions:
            self._positions[symbol].current_price = quote.price
            await self._check_exit(symbol, quote)
        else:
            await self._check_entry(symbol, quote)

    async def _check_entry(self, symbol: str, quote):
        """Check entry conditions and generate signal if triggered"""
        candles = await self._broker.get_recent_candles(symbol, limit=100)
        if not candles or len(candles) < 20:
            return

        df = pd.DataFrame([c.__dict__ for c in candles])
        result = self._engine.evaluate_formula(
            self._session.strategy.entry_rule, df
        )

        if not result.iloc[-1]:
            return

        if not self._passes_risk_check(quote):
            return

        quantity = self._calculate_position_size(quote.price)
        signal = TradingSignal(
            session_id=self._session.id,
            symbol=symbol,
            direction=TradeDirection.BUY,
            price=quote.price,
            quantity=quantity
        )

        await self._emit_signal(signal)

        if self._session.execution_mode == ExecutionMode.AUTO:
            await self._execute_order(signal)
```

---

### 3.4 T04: Risk Control Enforcement (3 hours)

**Add to**: `src/application/live_trading/runner.py`

```python
def _passes_risk_check(self, quote) -> bool:
    """
    Validate trade against risk controls.

    Checks:
    1. Max positions not exceeded
    2. Position size within limit
    3. Daily loss limit not reached

    Returns True only if ALL checks pass.
    """
    controls = self._session.risk_controls

    # Check max positions
    if len(self._positions) >= controls.max_positions:
        self._logger.info(f"Max positions reached: {len(self._positions)}/{controls.max_positions}")
        return False

    # Check position size
    position_size = self._calculate_position_size(quote.price)
    position_value = quote.price * position_size
    portfolio_value = self._get_portfolio_value()

    if portfolio_value > 0:
        position_pct = (position_value / portfolio_value) * 100
        if position_pct > controls.max_position_size_pct:
            self._logger.info(f"Position size {position_pct:.1f}% exceeds limit")
            return False

    # Check daily loss
    if self._is_daily_limit_reached():
        return False

    return True


def get_risk_status(self) -> RiskStatus:
    """Get current risk status for UI display"""
    controls = self._session.risk_controls
    portfolio_value = self._get_portfolio_value()
    max_loss = portfolio_value * Decimal(controls.max_daily_loss_pct / 100)

    return RiskStatus(
        current_positions=len(self._positions),
        max_positions=controls.max_positions,
        daily_pnl=self._daily_pnl,
        daily_loss_limit=-max_loss,
        is_within_trading_hours=self._is_within_trading_hours(),
        is_daily_limit_reached=self._is_daily_limit_reached()
    )
```

---

## 4. Testing Strategy

### 4.1 Unit Tests

| Component | Coverage Target |
|-----------|-----------------|
| SessionManager | 85% |
| check_prerequisites | 95% |
| Runner main loop | 80% |
| Risk controls | 100% |

### 4.2 Integration Tests

- Session start → runner execution → stop
- Prerequisite check with mock repositories
- Signal generation with mock broker

### 4.3 Mock Requirements

```python
# Mock broker for testing
class MockBroker:
    async def get_latest_quote(self, symbol):
        return Quote(symbol=symbol, price=Decimal(72000))

    async def get_recent_candles(self, symbol, limit):
        return [Candle(...) for _ in range(limit)]

    async def place_order(self, **kwargs):
        return OrderResult(status="filled", filled_price=72000)
```

---

## 5. Integration Points

### 5.1 Upstream Dependencies

| Dependency | Component | Purpose |
|------------|-----------|---------|
| F01 | Domain Models | All entities |
| E03 | IBrokerGateway | Order execution |
| E03 | IBrokerRegistry | Broker discovery |
| E09 | ProcessingEngine | Formula evaluation |
| E12 | PaperTradingRepo | Prerequisites |

### 5.2 Downstream Consumers

| Consumer | Usage |
|----------|-------|
| F03 | Order execution |
| F04 | Signal/order events |

---

## 6. Error Handling

### 6.1 Exception Hierarchy

```python
class LiveTradingError(Exception):
    """Base exception for live trading"""
    pass

class BrokerNotFoundError(LiveTradingError):
    """Broker not available in registry"""
    pass

class SessionNotFoundError(LiveTradingError):
    """Session not found in active sessions"""
    pass
```

### 6.2 Error Scenarios

| Scenario | Handling |
|----------|----------|
| Broker disconnection | Log error, pause session, notify UI |
| Prerequisites fail | Raise PreRequisiteNotMetError |
| Order rejected | Log error, emit failed order event |
| Symbol processing error | Log error, continue with next symbol |

---

## 7. Acceptance Checklist

- [ ] SessionManager creates sessions correctly
- [ ] Prerequisites validated before start
- [ ] Runner executes main loop
- [ ] Trading hours respected
- [ ] Daily loss limit pauses trading
- [ ] Max positions enforced
- [ ] Position size limit enforced
- [ ] Signals emitted for UI
- [ ] AUTO mode executes immediately
- [ ] > 85% test coverage

---

## 8. Safety Critical Code

### Risk Control Validation (MUST be 100% tested)

```python
# This code is safety critical - prevents excessive trading
def _passes_risk_check(self, quote) -> bool:
    # CRITICAL: Every check must be validated
    if len(self._positions) >= controls.max_positions:
        return False  # TEST: Verify this blocks new positions

    if position_pct > controls.max_position_size_pct:
        return False  # TEST: Verify this blocks large positions

    if self._is_daily_limit_reached():
        return False  # TEST: Verify this blocks after losses

    return True
```

---

*Pre-docs generated: 2025-12-30*
