# Spec: E13-F01-T03 - Define LiveTradingSession and LiveOrder Entities

---
id: E13-F01-T03
clickup_task_id: '86ew0fph7'
title: Define LiveTradingSession and LiveOrder Entities
type: task
parent: E13-F01
epic: E13
feature: F01
domain: live-trading
status: draft
priority: high
created: '2025-12-30'
updated: '2025-12-30'
estimated_hours: 3
actual_hours: 0
tags: [entities, session, order, domain]
effort: medium
risk: low
parallel: false
---

**Status**: Draft | **Type**: Task | **Parent**: E13-F01 | **Parallel**: No

## Summary

Define the core entities `LiveTradingSession` and `LiveOrder` that represent a live trading session and individual orders within that session. These entities track the complete lifecycle of live trading operations.

## Implementation Details

### File Location
`src/domain/live_trading/entities.py`

### LiveTradingSession Entity

```python
from dataclasses import dataclass, field
from datetime import datetime
from decimal import Decimal
from typing import Optional
import uuid

from .enums import ExecutionMode, SessionStatus
from .risk_controls import RiskControls

@dataclass
class LiveTradingSession:
    """
    Live trading session entity.

    Represents an active or historical live trading session with a specific
    strategy, broker, and risk controls.
    """
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    strategy_id: int = 0  # Reference to Strategy
    strategy_name: str = ""
    broker_id: str = ""
    account_id: str = ""
    symbols: list[str] = field(default_factory=list)
    risk_controls: RiskControls = field(default_factory=RiskControls)
    execution_mode: ExecutionMode = ExecutionMode.MANUAL
    status: SessionStatus = SessionStatus.CREATED
    started_at: Optional[datetime] = None
    stopped_at: Optional[datetime] = None
    created_at: datetime = field(default_factory=datetime.utcnow)

    def start(self) -> None:
        """Mark session as started"""
        self.status = SessionStatus.RUNNING
        self.started_at = datetime.utcnow()

    def pause(self) -> None:
        """Pause the session"""
        self.status = SessionStatus.PAUSED

    def resume(self) -> None:
        """Resume a paused session"""
        if self.status == SessionStatus.PAUSED:
            self.status = SessionStatus.RUNNING

    def stop(self) -> None:
        """Stop the session permanently"""
        self.status = SessionStatus.STOPPED
        self.stopped_at = datetime.utcnow()

    def set_error(self, error_message: str) -> None:
        """Set session to error state"""
        self.status = SessionStatus.ERROR
        self.stopped_at = datetime.utcnow()
```

### LiveOrder Entity

```python
@dataclass
class LiveOrder:
    """
    Order for live trading.

    Tracks the complete lifecycle of an order from creation through
    submission to final status (filled, cancelled, rejected, or failed).
    """
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    session_id: str = ""
    symbol: str = ""
    symbol_name: str = ""  # Korean name for display
    side: OrderSide = OrderSide.BUY
    order_type: OrderType = OrderType.MARKET
    quantity: int = 0
    price: Optional[Decimal] = None  # For limit orders
    status: OrderStatus = OrderStatus.PENDING
    broker_order_id: Optional[str] = None
    filled_quantity: int = 0
    filled_price: Optional[Decimal] = None
    commission: Decimal = Decimal(0)
    created_at: datetime = field(default_factory=datetime.utcnow)
    submitted_at: Optional[datetime] = None
    filled_at: Optional[datetime] = None
    error_message: Optional[str] = None

    @property
    def is_terminal(self) -> bool:
        """Check if order is in a terminal state"""
        return self.status in {
            OrderStatus.FILLED,
            OrderStatus.CANCELLED,
            OrderStatus.REJECTED,
            OrderStatus.FAILED
        }

    @property
    def total_value(self) -> Decimal:
        """Calculate total order value"""
        price = self.filled_price or self.price or Decimal(0)
        return price * self.quantity

    def submit(self) -> None:
        """Mark order as submitted"""
        self.status = OrderStatus.SUBMITTED
        self.submitted_at = datetime.utcnow()

    def fill(self, filled_price: Decimal, commission: Decimal) -> None:
        """Mark order as filled"""
        self.status = OrderStatus.FILLED
        self.filled_quantity = self.quantity
        self.filled_price = filled_price
        self.commission = commission
        self.filled_at = datetime.utcnow()

    def partial_fill(self, quantity: int, price: Decimal) -> None:
        """Record partial fill"""
        self.status = OrderStatus.PARTIAL
        self.filled_quantity = quantity
        self.filled_price = price

    def reject(self, error_message: str) -> None:
        """Mark order as rejected by broker"""
        self.status = OrderStatus.REJECTED
        self.error_message = error_message

    def fail(self, error_message: str) -> None:
        """Mark order as failed (submission error)"""
        self.status = OrderStatus.FAILED
        self.error_message = error_message
```

## Acceptance Criteria

- [ ] LiveTradingSession with all fields from spec
- [ ] Lifecycle methods: start, pause, resume, stop, set_error
- [ ] LiveOrder with complete order tracking
- [ ] Order lifecycle methods: submit, fill, partial_fill, reject, fail
- [ ] is_terminal property for terminal state check
- [ ] total_value property for order value calculation
- [ ] All Decimal types for monetary values
- [ ] UUID generation for entity IDs
- [ ] UTC timestamps throughout

## Dependencies

- **Upstream**: E13-F01-T01 (enums), E13-F01-T02 (RiskControls)
- **Downstream**: E13-F02, E13-F03, E13-F04

## Testing

```python
def test_session_lifecycle():
    session = LiveTradingSession()
    assert session.status == SessionStatus.CREATED
    session.start()
    assert session.status == SessionStatus.RUNNING
    assert session.started_at is not None
    session.stop()
    assert session.status == SessionStatus.STOPPED

def test_order_fill():
    order = LiveOrder(symbol="005930", quantity=100)
    order.submit()
    assert order.status == OrderStatus.SUBMITTED
    order.fill(Decimal("72000"), Decimal("100"))
    assert order.status == OrderStatus.FILLED
    assert order.total_value == Decimal("7200000")
```

---
*Estimated: 3 hours | Risk: Low*
