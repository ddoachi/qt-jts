# E13-F01: Domain Models - Pre-Implementation Documentation

## Feature Overview

| Field | Value |
|-------|-------|
| Feature ID | E13-F01 |
| Title | Live Trading Domain Models |
| Parent Epic | E13 (Live Trading) |
| Estimated Hours | 8 |
| Tasks | 4 |
| Risk Level | Low |

---

## 1. Implementation Strategy

### 1.1 Approach

This feature establishes the foundational domain models for live trading. We'll use Python dataclasses for immutable, type-safe entities with validation. The implementation follows Domain-Driven Design principles with clear value objects and entities.

### 1.2 Key Patterns

- **Frozen Dataclasses**: For immutable configuration (RiskControls, PreRequisiteCheck)
- **Mutable Dataclasses**: For entities with state changes (LiveTradingSession, LiveOrder)
- **Enums**: For type-safe status and mode values
- **Decimal**: For all monetary calculations (avoid float precision issues)
- **UTC Timestamps**: All datetime values in UTC

### 1.3 Implementation Order

```
T01 (Enums) ─────┐
                 ├──→ T03 (Entities) ──→ Complete
T02 (RiskControls)┘
                 │
T01 (Enums) ─────┴──→ T04 (Prerequisites)
```

---

## 2. File Structure

```
src/domain/live_trading/
├── __init__.py
├── enums.py           # T01: All enums
├── risk_controls.py   # T02: RiskControls dataclass
├── entities.py        # T03: LiveTradingSession, LiveOrder
└── prerequisites.py   # T04: PreRequisiteCheck, PreRequisiteNotMetError
```

---

## 3. Task Implementation Details

### 3.1 T01: Define Enums (2 hours)

**File**: `src/domain/live_trading/enums.py`

```python
from enum import Enum

class ExecutionMode(Enum):
    """
    Execution mode for live trading sessions.

    MANUAL: User confirms each trade before execution
    SEMI_AUTO: User confirms, then auto-execute for N seconds
    AUTO: Fully automatic execution (requires explicit consent)
    """
    MANUAL = "manual"
    SEMI_AUTO = "semi_auto"
    AUTO = "auto"


class SessionStatus(Enum):
    """
    Status of a live trading session.

    Lifecycle: CREATED → RUNNING ⇄ PAUSED → STOPPED
                            ↓
                          ERROR
    """
    CREATED = "created"
    RUNNING = "running"
    PAUSED = "paused"
    STOPPED = "stopped"
    ERROR = "error"


class OrderStatus(Enum):
    """
    Status of a live order.

    Lifecycle: PENDING → SUBMITTED → FILLED
                            ↓           ↓
                        PARTIAL    CANCELLED
                            ↓
                     REJECTED / FAILED
    """
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIAL = "partial"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"
    FAILED = "failed"


class OrderSide(Enum):
    """Side of an order"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """Type of order"""
    MARKET = "market"
    LIMIT = "limit"
```

**Tests**: `tests/unit/domain/test_live_trading_enums.py`

---

### 3.2 T02: Define RiskControls (2 hours)

**File**: `src/domain/live_trading/risk_controls.py`

```python
from dataclasses import dataclass, field
from datetime import time
from decimal import Decimal
from typing import Optional


@dataclass(frozen=True)
class RiskControls:
    """
    Risk control configuration for live trading.

    Immutable to prevent accidental modification during trading.

    Example:
        >>> controls = RiskControls(max_positions=3, max_daily_loss_pct=3.0)
        >>> controls.is_within_trading_hours(time(10, 0))
        True
    """
    # Position limits
    max_position_size_pct: float = 10.0
    max_positions: int = 5

    # Loss limits
    max_daily_loss_pct: float = 5.0
    max_daily_loss_amount: Optional[Decimal] = None

    # Trading hours (KRX: 09:00-15:30)
    trading_hours_start: Optional[time] = field(default_factory=lambda: time(9, 0))
    trading_hours_end: Optional[time] = field(default_factory=lambda: time(15, 30))

    # Prerequisites thresholds
    require_backtest_sharpe: Optional[float] = 1.0
    require_paper_trading_days: Optional[int] = 5

    def __post_init__(self):
        """Validate risk control values"""
        if not 0 < self.max_position_size_pct <= 100:
            raise ValueError("max_position_size_pct must be between 0 and 100")
        if self.max_positions <= 0:
            raise ValueError("max_positions must be positive")
        if not 0 < self.max_daily_loss_pct <= 100:
            raise ValueError("max_daily_loss_pct must be between 0 and 100")

    def is_within_trading_hours(self, current_time: time) -> bool:
        """Check if current time is within configured trading hours"""
        if not self.trading_hours_start or not self.trading_hours_end:
            return True
        return self.trading_hours_start <= current_time <= self.trading_hours_end
```

**Tests**: `tests/unit/domain/test_risk_controls.py`

---

### 3.3 T03: Define Entities (3 hours)

**File**: `src/domain/live_trading/entities.py`

```python
from dataclasses import dataclass, field
from datetime import datetime
from decimal import Decimal
from typing import Optional
import uuid

from .enums import ExecutionMode, SessionStatus, OrderStatus, OrderSide, OrderType
from .risk_controls import RiskControls


@dataclass
class LiveTradingSession:
    """
    Live trading session entity.

    Manages the lifecycle of a live trading session including
    start, pause, resume, and stop operations.
    """
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    strategy_id: int = 0
    strategy_name: str = ""
    broker_id: str = ""
    account_id: str = ""
    symbols: list[str] = field(default_factory=list)
    risk_controls: RiskControls = field(default_factory=RiskControls)
    execution_mode: ExecutionMode = ExecutionMode.MANUAL
    status: SessionStatus = SessionStatus.CREATED
    started_at: Optional[datetime] = None
    stopped_at: Optional[datetime] = None
    created_at: datetime = field(default_factory=datetime.utcnow)

    def start(self) -> None:
        """Transition to RUNNING status"""
        self.status = SessionStatus.RUNNING
        self.started_at = datetime.utcnow()

    def pause(self) -> None:
        """Transition to PAUSED status"""
        self.status = SessionStatus.PAUSED

    def resume(self) -> None:
        """Resume from PAUSED to RUNNING"""
        if self.status == SessionStatus.PAUSED:
            self.status = SessionStatus.RUNNING

    def stop(self) -> None:
        """Transition to STOPPED status (terminal)"""
        self.status = SessionStatus.STOPPED
        self.stopped_at = datetime.utcnow()

    def set_error(self, message: str) -> None:
        """Transition to ERROR status (terminal)"""
        self.status = SessionStatus.ERROR
        self.stopped_at = datetime.utcnow()


@dataclass
class LiveOrder:
    """
    Order for live trading.

    Tracks complete lifecycle from creation through broker submission
    to final status (filled, cancelled, rejected, or failed).
    """
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    session_id: str = ""
    symbol: str = ""
    symbol_name: str = ""
    side: OrderSide = OrderSide.BUY
    order_type: OrderType = OrderType.MARKET
    quantity: int = 0
    price: Optional[Decimal] = None
    status: OrderStatus = OrderStatus.PENDING
    broker_order_id: Optional[str] = None
    filled_quantity: int = 0
    filled_price: Optional[Decimal] = None
    commission: Decimal = Decimal(0)
    created_at: datetime = field(default_factory=datetime.utcnow)
    submitted_at: Optional[datetime] = None
    filled_at: Optional[datetime] = None
    error_message: Optional[str] = None

    @property
    def is_terminal(self) -> bool:
        """Check if order is in terminal state"""
        return self.status in {
            OrderStatus.FILLED,
            OrderStatus.CANCELLED,
            OrderStatus.REJECTED,
            OrderStatus.FAILED
        }

    @property
    def total_value(self) -> Decimal:
        """Calculate total order value"""
        price = self.filled_price or self.price or Decimal(0)
        return price * self.quantity

    def submit(self) -> None:
        """Mark as submitted to broker"""
        self.status = OrderStatus.SUBMITTED
        self.submitted_at = datetime.utcnow()

    def fill(self, filled_price: Decimal, commission: Decimal) -> None:
        """Mark as fully filled"""
        self.status = OrderStatus.FILLED
        self.filled_quantity = self.quantity
        self.filled_price = filled_price
        self.commission = commission
        self.filled_at = datetime.utcnow()

    def partial_fill(self, quantity: int, price: Decimal) -> None:
        """Record partial fill"""
        self.status = OrderStatus.PARTIAL
        self.filled_quantity = quantity
        self.filled_price = price

    def reject(self, error_message: str) -> None:
        """Mark as rejected by broker"""
        self.status = OrderStatus.REJECTED
        self.error_message = error_message

    def fail(self, error_message: str) -> None:
        """Mark as failed (submission error)"""
        self.status = OrderStatus.FAILED
        self.error_message = error_message
```

**Tests**: `tests/unit/domain/test_live_trading_entities.py`

---

### 3.4 T04: Define PreRequisiteCheck (1 hour)

**File**: `src/domain/live_trading/prerequisites.py`

```python
from dataclasses import dataclass
from typing import Optional


@dataclass(frozen=True)
class PreRequisiteCheck:
    """
    Pre-requisites validation for live trading.

    Immutable snapshot of prerequisite check results.
    All prerequisites must pass before live trading can begin.
    """
    strategy_id: int

    # Backtest requirements
    backtest_passed: bool = False
    backtest_sharpe: Optional[float] = None
    backtest_total_trades: Optional[int] = None

    # Paper trading requirements
    paper_trading_passed: bool = False
    paper_trading_days: Optional[int] = None
    paper_trading_pnl: Optional[float] = None

    # Configuration
    risk_parameters_set: bool = False

    # Broker
    broker_connected: bool = False
    account_verified: bool = False
    account_balance: Optional[float] = None

    @property
    def all_passed(self) -> bool:
        """Check if ALL prerequisites are met"""
        return all([
            self.backtest_passed,
            self.paper_trading_passed,
            self.risk_parameters_set,
            self.broker_connected,
            self.account_verified
        ])

    @property
    def failed_checks(self) -> list[str]:
        """Return list of failed prerequisite names"""
        failed = []
        if not self.backtest_passed:
            failed.append("backtest")
        if not self.paper_trading_passed:
            failed.append("paper_trading")
        if not self.risk_parameters_set:
            failed.append("risk_parameters")
        if not self.broker_connected:
            failed.append("broker_connection")
        if not self.account_verified:
            failed.append("account_verification")
        return failed

    @property
    def summary(self) -> str:
        """Human-readable summary"""
        if self.all_passed:
            return "All prerequisites passed"
        return f"Failed: {', '.join(self.failed_checks)}"


class PreRequisiteNotMetError(Exception):
    """Raised when live trading prerequisites are not met"""

    def __init__(self, check: PreRequisiteCheck):
        self.check = check
        super().__init__(f"Prerequisites not met: {check.summary}")
```

**Tests**: `tests/unit/domain/test_prerequisites.py`

---

## 4. Testing Strategy

### 4.1 Unit Test Coverage

| File | Target Coverage |
|------|-----------------|
| enums.py | 100% |
| risk_controls.py | 95% |
| entities.py | 90% |
| prerequisites.py | 95% |

### 4.2 Key Test Cases

**Enums**:
- All values accessible
- String values correct for serialization

**RiskControls**:
- Default values correct
- Validation rejects invalid values
- Trading hours check works

**Entities**:
- Session lifecycle transitions
- Order status transitions
- is_terminal property
- total_value calculation

**Prerequisites**:
- all_passed logic (all True → True, any False → False)
- failed_checks returns correct list
- Exception contains check details

---

## 5. Integration Points

This feature has **no runtime dependencies** on other features. It provides the foundation that F02, F03, and F04 depend on.

### Downstream Consumers

| Consumer | Usage |
|----------|-------|
| F02 (Engine) | All entities and enums |
| F03 (Execution) | LiveOrder, OrderStatus |
| F04 (UI) | All entities for display |

---

## 6. Acceptance Checklist

- [ ] All enums defined with complete values
- [ ] RiskControls with defaults and validation
- [ ] LiveTradingSession with lifecycle methods
- [ ] LiveOrder with status tracking
- [ ] PreRequisiteCheck with all_passed logic
- [ ] All Decimal for monetary values
- [ ] All datetime in UTC
- [ ] > 90% test coverage
- [ ] No external dependencies
- [ ] Type hints complete

---

## 7. Notes

### Design Decisions

1. **Frozen vs Mutable**: RiskControls and PreRequisiteCheck are frozen (immutable) because they represent configuration/snapshots. Entities (Session, Order) are mutable because they have state transitions.

2. **Decimal for Money**: Using Decimal instead of float to avoid precision issues in financial calculations.

3. **UUID for IDs**: Using UUID strings for entity IDs to ensure uniqueness without database dependency.

4. **UTC Timestamps**: All timestamps in UTC to avoid timezone issues. Conversion to local time happens at display layer.

### Potential Issues

- **Enum serialization**: Ensure `.value` is used when serializing to JSON/database
- **Decimal serialization**: May need custom JSON encoder for Decimal
- **Timezone awareness**: datetime.utcnow() returns naive datetime, consider using timezone-aware

---

*Pre-docs generated: 2025-12-30*
