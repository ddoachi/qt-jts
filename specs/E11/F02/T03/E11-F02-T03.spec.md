# Spec: E11-F02-T03 - Result Ranking and Walk-Forward Integration

---
# ============================================================================
# SPEC METADATA
# ============================================================================

# === IDENTIFICATION ===
id: E11-F02-T03
clickup_task_id: '86ew0fpk8'
title: Result Ranking and Walk-Forward Integration
type: task

# === HIERARCHY ===
parent: E11-F02
children: []
epic: E11
feature: F02
task: T03
domain: optimization

# === WORKFLOW ===
status: draft
priority: high

# === TRACKING ===
created: '2025-12-30'
updated: '2025-12-30'
due_date: ''
estimated_hours: 3
actual_hours: 0

# === METADATA ===
tags: [ranking, sorting, walk-forward, integration]
effort: medium
risk: low
wave: 5
parallel: true
---

**Status**: Draft
**Type**: Task
**Parent**: E11-F02 (Grid Search Optimizer Engine)
**Wave**: 5 (Depends on T01, can parallel with T02)

## Executive Summary

Implement result ranking by optimization target metric (Sharpe, Return, etc.) and integrate walk-forward analysis for the top result. Results are sorted in descending order and assigned ranks. Walk-forward is triggered when walk_forward_splits > 0 in config.

## User Stories

**As a** trader
**I want to** see results ranked by my chosen metric
**So that** I can easily identify the best parameters

## Acceptance Scenarios

### Scenario 1: Rank by Sharpe
**Given** results with Sharpe ratios [1.2, 1.8, 1.5, 1.0]
**When** ranked by SHARPE target
**Then** order becomes [1.8, 1.5, 1.2, 1.0]
**And** ranks are [1, 2, 3, 4]

### Scenario 2: Rank by Total Return
**Given** results with returns [10%, 25%, 15%, 5%]
**When** ranked by TOTAL_RETURN target
**Then** order becomes [25%, 15%, 10%, 5%]

### Scenario 3: Walk-Forward Integration
**Given** optimization with walk_forward_splits=5
**When** optimization completes
**Then** WalkForwardAnalyzer is called with best parameters
**And** result includes walk_forward_results

### Scenario 4: No Walk-Forward
**Given** optimization with walk_forward_splits=0
**When** optimization completes
**Then** walk_forward_results is None

## Requirements

### Functional Requirements
- **FR-001**: _rank_results() MUST sort by selected optimization target descending
- **FR-002**: Each result MUST have rank assigned (1 = best)
- **FR-003**: optimize() MUST call WalkForwardAnalyzer when splits > 0
- **FR-004**: Walk-forward uses best (rank 1) parameters

### Technical Constraints
- **TC-001**: Use Python sorted() with key function
- **TC-002**: Access metrics via OptimizationTarget enum mapping

## Implementation Details

### File Location
`src/domain/services/optimization/grid_search_optimizer.py`

### Code Structure (Addition to T01/T02)
```python
class GridSearchOptimizer:
    # ... (from T01, T02)

    def _rank_results(
        self,
        results: list[ParameterResult],
        target: OptimizationTarget
    ) -> list[ParameterResult]:
        """Rank results by optimization target metric"""
        def get_metric(r: ParameterResult) -> float:
            metrics = r.metrics
            if target == OptimizationTarget.SHARPE:
                return metrics.sharpe_ratio
            elif target == OptimizationTarget.TOTAL_RETURN:
                return metrics.total_return_pct
            elif target == OptimizationTarget.PROFIT_FACTOR:
                return metrics.profit_factor
            elif target == OptimizationTarget.WIN_RATE:
                return metrics.win_rate
            elif target == OptimizationTarget.CALMAR:
                return metrics.calmar_ratio
            return 0.0

        # Sort descending (best first)
        sorted_results = sorted(results, key=get_metric, reverse=True)

        # Assign ranks
        for i, result in enumerate(sorted_results):
            result.rank = i + 1

        return sorted_results

    async def optimize(
        self,
        config: OptimizationConfig,
        progress_callback: Optional[Callable[[int, int], None]] = None
    ) -> OptimizationResult:
        """Run grid search with ranking and walk-forward"""
        # ... (parallel execution from T02)

        results = self._rank_results(results, config.optimization_target)

        # Walk-forward analysis on best result
        walk_forward_result = None
        if results and config.walk_forward_splits > 0:
            analyzer = WalkForwardAnalyzer(self)
            walk_forward_result = await analyzer.analyze(
                config,
                n_splits=config.walk_forward_splits,
                train_ratio=config.train_ratio
            )

        return OptimizationResult.create(
            config=config,
            results=results,
            walk_forward=walk_forward_result,
            execution_time_ms=elapsed_ms
        )
```

## Dependencies

### Upstream
- E11-F02-T01: GridSearchOptimizer class
- E11-F02-T02: Results from parallel execution
- E11-F01: OptimizationTarget enum, ParameterResult

### Downstream
- E11-F03: WalkForwardAnalyzer called from here
- E11-F04: UI displays ranked results

## Success Criteria

- [ ] _rank_results() sorts correctly for all 5 targets
- [ ] Ranks assigned correctly (1 = best)
- [ ] Walk-forward triggered when splits > 0
- [ ] Walk-forward skipped when splits = 0
- [ ] Unit tests for all ranking scenarios

---
*Template Version: 2.0.0*
