# Spec: E11-F03-T02 - Robustness Scoring

---
# ============================================================================
# SPEC METADATA
# ============================================================================

# === IDENTIFICATION ===
id: E11-F03-T02
clickup_task_id: '86ew0fpkh'
title: Robustness Scoring
type: task

# === HIERARCHY ===
parent: E11-F03
children: []
epic: E11
feature: F03
task: T02
domain: optimization

# === WORKFLOW ===
status: draft
priority: high

# === TRACKING ===
created: '2025-12-30'
updated: '2025-12-30'
due_date: ''
estimated_hours: 2
actual_hours: 0

# === METADATA ===
tags: [robustness, scoring, sharpe-ratio, validation]
effort: small
risk: low
wave: 6
parallel: true
---

**Status**: Draft
**Type**: Task
**Parent**: E11-F03 (Walk-Forward Analyzer)
**Wave**: 6 (Can parallel with T01 in implementation)

## Executive Summary

Implement robustness scoring calculation from walk-forward split results. Calculate average in-sample and out-of-sample Sharpe ratios, compute robustness score as out/in ratio, and determine is_robust flag based on 0.5 threshold. A robust strategy retains at least 50% of its in-sample performance on unseen data.

## User Stories

**As a** trader
**I want to** see a clear robustness score
**So that** I know if my optimized parameters will work in live trading

## Acceptance Scenarios

### Scenario 1: Calculate Averages
**Given** 5 splits with in-sample Sharpe [1.9, 1.8, 1.85, 1.9, 1.82]
**And** out-sample Sharpe [1.45, 1.28, 1.42, 1.25, 1.35]
**When** averages are calculated
**Then** avg_in_sample = 1.854
**And** avg_out_sample = 1.35

### Scenario 2: Calculate Robustness Score
**Given** avg_in = 1.854, avg_out = 1.35
**When** robustness_score is calculated
**Then** it equals ~0.728 (1.35 / 1.854)

### Scenario 3: Robust Strategy
**Given** robustness_score = 0.72
**When** is_robust is evaluated
**Then** it returns True (0.72 > 0.5)

### Scenario 4: Overfitted Strategy
**Given** robustness_score = 0.25
**When** is_robust is evaluated
**Then** it returns False (0.25 < 0.5)

### Scenario 5: Edge Case - Zero In-Sample
**Given** avg_in = 0 (edge case)
**When** robustness_score is calculated
**Then** it returns 0 (avoid division by zero)

## Requirements

### Functional Requirements
- **FR-001**: MUST calculate avg_in_sample_sharpe from all splits
- **FR-002**: MUST calculate avg_out_sample_sharpe from all splits
- **FR-003**: robustness_score MUST equal avg_out / avg_in
- **FR-004**: MUST handle avg_in = 0 case (return 0)
- **FR-005**: is_robust MUST be True when score > 0.5

### Technical Constraints
- **TC-001**: Use mean calculation (sum / count)
- **TC-002**: Threshold at 0.5 per PRD ("at least 50%")

## Implementation Details

### File Location
`src/domain/models/optimization.py` (WalkForwardResult.from_splits)

### Code Structure
```python
@dataclass
class WalkForwardResult:
    """Aggregate walk-forward analysis results"""
    splits: list[WalkForwardSplit]
    avg_in_sample_sharpe: float
    avg_out_sample_sharpe: float
    robustness_score: float
    is_robust: bool

    @classmethod
    def from_splits(cls, splits: list[WalkForwardSplit]) -> 'WalkForwardResult':
        """Calculate robustness metrics from split results"""
        if not splits:
            return cls(
                splits=[],
                avg_in_sample_sharpe=0.0,
                avg_out_sample_sharpe=0.0,
                robustness_score=0.0,
                is_robust=False
            )

        # Calculate averages
        in_sample_sharpes = [s.in_sample_metrics.sharpe_ratio for s in splits]
        out_sample_sharpes = [s.out_sample_metrics.sharpe_ratio for s in splits]

        avg_in = sum(in_sample_sharpes) / len(in_sample_sharpes)
        avg_out = sum(out_sample_sharpes) / len(out_sample_sharpes)

        # Calculate robustness (handle division by zero)
        robustness = avg_out / avg_in if avg_in > 0 else 0.0

        # Determine if robust (>= 50% of in-sample performance)
        is_robust = robustness > 0.5

        return cls(
            splits=splits,
            avg_in_sample_sharpe=avg_in,
            avg_out_sample_sharpe=avg_out,
            robustness_score=robustness,
            is_robust=is_robust
        )

    @property
    def summary(self) -> str:
        """Human-readable summary"""
        status = "Robust" if self.is_robust else "Overfitted"
        return f"Robustness: {self.robustness_score:.2f} ({status})"
```

## Dependencies

### Upstream
- E11-F03-T01: Provides WalkForwardSplit results
- E11-F01-T03: WalkForwardSplit and WalkForwardResult dataclasses

### Downstream
- E11-F04: UI displays robustness score and status

## Success Criteria

- [ ] Average calculations are correct
- [ ] Robustness score = out/in ratio
- [ ] Division by zero handled gracefully
- [ ] is_robust threshold at 0.5 works
- [ ] Unit tests cover all scenarios including edge cases

---
*Template Version: 2.0.0*
