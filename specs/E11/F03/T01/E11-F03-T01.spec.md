# Spec: E11-F03-T01 - WalkForwardAnalyzer Core

---
# ============================================================================
# SPEC METADATA
# ============================================================================

# === IDENTIFICATION ===
id: E11-F03-T01
clickup_task_id: '86ew0fpkf'
title: WalkForwardAnalyzer Core
type: task

# === HIERARCHY ===
parent: E11-F03
children: []
epic: E11
feature: F03
task: T01
domain: optimization

# === WORKFLOW ===
status: draft
priority: high

# === TRACKING ===
created: '2025-12-30'
updated: '2025-12-30'
due_date: ''
estimated_hours: 5
actual_hours: 0

# === METADATA ===
tags: [walk-forward, validation, splits, robustness]
effort: large
risk: medium
wave: 6
parallel: false
---

**Status**: Draft
**Type**: Task
**Parent**: E11-F03 (Walk-Forward Analyzer)
**Wave**: 6 (Depends on F02)

## Executive Summary

Implement the WalkForwardAnalyzer class with date range splitting logic and the main analyze() loop. Creates train/test splits, runs optimization on each training period, validates on testing period, and collects results. Integrates with GridSearchOptimizer for in-sample optimization.

## User Stories

**As a** trader
**I want to** validate that optimized parameters work on unseen data
**So that** I avoid overfitting to historical noise

## Acceptance Scenarios

### Scenario 1: Create 5 Splits
**Given** 2 years of data (730 days) with 5 splits, 70% train
**When** _create_splits() is called
**Then** 5 split tuples are returned
**And** each split has ~102 days training, ~44 days testing

### Scenario 2: Per-Split Optimization
**Given** 5 splits configured
**When** analyze() runs
**Then** GridSearchOptimizer.optimize() is called 5 times
**And** walk_forward_splits=0 is set to prevent recursion

### Scenario 3: Out-of-Sample Validation
**Given** optimal parameters found for split
**When** out-of-sample backtest runs
**Then** test period uses optimal params from training
**And** out_sample_metrics are recorded

## Requirements

### Functional Requirements
- **FR-001**: _create_splits() MUST divide date range into n segments
- **FR-002**: Each segment MUST have train_ratio% training, rest testing
- **FR-003**: analyze() MUST run optimization on each training period
- **FR-004**: analyze() MUST validate on testing period with best params
- **FR-005**: MUST set walk_forward_splits=0 in per-split optimization

### Technical Constraints
- **TC-001**: Reuse GridSearchOptimizer for training optimization
- **TC-002**: Use timedelta for date calculations
- **TC-003**: Handle date boundary edge cases

## Implementation Details

### File Location
`src/domain/services/optimization/walk_forward_analyzer.py`

### Code Structure
```python
from datetime import timedelta
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from domain.models.optimization import (
        OptimizationConfig, WalkForwardResult, WalkForwardSplit
    )
    from domain.models.backtest import DateRange

class WalkForwardAnalyzer:
    """Walk-forward analysis for robustness testing"""

    def __init__(self, optimizer: 'GridSearchOptimizer'):
        self._optimizer = optimizer

    def _create_splits(
        self,
        date_range: 'DateRange',
        n_splits: int,
        train_ratio: float
    ) -> list[tuple['DateRange', 'DateRange']]:
        """Create train/test date range splits"""
        total_days = (date_range.end - date_range.start).days
        split_size = total_days // n_splits

        splits = []
        for i in range(n_splits):
            split_start = date_range.start + timedelta(days=i * split_size)
            split_end = split_start + timedelta(days=split_size - 1)

            train_days = int(split_size * train_ratio)
            train_end = split_start + timedelta(days=train_days - 1)

            train_range = DateRange(split_start, train_end)
            test_range = DateRange(train_end + timedelta(days=1), split_end)

            splits.append((train_range, test_range))

        return splits

    async def analyze(
        self,
        config: 'OptimizationConfig',
        n_splits: int = 5,
        train_ratio: float = 0.7
    ) -> 'WalkForwardResult':
        """Run walk-forward analysis"""
        splits = self._create_splits(config.date_range, n_splits, train_ratio)
        split_results = []

        for i, (train_range, test_range) in enumerate(splits):
            # Optimize on training period (no nested walk-forward)
            train_config = OptimizationConfig(
                strategy=config.strategy,
                parameters=config.parameters,
                optimization_target=config.optimization_target,
                date_range=train_range,
                symbols=config.symbols,
                walk_forward_splits=0  # CRITICAL: prevent recursion
            )

            opt_result = await self._optimizer.optimize(train_config)
            best_params = opt_result.results[0].parameters

            # Validate on out-of-sample period
            test_strategy = self._optimizer._apply_params(config.strategy, best_params)
            test_config = BacktestConfig(
                strategy=test_strategy,
                symbols=config.symbols,
                start_date=test_range.start,
                end_date=test_range.end
            )

            test_result = await self._optimizer._backtest_engine.run(test_config)

            split_results.append(WalkForwardSplit(
                split_index=i,
                train_start=train_range.start,
                train_end=train_range.end,
                test_start=test_range.start,
                test_end=test_range.end,
                optimal_params=best_params,
                in_sample_metrics=opt_result.results[0].metrics,
                out_sample_metrics=test_result.metrics
            ))

        # Robustness calculation in T02
        return WalkForwardResult.from_splits(split_results)
```

## Dependencies

### Upstream
- E11-F02: GridSearchOptimizer for training optimization
- E11-F01: Domain models
- E10: BacktestEngine, DateRange

### Downstream
- E11-F03-T02: Uses split results for robustness calculation

## Success Criteria

- [ ] _create_splits() divides dates correctly
- [ ] Per-split optimization runs with walk_forward_splits=0
- [ ] Out-of-sample validation uses correct parameters
- [ ] All split results collected correctly
- [ ] Unit tests verify date calculations

---
*Template Version: 2.0.0*
