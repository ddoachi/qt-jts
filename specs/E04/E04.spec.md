# Epic E04: Historical Data Collection

## Metadata

| Field | Value |
|-------|-------|
| Epic ID | E04 |
| Title | Historical Data Collection |
| Status | Draft |
| Platform | Cross-platform |
| Dependencies | E02 (Storage), E03 (Broker) |
| PRD Sections | 5.1 |

---

## 1. Overview

### 1.1 Purpose

Download and store historical OHLCV candle data from brokers for:
- Backtesting strategies on historical data
- Pattern discovery and analysis
- Market scanning with historical context

### 1.2 Goals

1. **Bulk Collection**: Download years of data for thousands of symbols
2. **Incremental Updates**: Only fetch new data since last collection
3. **Rate Limit Compliance**: Never exceed broker API limits
4. **Progress Visibility**: Real-time progress with estimated completion time
5. **Reliability**: Resume on failure, retry failed symbols

---

## 2. Architecture

### 2.1 Collection Pipeline

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        Data Collection Pipeline                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌──────────┐ │
│  │  Job Queue  │───►│  Fetcher    │───►│  Validator  │───►│  Storage │ │
│  │             │    │  (Rate      │    │  (Gap       │    │  (DuckDB)│ │
│  │  - Symbols  │    │   Limited)  │    │   Check)    │    │          │ │
│  │  - Priority │    │             │    │             │    │          │ │
│  └─────────────┘    └─────────────┘    └─────────────┘    └──────────┘ │
│        ▲                   │                                      │     │
│        │                   │ Error                                │     │
│        │                   ▼                                      │     │
│        │            ┌─────────────┐                               │     │
│        └────────────│  Retry      │◄──────────────────────────────┘     │
│                     │  Queue      │                                      │
│                     └─────────────┘                                      │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 Domain Model

```python
@dataclass
class CollectionJob:
    """Data collection job entity"""
    id: str
    broker_id: str
    symbols: list[str]
    timeframe: str
    start_date: date
    end_date: date
    options: CollectionOptions
    status: JobStatus = JobStatus.PENDING
    created_at: datetime = field(default_factory=datetime.utcnow)
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None

@dataclass
class CollectionOptions:
    """Collection job options"""
    incremental: bool = True  # Skip already downloaded
    retry_failed: bool = True  # Auto-retry failed symbols
    include_delisted: bool = False  # Include delisted stocks
    max_retries: int = 3
    batch_size: int = 100  # Symbols per batch

@dataclass
class CollectionProgress:
    """Job progress tracking"""
    job_id: str
    total_symbols: int
    completed_symbols: int
    failed_symbols: int
    total_candles: int
    elapsed_seconds: float
    estimated_remaining_seconds: float

    @property
    def progress_pct(self) -> float:
        if self.total_symbols == 0:
            return 0
        return (self.completed_symbols / self.total_symbols) * 100
```

---

## 3. Use Cases

### 3.1 Start Collection Job

```python
class StartCollectionUseCase:
    """Start a data collection job"""

    def __init__(
        self,
        job_repo: ICollectionJobRepository,
        symbol_repo: ISymbolRepository,
        broker_gateway: IBrokerGateway,
        candle_repo: ICandleRepository
    ):
        self._job_repo = job_repo
        self._symbol_repo = symbol_repo
        self._broker = broker_gateway
        self._candle_repo = candle_repo

    async def execute(self, request: StartCollectionRequest) -> CollectionJob:
        # Resolve symbols based on request
        symbols = await self._resolve_symbols(request)

        # Check existing coverage if incremental
        if request.options.incremental:
            symbols = await self._filter_already_collected(
                symbols, request.timeframe
            )

        # Create job
        job = CollectionJob(
            id=str(uuid.uuid4()),
            broker_id=request.broker_id,
            symbols=symbols,
            timeframe=request.timeframe,
            start_date=request.start_date,
            end_date=request.end_date,
            options=request.options
        )

        await self._job_repo.save(job)

        # Start collection in background
        asyncio.create_task(self._run_collection(job))

        return job

    async def _run_collection(self, job: CollectionJob) -> None:
        """Execute collection job"""
        job.status = JobStatus.RUNNING
        job.started_at = datetime.utcnow()
        await self._job_repo.save(job)

        failed_symbols = []

        for symbol in job.symbols:
            try:
                await self._collect_symbol(
                    symbol, job.timeframe,
                    job.start_date, job.end_date
                )
            except Exception as e:
                failed_symbols.append((symbol, str(e)))
                if len(failed_symbols) > 10:
                    # Too many failures, pause job
                    job.status = JobStatus.PAUSED
                    break

        job.status = JobStatus.COMPLETED
        job.completed_at = datetime.utcnow()
        await self._job_repo.save(job)

    async def _collect_symbol(
        self,
        symbol: str,
        timeframe: str,
        start: date,
        end: date
    ) -> int:
        """Collect candles for single symbol"""
        candles = await self._broker.get_candles(
            symbol=symbol,
            timeframe=timeframe,
            start=datetime.combine(start, datetime.min.time()),
            end=datetime.combine(end, datetime.max.time())
        )

        # Validate data
        candles = self._validate_candles(candles)

        # Save to storage
        symbol_entity = await self._symbol_repo.get_by_code(symbol)
        count = await self._candle_repo.save_many(
            symbol_id=symbol_entity.id,
            timeframe=timeframe,
            candles=candles
        )

        return count
```

### 3.2 Monitor Collection Progress

```python
class GetCollectionProgressUseCase:
    """Get real-time collection progress"""

    def __init__(self, job_repo: ICollectionJobRepository):
        self._job_repo = job_repo

    async def execute(self, job_id: str) -> CollectionProgress:
        job = await self._job_repo.get_by_id(job_id)
        if not job:
            raise JobNotFoundError(job_id)

        stats = await self._job_repo.get_stats(job_id)

        elapsed = (datetime.utcnow() - job.started_at).total_seconds()
        rate = stats.completed / elapsed if elapsed > 0 else 0
        remaining = (stats.total - stats.completed) / rate if rate > 0 else 0

        return CollectionProgress(
            job_id=job_id,
            total_symbols=stats.total,
            completed_symbols=stats.completed,
            failed_symbols=stats.failed,
            total_candles=stats.total_candles,
            elapsed_seconds=elapsed,
            estimated_remaining_seconds=remaining
        )
```

### 3.3 Data Validation

```python
class DataValidationUseCase:
    """Validate downloaded data for gaps and errors"""

    def __init__(self, candle_repo: ICandleRepository):
        self._candle_repo = candle_repo

    async def execute(
        self,
        symbol_id: int,
        timeframe: str
    ) -> DataValidationResult:
        candles = await self._candle_repo.get_all(symbol_id, timeframe)

        gaps = self._find_gaps(candles, timeframe)
        anomalies = self._find_anomalies(candles)

        return DataValidationResult(
            symbol_id=symbol_id,
            timeframe=timeframe,
            total_candles=len(candles),
            gaps=gaps,
            anomalies=anomalies,
            is_valid=len(gaps) == 0 and len(anomalies) == 0
        )

    def _find_gaps(
        self,
        candles: list[Candle],
        timeframe: str
    ) -> list[DateRange]:
        """Find missing date ranges"""
        gaps = []
        expected_delta = self._get_expected_delta(timeframe)

        for i in range(1, len(candles)):
            actual_delta = candles[i].timestamp - candles[i-1].timestamp
            if actual_delta > expected_delta * 1.5:  # Allow some tolerance
                gaps.append(DateRange(
                    start=candles[i-1].timestamp,
                    end=candles[i].timestamp
                ))

        return gaps

    def _find_anomalies(self, candles: list[Candle]) -> list[CandleAnomaly]:
        """Find suspicious candle data"""
        anomalies = []

        for candle in candles:
            # High < Low
            if candle.high < candle.low:
                anomalies.append(CandleAnomaly(
                    timestamp=candle.timestamp,
                    type="INVALID_RANGE",
                    message="High is less than low"
                ))

            # Open/Close outside High-Low range
            if candle.open > candle.high or candle.open < candle.low:
                anomalies.append(CandleAnomaly(
                    timestamp=candle.timestamp,
                    type="OPEN_OUT_OF_RANGE",
                    message="Open is outside high-low range"
                ))

            # Zero volume on trading day
            if candle.volume == 0:
                anomalies.append(CandleAnomaly(
                    timestamp=candle.timestamp,
                    type="ZERO_VOLUME",
                    message="Zero volume"
                ))

        return anomalies
```

---

## 4. UI Components

### 4.1 Collection Configuration (PRD 5.1.2)

```
┌─────────────────────────────────────────────────────────────────────────┐
│ Historical Data Collection                                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│ Broker: [Creon ▼]                    Rate: ████████░░ 12/15 req/s       │
│                                                                          │
│ ┌─────────────────────────────────────────────────────────────────────┐ │
│ │ Symbol Selection                                                     │ │
│ │ ├─ Market: [☑ KOSPI] [☑ KOSDAQ] [☐ ETF]                            │ │
│ │ ├─ Sector: [전체 ▼]                                                  │ │
│ │ └─ Symbols: 2,456 종목 선택됨                    [종목 리스트 보기]  │ │
│ └─────────────────────────────────────────────────────────────────────┘ │
│                                                                          │
│ ┌─────────────────────────────────────────────────────────────────────┐ │
│ │ Timeframe & Period                                                   │ │
│ │ ├─ Timeframe: [일봉 ▼]                                               │ │
│ │ ├─ From: [2020-01-01]  To: [2024-12-31]                             │ │
│ │ └─ Estimated: ~4.5M candles                                          │ │
│ └─────────────────────────────────────────────────────────────────────┘ │
│                                                                          │
│ ┌─────────────────────────────────────────────────────────────────────┐ │
│ │ Options                                                              │ │
│ │ ├─ [☑] Skip already downloaded data (incremental)                   │ │
│ │ ├─ [☑] Retry failed symbols automatically                           │ │
│ │ └─ [☐] Include delisted stocks                                       │ │
│ └─────────────────────────────────────────────────────────────────────┘ │
│                                                                          │
│                                [▶ 수집 시작]  [예상 시간: 약 3시간 20분] │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.2 Collection Progress (PRD 5.1.3)

```
┌─────────────────────────────────────────────────────────────────────────┐
│ Downloading Historical Data                              [일시정지] [중지]│
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│ Overall Progress: ████████████████░░░░░░░░░░░░░░░░ 52% (1,278 / 2,456)  │
│ Elapsed: 1h 43m                                   Remaining: ~1h 35m     │
│                                                                          │
│ Rate Limit: ████████████░░░ 12/15 req/s                                 │
│                                                                          │
│ Current Symbol: 005930 삼성전자                                          │
│ ├─ Downloaded: 1,245 candles (2020-01-02 ~ 2024-12-27)                  │
│ └─ Status: Downloading...                                                │
│                                                                          │
│ ──────────────────────────────────────────────────────────────────────── │
│ Recent Activity                                                          │
│ ├─ 14:32:15  000660 SK하이닉스      1,245 candles  ✓ Complete           │
│ ├─ 14:32:08  035420 NAVER          1,245 candles  ✓ Complete           │
│ ├─ 14:32:01  051910 LG화학          1,245 candles  ✓ Complete           │
│ └─ 14:31:54  006400 삼성SDI         1,245 candles  ✓ Complete           │
│                                                                          │
│ ──────────────────────────────────────────────────────────────────────── │
│ Statistics                                                               │
│ ├─ Completed: 1,277 symbols                                              │
│ ├─ Failed: 3 symbols (retry pending)                                     │
│ ├─ Total Candles: 1,589,865                                              │
│ └─ Data Size: 245 MB                                                     │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.3 Downloaded Data View (PRD 5.1.5)

```
┌─────────────────────────────────────────────────────────────────────────┐
│ Downloaded Data                                                          │
├─────────────────────────────────────────────────────────────────────────┤
│ Filter: [Timeframe: 일봉 ▼] [Market: 전체 ▼]              [데이터 검증] │
│                                                                          │
│ ┌────────┬──────────┬────────────┬────────────┬─────────┬─────────────┐ │
│ │ Symbol │ Name     │ From       │ To         │ Candles │ Status      │ │
│ ├────────┼──────────┼────────────┼────────────┼─────────┼─────────────┤ │
│ │ 005930 │ 삼성전자 │ 2020-01-02 │ 2024-12-27 │ 1,245   │ ✓ Complete  │ │
│ │ 000660 │ SK하이닉스│ 2020-01-02 │ 2024-12-27 │ 1,245   │ ✓ Complete  │ │
│ │ 035420 │ NAVER    │ 2020-01-02 │ 2024-12-27 │ 1,245   │ ✓ Complete  │ │
│ │ 051910 │ LG화학   │ 2020-01-02 │ 2024-11-15 │ 1,203   │ ⚠ Gap found │ │
│ │ 006400 │ 삼성SDI  │ 2020-01-02 │ 2024-12-27 │ 1,245   │ ✓ Complete  │ │
│ └────────┴──────────┴────────────┴────────────┴─────────┴─────────────┘ │
│                                                                          │
│ Summary: 2,456 symbols | 3,058,620 candles | 472 MB    [CSV 내보내기]   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 5. Qt Widgets

### 5.1 Collection Config Widget

```python
class CollectionConfigWidget(QWidget):
    """Configuration widget for data collection"""

    collection_requested = Signal(StartCollectionRequest)

    def __init__(self, broker_registry: IBrokerRegistry, parent=None):
        super().__init__(parent)
        self._broker_registry = broker_registry
        self._setup_ui()

    def _setup_ui(self):
        layout = QVBoxLayout(self)

        # Broker selection
        broker_group = QGroupBox("Broker")
        broker_layout = QHBoxLayout(broker_group)
        self._broker_combo = QComboBox()
        self._rate_indicator = RateLimitIndicator()
        broker_layout.addWidget(self._broker_combo)
        broker_layout.addWidget(self._rate_indicator)
        layout.addWidget(broker_group)

        # Symbol selection
        symbol_group = QGroupBox("Symbol Selection")
        symbol_layout = QFormLayout(symbol_group)
        self._market_checks = MarketCheckboxGroup()
        self._sector_combo = QComboBox()
        self._symbol_count_label = QLabel("0 종목 선택됨")
        symbol_layout.addRow("Market:", self._market_checks)
        symbol_layout.addRow("Sector:", self._sector_combo)
        symbol_layout.addRow("", self._symbol_count_label)
        layout.addWidget(symbol_group)

        # Timeframe & Period
        period_group = QGroupBox("Timeframe & Period")
        period_layout = QFormLayout(period_group)
        self._timeframe_combo = QComboBox()
        self._timeframe_combo.addItems(["1분", "5분", "15분", "1시간", "일봉", "주봉"])
        self._start_date = QDateEdit()
        self._end_date = QDateEdit()
        period_layout.addRow("Timeframe:", self._timeframe_combo)
        period_layout.addRow("From:", self._start_date)
        period_layout.addRow("To:", self._end_date)
        layout.addWidget(period_group)

        # Options
        options_group = QGroupBox("Options")
        options_layout = QVBoxLayout(options_group)
        self._incremental_check = QCheckBox("Skip already downloaded data")
        self._retry_check = QCheckBox("Retry failed symbols automatically")
        self._delisted_check = QCheckBox("Include delisted stocks")
        options_layout.addWidget(self._incremental_check)
        options_layout.addWidget(self._retry_check)
        options_layout.addWidget(self._delisted_check)
        layout.addWidget(options_group)

        # Start button
        button_layout = QHBoxLayout()
        self._estimate_label = QLabel()
        self._start_button = QPushButton("▶ 수집 시작")
        self._start_button.clicked.connect(self._on_start_clicked)
        button_layout.addWidget(self._estimate_label)
        button_layout.addStretch()
        button_layout.addWidget(self._start_button)
        layout.addLayout(button_layout)

    def _on_start_clicked(self):
        request = self._build_request()
        self.collection_requested.emit(request)
```

### 5.2 Collection Progress Widget

```python
class CollectionProgressWidget(QWidget):
    """Real-time collection progress display"""

    pause_requested = Signal()
    stop_requested = Signal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self._setup_ui()
        self._update_timer = QTimer()
        self._update_timer.timeout.connect(self._update_progress)

    def _setup_ui(self):
        layout = QVBoxLayout(self)

        # Header with controls
        header = QHBoxLayout()
        self._title_label = QLabel("Downloading Historical Data")
        self._pause_button = QPushButton("일시정지")
        self._stop_button = QPushButton("중지")
        header.addWidget(self._title_label)
        header.addStretch()
        header.addWidget(self._pause_button)
        header.addWidget(self._stop_button)
        layout.addLayout(header)

        # Overall progress
        self._overall_progress = QProgressBar()
        self._overall_label = QLabel()
        self._time_label = QLabel()
        layout.addWidget(self._overall_progress)

        progress_info = QHBoxLayout()
        progress_info.addWidget(self._overall_label)
        progress_info.addStretch()
        progress_info.addWidget(self._time_label)
        layout.addLayout(progress_info)

        # Rate limit
        self._rate_indicator = RateLimitIndicator()
        layout.addWidget(self._rate_indicator)

        # Current symbol
        self._current_group = QGroupBox("Current Symbol")
        current_layout = QVBoxLayout(self._current_group)
        self._current_symbol_label = QLabel()
        self._current_status_label = QLabel()
        current_layout.addWidget(self._current_symbol_label)
        current_layout.addWidget(self._current_status_label)
        layout.addWidget(self._current_group)

        # Recent activity table
        self._activity_table = QTableWidget()
        self._activity_table.setColumnCount(4)
        self._activity_table.setHorizontalHeaderLabels(
            ["Time", "Symbol", "Candles", "Status"]
        )
        layout.addWidget(self._activity_table)

        # Statistics
        self._stats_group = QGroupBox("Statistics")
        stats_layout = QFormLayout(self._stats_group)
        self._completed_label = QLabel("0")
        self._failed_label = QLabel("0")
        self._candles_label = QLabel("0")
        self._size_label = QLabel("0 MB")
        stats_layout.addRow("Completed:", self._completed_label)
        stats_layout.addRow("Failed:", self._failed_label)
        stats_layout.addRow("Total Candles:", self._candles_label)
        stats_layout.addRow("Data Size:", self._size_label)
        layout.addWidget(self._stats_group)

    def set_progress(self, progress: CollectionProgress):
        """Update UI with current progress"""
        self._overall_progress.setValue(int(progress.progress_pct))
        self._overall_label.setText(
            f"{progress.completed_symbols} / {progress.total_symbols}"
        )

        elapsed = self._format_duration(progress.elapsed_seconds)
        remaining = self._format_duration(progress.estimated_remaining_seconds)
        self._time_label.setText(f"Elapsed: {elapsed}  Remaining: ~{remaining}")

        self._candles_label.setText(f"{progress.total_candles:,}")
```

---

## 6. Tasks Breakdown

| Task ID | Title | Effort | Dependencies |
|---------|-------|--------|--------------|
| E04-F01-T01 | Create CollectionJob domain entity | S | E02 |
| E04-F01-T02 | Create CollectionProgress value object | S | T01 |
| E04-F01-T03 | Define ICollectionJobRepository interface | S | T01 |
| E04-F02-T01 | Implement StartCollectionUseCase | L | F01, E03 |
| E04-F02-T02 | Implement collection worker with rate limiting | L | F02-T01 |
| E04-F02-T03 | Implement retry logic for failed symbols | M | F02-T02 |
| E04-F03-T01 | Implement GetCollectionProgressUseCase | M | F01 |
| E04-F03-T02 | Implement pause/resume functionality | M | F02 |
| E04-F04-T01 | Implement DataValidationUseCase | M | E02 |
| E04-F04-T02 | Create gap detection algorithm | M | F04-T01 |
| E04-F05-T01 | Create CollectionConfigWidget | L | E01 |
| E04-F05-T02 | Create CollectionProgressWidget | L | F03, E01 |
| E04-F05-T03 | Create DataManagementView | L | F04, E01 |
| E04-F06-T01 | Implement CSV/Parquet export | M | E02 |

---

## 7. Acceptance Criteria

### 7.1 Functional (PRD 8.1)

- [ ] Download 5 years of daily data for all KOSPI/KOSDAQ stocks
- [ ] Progress display with estimated time remaining
- [ ] Pause/resume capability
- [ ] Incremental update (skip already downloaded)
- [ ] Rate limit compliance (no broker blocks)
- [ ] Data validation for gaps/errors

### 7.2 Performance

- [ ] Collection of 2,500 symbols in < 4 hours (rate limited)
- [ ] Progress updates every 1 second
- [ ] Memory usage < 500MB during collection

### 7.3 Testing

- [ ] Unit tests with mock broker gateway
- [ ] Integration tests for storage persistence
- [ ] Test coverage > 80%

---

## 8. TDD Approach

### 8.1 Collection Use Case Test

```python
class TestStartCollectionUseCase:
    @pytest.fixture
    def use_case(self):
        job_repo = InMemoryCollectionJobRepository()
        symbol_repo = InMemorySymbolRepository()
        broker = MockBrokerGateway()
        candle_repo = InMemoryCandleRepository()

        # Setup test symbols
        symbol_repo.save(Symbol(1, "005930", "삼성전자", Market.KOSPI))
        symbol_repo.save(Symbol(2, "000660", "SK하이닉스", Market.KOSPI))

        return StartCollectionUseCase(
            job_repo, symbol_repo, broker, candle_repo
        )

    async def test_starts_collection_job(self, use_case):
        request = StartCollectionRequest(
            broker_id="mock",
            markets=[Market.KOSPI],
            timeframe="1d",
            start_date=date(2024, 1, 1),
            end_date=date(2024, 12, 31),
            options=CollectionOptions(incremental=False)
        )

        job = await use_case.execute(request)

        assert job.status == JobStatus.RUNNING
        assert len(job.symbols) == 2

    async def test_incremental_skips_existing(self, use_case):
        # Pre-populate candles for one symbol
        # ...
        pass
```

### 8.2 Data Validation Test

```python
class TestDataValidation:
    def test_finds_gaps_in_data(self):
        validator = DataValidationUseCase(InMemoryCandleRepository())

        candles = [
            Candle(datetime(2024, 1, 1), ...),
            Candle(datetime(2024, 1, 2), ...),
            # Gap: 2024-01-03 missing
            Candle(datetime(2024, 1, 4), ...),
        ]

        result = validator._find_gaps(candles, "1d")

        assert len(result) == 1
        assert result[0].start == datetime(2024, 1, 2)
        assert result[0].end == datetime(2024, 1, 4)
```

---

## 9. References

- PRD Section 5.1: Historical Data Collection
- E02: Storage Layer (candle repository)
- E03: Broker Integration (rate limiter, gateway)
