# Pre-Implementation Docs: E01-F03 - Dependency Injection Container

**Feature**: Dependency Injection Container
**Spec ID**: E01-F03
**Created**: 2025-12-28
**Estimated Effort**: 6 hours
**Reading Time**: 10-12 minutes

---

## 1. Problem & Context

### Clear Problem Statement

**Problem**: Our Qt application needs a way to manage dependencies between services without creating tight coupling. Currently, services create their own dependencies directly, making testing impossible and leading to tangled code.

**Example**: Imagine a `DataProcessor` service that needs a `Logger` and a `SettingsService`. Without DI:
```python
class DataProcessor:
    def __init__(self):
        self.logger = Logger()  # âŒ Hard-coded dependency
        self.settings = SettingsService()  # âŒ Can't test with mocks
```

### Business Impact

**Why This Matters**:
- âœ… **Testability**: Write unit tests with mock dependencies
- âœ… **Maintainability**: Change implementations without touching consumers
- âœ… **Clarity**: See all dependencies explicitly in constructors
- âœ… **Flexibility**: Swap implementations for testing/production

### Current Pain Points

| Issue | Impact | Frequency | Severity |
|-------|--------|-----------|----------|
| Hard-coded dependencies | Cannot unit test in isolation | Every service | ğŸ”´ High |
| Tight coupling | Changes ripple through codebase | Every change | ğŸ”´ High |
| No clear dependency graph | Hard to understand system structure | Daily | ğŸŸ¡ Medium |
| Manual object wiring | Error-prone startup code | Every feature | ğŸŸ¡ Medium |

### Success Metrics

- âœ… All services use constructor injection
- âœ… Service resolution time < 1ms
- âœ… Zero external dependencies (pure Python)
- âœ… 100% unit test coverage for container
- âœ… Clear error messages for configuration issues

---

## 2. Conceptual Solution

### Core Architecture

Think of the DI Container like a **smart vending machine** ğŸª:
- You register "products" (services) with recipes (factory functions)
- You specify if a product is "shared" (singleton) or "fresh each time" (transient)
- When someone asks for a product, the machine either:
  - Returns the shared instance (singleton)
  - Makes a fresh one (transient)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        DI CONTAINER ARCHITECTURE        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Registrationsâ”‚    â”‚  Singletons  â”‚  â”‚
â”‚  â”‚  Dictionary  â”‚    â”‚    Cache     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                   â”‚          â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                â”‚                        â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚         â”‚  Resolution  â”‚                â”‚
â”‚         â”‚    Logic     â”‚                â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

User Code â”€â”€â”
            â”œâ”€â†’ register() â”€â”€â†’ Store factory
Developer   â”‚
            â””â”€â†’ resolve() â”€â”€â†’ Get instance
```

### Key Concepts Explained

#### Concept 1: Service Lifetimes

**Real-World Analogy**: Think of a coffee shop â˜•

- **SINGLETON** = The coffee machine
  - One machine shared by everyone
  - Same instance every time you ask
  - Example: `Logger`, `SettingsService`

- **TRANSIENT** = Individual coffee cups
  - Fresh cup for each customer
  - New instance every time you ask
  - Example: `RequestHandler`, `DataProcessor`

**Visual Diagram**:
```
SINGLETON Lifetime:
Request 1 â”€â”€â”
Request 2 â”€â”€â”¼â”€â”€â†’ [Same Instance] â”€â”€â†’ Instance #1
Request 3 â”€â”€â”˜

TRANSIENT Lifetime:
Request 1 â”€â”€â†’ [New Instance] â”€â”€â†’ Instance #1
Request 2 â”€â”€â†’ [New Instance] â”€â”€â†’ Instance #2
Request 3 â”€â”€â†’ [New Instance] â”€â”€â†’ Instance #3
```

**Problem vs Solution**:

âŒ **Without Lifetimes**:
```python
# Who manages this? When is it created? Is it shared?
logger = Logger()  # Unclear lifecycle
```

âœ… **With Lifetimes**:
```python
# Crystal clear: singleton, created once, shared everywhere
container.register(ILogger, lambda: Logger(), Lifetime.SINGLETON)
```

**Why Use This?**

| Benefit | Description | Example |
|---------|-------------|---------|
| Memory Efficiency | Singletons reduce object creation | One logger vs 100 loggers |
| State Sharing | Singletons share state across app | Settings cache |
| Isolation | Transients ensure clean state | Each request is independent |
| Testability | Easy to mock/replace | Inject test logger |

**Concrete Example from Our System**:
```python
# Settings should be singleton - shared configuration
container.register(ISettingsService, create_settings, Lifetime.SINGLETON)

# Window instances should be transient - each window is independent
container.register(IMainWindow, create_window, Lifetime.TRANSIENT)
```

#### Concept 2: Factory Functions

**What**: A factory function is a simple function that creates and returns an instance.

**Why**: Delays object creation until actually needed (lazy initialization).

```python
# Factory function - just a regular function
def create_logger() -> ILogger:
    return ConsoleLogger(level=LogLevel.INFO)

# Register the recipe, don't call it yet
container.register(ILogger, create_logger, Lifetime.SINGLETON)

# Now call it when needed
logger = container.resolve(ILogger)  # Calls create_logger() now
```

#### Concept 3: Type-Safe Resolution

**Analogy**: Using a library card catalog ğŸ“š
- You search by category (interface type)
- You get the exact book (concrete implementation)
- IDE helps you find the right category (autocomplete)

```python
# Type hints give you IDE autocomplete and compile-time checking
logger: ILogger = container.resolve(ILogger)
#       ^^^^^^^ Your IDE knows this is ILogger
#                                 ^^^^^^^ Type-checked!
```

### Component Interactions

**Sequence Diagram: Service Resolution**

```
Developer        Container       Registrations    Singletons Cache
    â”‚                â”‚                â”‚                  â”‚
    â”‚  resolve(T)    â”‚                â”‚                  â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚                â”‚                  â”‚
    â”‚                â”‚   lookup(T)    â”‚                  â”‚
    â”‚                â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚                  â”‚
    â”‚                â”‚  factory, life â”‚                  â”‚
    â”‚                â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                  â”‚
    â”‚                â”‚                â”‚                  â”‚
    â”‚                â”‚  if SINGLETON  â”‚                  â”‚
    â”‚                â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€check cacheâ”€â”€>â”‚
    â”‚                â”‚                â”‚   exists?        â”‚
    â”‚                â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€yes/noâ”€â”€â”€â”€â”€â”€â”¤
    â”‚                â”‚                â”‚                  â”‚
    â”‚                â”‚  if not cached â”‚                  â”‚
    â”‚                â”‚  call factory()â”‚                  â”‚
    â”‚                â”‚  store resultâ”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
    â”‚                â”‚                â”‚                  â”‚
    â”‚   instance     â”‚                â”‚                  â”‚
    â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                â”‚                  â”‚
```

**Flow Diagram: Registration to Resolution**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PHASE 1: REGISTRATION (Startup)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”œâ”€â”€> Register ILogger + factory + SINGLETON
         â”œâ”€â”€> Register ISettings + factory + SINGLETON
         â””â”€â”€> Register IProcessor + factory + TRANSIENT

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PHASE 2: RESOLUTION (Runtime)                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”œâ”€â”€> Request ILogger
         â”‚    â””â”€> Check registrations âœ“
         â”‚    â””â”€> Check cache (empty)
         â”‚    â””â”€> Call factory() â†’ Logger instance
         â”‚    â””â”€> Store in cache
         â”‚    â””â”€> Return instance
         â”‚
         â”œâ”€â”€> Request ILogger again
         â”‚    â””â”€> Check cache âœ“
         â”‚    â””â”€> Return cached instance (same object!)
         â”‚
         â””â”€â”€> Request IProcessor
              â””â”€> Check registrations âœ“
              â””â”€> Call factory() â†’ new instance
              â””â”€> Return instance (no caching)
```

---

## 3. Technical Approach

### Strategy Diagrams

**Container State Lifecycle**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   CREATED    â”‚  Empty registrations, empty cache
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ register()
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CONFIGURED  â”‚  Registrations populated
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ resolve()
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   RUNNING    â”‚  Singletons cached, services active
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ clear() [for tests]
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    RESET     â”‚  Back to empty state
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Data Flow: Service Creation**

```
Interface Type (ILogger)
    â”‚
    â”œâ”€â”€> Lookup in registrations dict
    â”‚    â””â”€> Key: ILogger
    â”‚        Value: (factory_fn, Lifetime.SINGLETON)
    â”‚
    â”œâ”€â”€> Check lifetime
    â”‚    â””â”€> SINGLETON?
    â”‚        â”œâ”€> Yes: Check singletons cache
    â”‚        â”‚   â”œâ”€> Cached? Return it
    â”‚        â”‚   â””â”€> Not cached? Create, cache, return
    â”‚        â”‚
    â”‚        â””â”€> No (TRANSIENT): Create new, return
    â”‚
    â””â”€â”€> Return instance to caller
```

### Pseudocode Only

**Core Registration Logic**:
```
FUNCTION register(interface_type, factory_function, lifetime):
    IF interface_type already in registrations:
        RAISE Error("Service already registered")

    STORE (factory_function, lifetime) in registrations[interface_type]
    RETURN success
```

**Core Resolution Logic**:
```
FUNCTION resolve(interface_type):
    IF interface_type not in registrations:
        RAISE Error("Service not registered")

    GET (factory, lifetime) FROM registrations[interface_type]

    IF lifetime == SINGLETON:
        IF interface_type in singletons_cache:
            RETURN singletons_cache[interface_type]
        ELSE:
            instance = CALL factory()
            singletons_cache[interface_type] = instance
            RETURN instance

    ELSE IF lifetime == TRANSIENT:
        instance = CALL factory()
        RETURN instance
```

**Bootstrap Process**:
```
FUNCTION bootstrap_application():
    container = CREATE Container()

    # Register infrastructure (no dependencies)
    REGISTER SettingsService as SINGLETON
    REGISTER Logger as SINGLETON

    # Register application services (with dependencies)
    REGISTER DataProcessor as TRANSIENT
        FACTORY: lambda: DataProcessor(
            logger=container.resolve(ILogger),
            settings=container.resolve(ISettingsService)
        )

    VALIDATE all required services registered
    RETURN container
```

### Design Decisions Table

#### Decision 1: Explicit Registration vs Auto-Wiring

| Decision | Chosen | Why | Alternative Rejected |
|----------|--------|-----|---------------------|
| **Registration Style** | **Explicit** | **Detailed Reasoning**: Explicit registration makes the dependency graph visible and debuggable. Developers can see exactly what's registered, with what lifetime, and how dependencies are wired. This prevents "magic" behavior that's hard to understand. In a desktop Qt application, we have dozens of services, not thousands, so manual registration is manageable.<br><br>**Problem/Solution**: Auto-wiring uses reflection to scan classes and inject dependencies automatically. This seems convenient but creates problems:<br>- âŒ Hidden dependencies (can't see what's registered without debugging)<br>- âŒ Harder to debug when things go wrong<br>- âœ… Explicit registration shows everything clearly in bootstrap code<br><br>**Trade-offs**:<br>- **Gain**: Complete visibility, easier debugging, no surprises<br>- **Lose**: More boilerplate code (5-10 extra lines per service)<br><br>**Examples**:<br>```python<br># Explicit (our approach)<br>container.register(ILogger, create_logger, Lifetime.SINGLETON)<br># Clear, obvious, searchable<br><br># Auto-wiring (rejected)<br>@injectable  # Magic decorator<br>class MyService:<br>    # Dependencies injected by reflection - where? how?<br>```<br> | **Auto-Wiring**: Rejected because it uses reflection/introspection to automatically discover and inject dependencies. Specific reasons:<br>1. Adds complexity (dependency scanning, decorator magic)<br>2. Harder to debug (can't see what's happening)<br>3. Performance overhead (reflection at startup)<br>4. Not Pythonic (explicit is better than implicit) |

#### Decision 2: Two Lifetimes vs Many Scopes

| Decision | Chosen | Why | Alternative Rejected |
|----------|--------|-----|---------------------|
| **Lifetime Options** | **SINGLETON + TRANSIENT only** | **Detailed Reasoning**: Desktop applications don't need web-style scopes (request scope, session scope). We only need two patterns: shared state (singleton) and fresh instances (transient). This keeps the container simple and the API minimal.<br><br>**Problem/Solution**: Web frameworks like ASP.NET Core have "scoped" lifetimes for HTTP requests. Each request gets its own instance, but it's shared within that request. Desktop apps don't have this pattern:<br>- âŒ No HTTP requests to scope to<br>- âŒ Thread/window scoping adds complexity we don't need<br>- âœ… Singleton + Transient covers 100% of our use cases<br><br>**Trade-offs**:<br>- **Gain**: Simpler API, easier to understand, less code<br>- **Lose**: Can't do request-scoped instances (don't need them anyway)<br><br>**Examples**:<br>```python<br># Our use cases<br>Logger â†’ SINGLETON (shared everywhere)<br>SettingsService â†’ SINGLETON (shared config)<br>MainWindow â†’ TRANSIENT (each window independent)<br>RequestHandler â†’ TRANSIENT (each request isolated)<br><br># What we DON'T need<br>RequestScoped â†’ Not applicable (no HTTP requests)<br>ThreadScoped â†’ Not needed (Qt handles threading)<br>```<br> | **Multiple Scopes** (Request, Thread, Session): Rejected because they add complexity without benefit:<br>1. Desktop apps don't have HTTP requests<br>2. Qt manages threading internally<br>3. Extra scopes would require lifecycle management code<br>4. More concepts to learn and understand |

#### Decision 3: Type Hints vs String Keys

| Decision | Chosen | Why | Alternative Rejected |
|----------|--------|-----|---------------------|
| **Service Keys** | **Type hints (type[T])** | **Detailed Reasoning**: Python's type system provides free compile-time checking and IDE autocomplete. Using types as keys instead of strings prevents typos, enables refactoring, and makes the code self-documenting. Modern Python (3.11+) has excellent type hint support.<br><br>**Problem/Solution**: String-based registration is error-prone:<br>```python<br># String keys (error-prone)<br>container.register("ILogger", ...)  # typo: "ILoger"<br>logger = container.resolve("ILogger")  # runtime error<br><br># Type hints (safe)<br>container.register(ILogger, ...)  # IDE checks spelling<br>logger: ILogger = container.resolve(ILogger)  # type-checked!<br>```<br><br>**Trade-offs**:<br>- **Gain**: IDE autocomplete, refactoring safety, compile-time errors<br>- **Lose**: None (type hints are free in Python 3.11+)<br><br>**Visual Example**:<br>```<br>String Keys:         Type Hints:<br>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”<br>â”‚"ILogger" â”‚ âŒ      â”‚ ILogger  â”‚ âœ…<br>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜<br>  Runtime              Compile-time<br>  error                checking<br>```<br> | **String Keys** ("ILogger", "ISettingsService"): Rejected for several reasons:<br>1. Typos not caught until runtime<br>2. No IDE autocomplete<br>3. Refactoring breaks silently<br>4. Strings don't convey type information |

#### Decision 4: Zero Dependencies vs Using a Framework

| Decision | Chosen | Why | Alternative Rejected |
|----------|--------|-----|---------------------|
| **Implementation** | **Pure Python (zero dependencies)** | **Detailed Reasoning**: DI containers are simple data structures (just dictionaries!). Implementing our own gives us full control, zero installation overhead, and no version conflicts. The implementation is ~100 lines of codeâ€”trivial compared to learning a framework's API.<br><br>**Problem/Solution**: External DI frameworks solve problems we don't have:<br>- âŒ `dependency-injector`: 5000+ lines, complex configuration<br>- âŒ `injector`: Adds decorators, metaclasses (magic we don't need)<br>- âœ… Our simple dict-based container: Clear, debuggable, no surprises<br><br>**Trade-offs**:<br>- **Gain**: No external dependencies, full control, instant understanding<br>- **Lose**: No advanced features (we don't need them anyway)<br><br>**Complexity Justification**:<br>```python<br># Our entire implementation concept:<br>registrations = {}  # interface -> (factory, lifetime)<br>singletons = {}     # interface -> instance<br><br># That's it! Simple dictionary operations.<br># Why add a framework for this?<br>```<br> | **DI Frameworks** (`dependency-injector`, `injector`, `pinject`): Rejected because:<br>1. External dependency (install overhead, version conflicts)<br>2. Learning curve (new API to understand)<br>3. Over-engineering (we need <100 lines of code)<br>4. Hidden complexity (decorators, metaclasses)<br>5. Harder to debug (framework internals) |

#### Decision 5: No Circular Dependency Detection

| Decision | Chosen | Why | Alternative Rejected |
|----------|--------|-----|---------------------|
| **Circular Dependencies** | **No automatic detection** | **Detailed Reasoning**: Circular dependencies are a design smell that developers should fix, not work around. Detecting them requires tracking the resolution stack and adds complexity for a rare edge case. The error message from Python's RecursionError is clear enough.<br><br>**Problem/Solution**: Detection would require:<br>```python<br># Complex tracking (adds overhead)<br>resolution_stack = []  # Track what we're resolving<br>def resolve(T):<br>    if T in resolution_stack:<br>        raise CircularDependencyError(...)<br>    resolution_stack.append(T)<br>    # ... resolve logic ...<br>    resolution_stack.pop()<br>```<br>This adds complexity to every resolution call for a problem that shouldn't exist.<br><br>**Trade-offs**:<br>- **Gain**: Simpler code, no resolution overhead<br>- **Lose**: Less helpful error for circular dependencies (rare case)<br><br>**Real Example**:<br>If `ServiceA` depends on `ServiceB` which depends on `ServiceA`, Python will raise:<br>```<br>RecursionError: maximum recursion depth exceeded<br>```<br>This is clear enoughâ€”developer fixes the design, not the container.<br> | **Automatic Detection**: Rejected because:<br>1. Adds resolution overhead (stack tracking)<br>2. Circular deps are design smells (shouldn't hide them)<br>3. Python's RecursionError is clear enough<br>4. Detection could mask deeper design problems |

---

## 4. Implementation Strategy

### Development Phases

```
Phase 1: Core Container (2 hours)
â”œâ”€ Implement Container class
â”œâ”€ Add registration methods
â””â”€ Add resolution logic
    â†“
Phase 2: Lifetime Support (1 hour)
â”œâ”€ Add Lifetime enum
â”œâ”€ Implement singleton caching
â””â”€ Implement transient creation
    â†“
Phase 3: Error Handling (1 hour)
â”œâ”€ Custom exceptions
â”œâ”€ Validation logic
â””â”€ Clear error messages
    â†“
Phase 4: Bootstrap (1 hour)
â”œâ”€ Create bootstrap module
â”œâ”€ Register core services
â””â”€ Validate registrations
    â†“
Phase 5: Testing (1 hour)
â”œâ”€ Unit tests
â”œâ”€ Integration tests
â””â”€ Performance validation
```

**Gantt Chart**:
```
Task                    â”‚ H1 â”‚ H2 â”‚ H3 â”‚ H4 â”‚ H5 â”‚ H6 â”‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
Core Container          â”‚ â–ˆâ–ˆ â”‚ â–ˆâ–ˆ â”‚    â”‚    â”‚    â”‚    â”‚
Lifetime Support        â”‚    â”‚    â”‚ â–ˆâ–ˆ â”‚    â”‚    â”‚    â”‚
Error Handling          â”‚    â”‚    â”‚    â”‚ â–ˆâ–ˆ â”‚    â”‚    â”‚
Bootstrap Module        â”‚    â”‚    â”‚    â”‚    â”‚ â–ˆâ–ˆ â”‚    â”‚
Testing & Validation    â”‚    â”‚    â”‚    â”‚    â”‚    â”‚ â–ˆâ–ˆ â”‚
```

### Integration Points

**System Architecture Connections**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  APPLICATION LAYER                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ Services   â”‚  â”‚ Handlers   â”‚  â”‚ Windows    â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚        â”‚               â”‚               â”‚                â”‚
â”‚        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                        â”‚                                â”‚
â”‚                â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚
â”‚                â”‚  DI Container  â”‚ â† YOU ARE HERE       â”‚
â”‚                â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               INFRASTRUCTURE LAYER                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚   Logger   â”‚  â”‚  Settings  â”‚  â”‚   Qt Core  â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Integration Points:
â‘  Container â†â†’ Bootstrap: Service registration at startup
â‘¡ Container â†â†’ All Services: Dependency injection via resolve()
â‘¢ Container â†â†’ Tests: Clear state between tests
```

### Risk Mitigation

| Risk | Probability | Impact | Mitigation Strategy |
|------|-------------|--------|---------------------|
| Circular dependencies cause infinite loop | Low | Medium | Document as developer responsibility; Python's RecursionError will catch it |
| Memory leaks from singleton cache | Low | Low | Document lifecycle; add clear() method for cleanup if needed |
| Type hint limitations in older Python | None | None | Require Python 3.11+ (already in requirements) |
| Performance overhead from resolution | Very Low | Low | Use simple dict lookups (O(1)); validate < 1ms in tests |
| Over-engineering temptation | Medium | Low | Keep scope minimal; resist adding features not in spec |

---

## 5. Expected Behavior & Scenarios

### User Stories (Given/When/Then)

**Story 1: Register and Resolve Singleton**
```
GIVEN: Container is initialized
WHEN: I register ILogger with SINGLETON lifetime
  AND: I resolve ILogger twice
THEN: Both resolutions return the same instance
  AND: Object identity matches (instance1 is instance2)
```

**Story 2: Register and Resolve Transient**
```
GIVEN: Container is initialized
WHEN: I register IProcessor with TRANSIENT lifetime
  AND: I resolve IProcessor twice
THEN: Each resolution returns a new instance
  AND: Object identities differ (instance1 is not instance2)
```

**Story 3: Register Pre-Created Instance**
```
GIVEN: I have a pre-configured Logger instance
WHEN: I register it with register_instance()
  AND: I resolve ILogger
THEN: I get the exact instance I registered
  AND: No factory function is called
```

**Story 4: Error on Unregistered Service**
```
GIVEN: Container is initialized
  AND: ILogger is NOT registered
WHEN: I try to resolve ILogger
THEN: ValueError is raised
  AND: Error message says "Service ILogger not registered"
```

### Edge Cases

| Case | Expected Behavior | Rationale |
|------|-------------------|-----------|
| Resolve before register | Raise ValueError("Service not registered") | Fail fast with clear error |
| Register same service twice | Raise ValueError("Already registered") | Prevent accidental overwrites |
| Register with None factory | Raise ValueError("Factory cannot be None") | Validate input |
| Factory returns None | Allow it (None is valid return) | Don't over-validate |
| Empty container | resolve() raises error, has() returns False | Container is just storage |
| clear() then resolve | Raise ValueError (registrations cleared) | Reset state completely |

### Performance Expectations

**Resolution Time Budget**:
```
Target: < 1ms per resolve() call

Breakdown:
â”œâ”€ Dict lookup (registrations): ~0.01ms
â”œâ”€ Dict lookup (singletons):    ~0.01ms
â”œâ”€ Factory call:                ~0.1ms (depends on factory)
â””â”€ Total:                       ~0.12ms âœ… Well under budget
```

**Memory Budget**:
```
Container overhead: < 1MB

Breakdown:
â”œâ”€ Registrations dict: ~10KB (50 services Ã— ~200 bytes)
â”œâ”€ Singletons cache:   ~50KB (10 singletons Ã— ~5KB avg)
â””â”€ Container object:   ~1KB
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total:                 ~61KB âœ… Well under budget
```

---

## 6. Testing Strategy

### Coverage Pyramid

```
                  â–²
                 â•± â•²
                â•±   â•²         E2E: Bootstrap integration
               â•±â”€â”€â”€â”€â”€â•²        (~5 tests)
              â•±       â•²
             â•±         â•²
            â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•²     Integration: Service wiring
           â•±             â•²    (~10 tests)
          â•±               â•²
         â•±                 â•²
        â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•²  Unit: Container logic
       â•±                     â•² (~30 tests)
      â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•²
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Target Distribution:
- Unit: 70% (container methods, lifetimes, errors)
- Integration: 20% (multi-service scenarios)
- E2E: 10% (full application bootstrap)
```

### Key Scenarios

**Unit Test Scenarios**:
- âœ… Register service with SINGLETON lifetime
- âœ… Register service with TRANSIENT lifetime
- âœ… Resolve singleton returns same instance
- âœ… Resolve transient returns new instance
- âœ… Register instance directly
- âœ… Error when resolving unregistered service
- âœ… Error when registering duplicate service
- âœ… has() returns True for registered service
- âœ… has() returns False for unregistered service
- âœ… clear() removes all registrations
- âœ… clear() empties singleton cache

**Integration Test Scenarios**:
- âœ… Bootstrap registers all core services
- âœ… Services with dependencies resolve correctly
- âœ… Service graph builds without errors
- âœ… Multiple services share singleton dependencies

**Performance Test Scenarios**:
- âœ… Resolve 1000 singletons in < 1 second
- âœ… Resolve 1000 transients in < 1 second
- âœ… Container memory overhead < 1MB

### Validation Approach

**Conceptual Validation Steps**:

1. **Functional Validation**
   - Register services with each lifetime
   - Verify instance behavior (same vs new)
   - Test error conditions
   - Validate error messages

2. **Performance Validation**
   - Time resolution calls
   - Measure memory usage
   - Compare against benchmarks

3. **Integration Validation**
   - Bootstrap real application services
   - Verify dependency graph builds
   - Check for circular dependencies

4. **Regression Validation**
   - Test clear() resets state
   - Verify no singleton leaks
   - Confirm type hints work

---

## Summary

### What We're Building

A lightweight, type-safe dependency injection container that:
- Manages service lifetimes (SINGLETON, TRANSIENT)
- Provides constructor injection for all services
- Enables easy unit testing with mock dependencies
- Uses zero external dependencies
- Completes resolutions in < 1ms

### Why It Matters

Enables testable, maintainable architecture by:
- Decoupling service implementations
- Making dependencies explicit
- Simplifying testing with mocks
- Providing clear error messages

### How It Works

1. Register services with factory functions and lifetimes
2. Resolve services by interface type
3. Container manages singleton caching automatically
4. Bootstrap module wires up all application services

### What Makes It Different

- **Explicit over magic**: No auto-wiring, no reflection
- **Minimal scope**: Only 2 lifetimes (SINGLETON, TRANSIENT)
- **Type-safe**: Uses Python type hints, not string keys
- **Zero dependencies**: Pure Python implementation
- **Simple**: ~100 lines of code, easy to understand

---

**Next Steps**: Ready for implementation! See `E01-F03.spec.md` for detailed requirements and task breakdown.

**Questions?** All requirements are clearâ€”no open questions or clarifications needed.
