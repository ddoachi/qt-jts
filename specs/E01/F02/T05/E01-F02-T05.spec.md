# Spec: E01-F02-T05 - Add Settings Validation and Error Handling

---
# ============================================================================
# SPEC METADATA
# ============================================================================

# === IDENTIFICATION ===
id: E01-F02-T05
clickup_task_id: '86ew020an'
title: Add Settings Validation and Error Handling
type: task

# === HIERARCHY ===
parent: E01-F02
children: []
epic: E01
feature: F02
task: T05
domain: application-framework

# === WORKFLOW ===
status: draft
priority: medium

# === TRACKING ===
created: '2025-12-28'
updated: '2025-12-28'
due_date: ''
estimated_hours: 4
actual_hours: 0

# === METADATA ===
tags: [validation, error-handling, settings, constraints, security]
effort: medium
risk: low
parallel: false
---

**Status**: Draft
**Type**: Task
**Parent**: E01-F02 (Settings Management)
**Created**: 2025-12-28
**Updated**: 2025-12-28
**Dependencies**: Requires T02 (SettingsService), T03 (SettingsSchema)

## Executive Summary

Implement comprehensive validation and error handling for application settings to ensure data integrity, prevent invalid configurations, and provide clear error messages to users and developers. This includes type validation, range validation, format validation (e.g., URLs, paths), custom validators, and graceful error recovery mechanisms.

## Execution Flow

```
1. Validate setting value before save (validate operation)
   → Get SettingDefinition from SettingsSchema
   → If setting not in schema: WARN "Unknown setting {key}", allow save (future-proofing)
   → Check type compatibility (str, int, bool, float, Path)
   → If type mismatch: ERROR "Invalid type for {key}: expected {type}, got {actual}"
   → Apply range validation (min/max for numbers)
   → If out of range: ERROR "Value {value} out of range [{min}, {max}] for {key}"
   → Apply format validation (URL format, path existence, etc.)
   → If format invalid: ERROR "Invalid format for {key}: {reason}"
   → Run custom validator if defined in schema
   → If custom validation fails: ERROR "Validation failed for {key}: {reason}"
   → Return: ValidationResult (success=True/False, error_message)

2. Handle validation errors (on validation failure)
   → Log validation error with key and reason
   → If called from UI: Display error message to user
   → If called from code: Raise SettingsValidationError exception
   → Do NOT save invalid value to QSettings
   → Return error to caller for handling

3. Validate all settings (validate_all operation)
   → For each setting in SettingsService:
     → Validate value against schema
     → Collect all validation errors
   → If errors found: Return list of ValidationError objects
   → If all valid: Return empty list (success)
   → Use case: Health check, testing, migration

4. Graceful error recovery (on QSettings corruption)
   → If QSettings.status() indicates error:
     → Log ERROR "Settings file corrupted: {status}"
     → Attempt to clear corrupted settings
     → Reset to defaults from SettingsSchema
     → Notify user "Settings were reset due to corruption"
   → If clear fails: Provide manual recovery instructions

5. Type coercion with validation (on get operation)
   → Retrieve value from QSettings
   → Attempt type coercion to requested type
   → If coercion fails: Log WARN "Type coercion failed for {key}"
   → Validate coerced value against schema
   → If validation fails: Return default value
   → Return: Validated and coerced value or default
```

## User Stories

### Primary User Story
**As a** developer
**I want to** validate setting values before saving
**So that** invalid configurations are rejected early and don't cause runtime errors

### Additional Stories
- **As a** user, **I want to** see clear error messages for invalid settings, **So that** I know how to fix the problem
- **As a** developer, **I want to** define custom validation rules in schema, **So that** I can enforce business logic constraints
- **As a** developer, **I want to** gracefully recover from corrupted settings, **So that** the application doesn't crash on startup

## Acceptance Scenarios

### Scenario 1: Type Validation
**Given** SettingsSchema defines "trading/default_quantity" as int
**When** attempting to save value "abc" (string, not a number)
**Then** validation should fail with error "Invalid type for trading/default_quantity: expected int, got str"
**And** the value should NOT be saved to QSettings

### Scenario 2: Range Validation
**Given** SettingsSchema defines "trading/default_quantity" with min=1, max=1000
**When** attempting to save value 0 (below minimum)
**Then** validation should fail with error "Value 0 out of range [1, 1000] for trading/default_quantity"
**And** the value should NOT be saved

### Scenario 3: Format Validation - URL
**Given** SettingsSchema defines "broker/endpoint_url" with URL format validation
**When** attempting to save value "not-a-url"
**Then** validation should fail with error "Invalid URL format for broker/endpoint_url"
**And** the value should NOT be saved

### Scenario 4: Custom Validator
**Given** SettingsSchema defines custom validator for "general/language" (must be "ko" or "en")
**When** attempting to save value "fr" (not supported)
**Then** validation should fail with error "Unsupported language: fr (supported: ko, en)"
**And** the value should NOT be saved

### Scenario 5: Graceful Recovery from Corruption
**Given** QSettings file is corrupted (invalid format)
**When** SettingsService initializes on startup
**Then** the system should log ERROR "Settings file corrupted"
**And** clear corrupted settings
**And** reset all settings to defaults from schema
**And** the application should continue running (not crash)

## Requirements

### Functional Requirements
- **FR-001**: System MUST validate setting types before saving
- **FR-002**: System MUST validate setting ranges (min/max) for numbers
- **FR-003**: System MUST validate setting formats (URLs, paths, etc.)
- **FR-004**: System MUST support custom validation functions in schema
- **FR-005**: System MUST provide clear, actionable error messages
- **FR-006**: System MUST prevent saving invalid values to QSettings
- **FR-007**: System MUST gracefully recover from QSettings corruption
- **FR-008**: System MUST reset to defaults when corruption detected
- **FR-009**: System MUST validate all settings on demand (health check)

### Non-Functional Requirements
- **NFR-001**: Usability: Error messages MUST be clear and actionable
- **NFR-002**: Reliability: Validation failures MUST NOT crash the application
- **NFR-003**: Performance: Validation MUST complete in < 5ms per setting
- **NFR-004**: Maintainability: Validation logic MUST be centralized
- **NFR-005**: Security: Validation MUST prevent injection attacks (e.g., path traversal)

### Technical Constraints
- **TC-001**: Must use SettingsSchema as source of validation rules
- **TC-002**: Must raise SettingsValidationError for validation failures
- **TC-003**: Must handle QSettings.status() errors gracefully
- **TC-004**: Must validate on set() operations before saving
- **TC-005**: Must support optional validation (backwards compatibility)

## Key Entities

### Entity: SettingsValidator
- **Description**: Centralized validation logic for settings
- **Key Methods**:
  - `validate(key: str, value: Any, schema: SettingsSchema) -> ValidationResult`
  - `validate_type(value: Any, expected_type: Type) -> bool`
  - `validate_range(value: float, min_val: float, max_val: float) -> bool`
  - `validate_url(value: str) -> bool`
  - `validate_path(value: str, must_exist: bool) -> bool`
  - `validate_all(settings: SettingsService, schema: SettingsSchema) -> List[ValidationError]`

### Entity: ValidationResult
- **Description**: Result of a validation operation
- **Key Attributes**:
  - `success` (bool): Whether validation succeeded
  - `error_message` (Optional[str]): Error message if validation failed
  - `error_code` (Optional[str]): Machine-readable error code

### Entity: SettingsValidationError
- **Description**: Exception raised when validation fails
- **Inherits**: Exception
- **Key Attributes**:
  - `key` (str): Setting key that failed validation
  - `value` (Any): Invalid value
  - `reason` (str): Reason for failure

## Dependencies

### Upstream Dependencies
- [x] E01-F02-T02 (SettingsService): Validation integrated into set() operation
- [x] E01-F02-T03 (SettingsSchema): Validation rules defined in schema

### Downstream Impact
- [ ] E01-F02-T04 (SettingsDialog): Will display validation errors in UI
- [ ] All components using SettingsService: Will benefit from validation

### External Dependencies
- `urllib.parse` (for URL validation)
- `pathlib.Path` (for path validation)
- `typing` (for type validation)

## Gate Checks

### Pre-Implementation Gates
- [ ] T02 (SettingsService) completed and tested
- [ ] T03 (SettingsSchema) completed with validation metadata
- [x] Validation requirements identified (type, range, format, custom)
- [x] Error handling strategy defined

### Quality Gates
- [ ] Unit tests for all validation types
- [ ] Unit tests for error recovery
- [ ] Edge case tests (null, empty, extreme values)
- [ ] Performance tests (< 5ms validation)
- [ ] Integration tests with SettingsService

## Success Criteria

### Acceptance Criteria
- [ ] Type validation rejects invalid types
- [ ] Range validation enforces min/max constraints
- [ ] Format validation checks URLs, paths correctly
- [ ] Custom validators execute and enforce rules
- [ ] Validation errors provide clear messages
- [ ] Invalid values are NOT saved to QSettings
- [ ] QSettings corruption detected and recovered gracefully
- [ ] Settings reset to defaults on corruption
- [ ] validate_all() checks all settings successfully
- [ ] Validation completes in < 5ms per setting
- [ ] SettingsValidationError raised on failures

### Definition of Done
- [ ] Code implemented in `src/infrastructure/services/settings_validator.py`
- [ ] Unit tests written in `tests/unit/infrastructure/test_settings_validator.py`
- [ ] Integration tests with SettingsService
- [ ] All tests passing (> 95% coverage for validator)
- [ ] Type hints and docstrings added
- [ ] Error messages documented
- [ ] Validation rules documented in SettingsSchema

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| Validation too strict | Medium | Medium | Test with realistic values, iterate based on feedback |
| Performance degradation | Low | Low | Benchmark validation, optimize hot paths |
| False positives | Low | Medium | Comprehensive testing, clear validation rules |
| Corruption recovery fails | Low | High | Test corruption scenarios, provide manual recovery docs |

## Implementation Details

### File Structure
```
src/infrastructure/services/
├── __init__.py
├── settings_service.py           # From T02
├── settings_validator.py         # SettingsValidator implementation
└── exceptions.py                 # SettingsValidationError

tests/unit/infrastructure/
├── __init__.py
└── test_settings_validator.py    # Unit tests
```

### Validation Types and Examples

#### Type Validation
```python
# Must be int, not string
validate_type(value="10", expected_type=int)  # FAIL
validate_type(value=10, expected_type=int)    # PASS
```

#### Range Validation
```python
# Must be between 1 and 1000
validate_range(value=0, min_val=1, max_val=1000)     # FAIL
validate_range(value=500, min_val=1, max_val=1000)   # PASS
```

#### Format Validation
```python
# Must be valid URL
validate_url("not-a-url")                      # FAIL
validate_url("https://api.example.com")        # PASS

# Must be valid path
validate_path("/nonexistent", must_exist=True) # FAIL
validate_path("/tmp", must_exist=True)         # PASS
```

#### Custom Validation
```python
# Custom validator in SettingsSchema
def validate_language(value: str) -> bool:
    return value in ["ko", "en"]

SettingDefinition(
    key="general/language",
    validator=validate_language
)
```

### Class Interface
```python
@dataclass
class ValidationResult:
    """Result of validation operation."""
    success: bool
    error_message: Optional[str] = None
    error_code: Optional[str] = None


class SettingsValidationError(Exception):
    """Raised when setting validation fails."""

    def __init__(self, key: str, value: Any, reason: str):
        self.key = key
        self.value = value
        self.reason = reason
        super().__init__(f"Validation failed for {key}: {reason}")


class SettingsValidator:
    """Centralized validation logic for settings."""

    @staticmethod
    def validate(key: str, value: Any, schema: SettingsSchema) -> ValidationResult:
        """Validate setting value against schema."""

    @staticmethod
    def validate_type(value: Any, expected_type: Type) -> bool:
        """Validate value type."""

    @staticmethod
    def validate_range(value: float, min_val: float, max_val: float) -> bool:
        """Validate numeric range."""

    @staticmethod
    def validate_url(value: str) -> bool:
        """Validate URL format."""

    @staticmethod
    def validate_path(value: str, must_exist: bool = False) -> bool:
        """Validate file path."""

    @staticmethod
    def validate_all(settings: SettingsService, schema: SettingsSchema) -> List[ValidationError]:
        """Validate all settings in SettingsService."""
```

### Integration with SettingsService
```python
# In SettingsService.set()
def set(self, key: str, value: Any) -> None:
    """Set setting value with validation."""
    # Validate before saving
    result = SettingsValidator.validate(key, value, SettingsSchema)
    if not result.success:
        raise SettingsValidationError(key, value, result.error_message)

    # Save to QSettings
    self._settings.setValue(key, value)
    self._settings.sync()
```

## Notes and Clarifications

### Decisions Made
- 2025-12-28: Validate on set() operation (eager validation) to catch errors early
- 2025-12-28: Raise SettingsValidationError for validation failures (explicit error handling)
- 2025-12-28: Allow unknown settings (forward compatibility) with warning
- 2025-12-28: Reset to defaults on corruption (better than crashing)
- 2025-12-28: Centralize validation in SettingsValidator (separation of concerns)

### Common Validation Rules
1. **Type validation**: All settings must match schema type
2. **Range validation**: Numeric settings must be within min/max
3. **URL validation**: Broker endpoints must be valid URLs
4. **Path validation**: File paths must be valid (and exist if required)
5. **Enum validation**: Choice settings must be in allowed values
6. **Length validation**: Strings must be within length limits

### Research Needed
None - Standard validation patterns

## Artifacts

### Input Documents
- [Parent Spec](../E01-F02.spec.md) (Feature E01-F02)
- [T02 Spec](../T02/E01-F02-T02.spec.md) (SettingsService)
- [T03 Spec](../T03/E01-F02-T03.spec.md) (SettingsSchema)

### Output Artifacts
- [ ] `src/infrastructure/services/settings_validator.py` - Implementation
- [ ] `src/infrastructure/services/exceptions.py` - Exception classes
- [ ] `tests/unit/infrastructure/test_settings_validator.py` - Unit tests
- [ ] Validation rules documentation (in SettingsSchema)

---
*Template Version: 2.0.0 - Task-level spec*
