# Spec: E01-F02 - Settings Management

---
# ============================================================================
# SPEC METADATA
# ============================================================================

# === IDENTIFICATION ===
id: E01-F02
clickup_task_id: ''    # REQUIRED - Empty string if not yet created in ClickUp
title: Settings Management
type: feature

# === HIERARCHY ===
parent: E01
children: []
epic: E01
feature: F02
domain: application-framework

# === WORKFLOW ===
status: draft
priority: high

# === TRACKING ===
created: '2025-12-28'
updated: '2025-12-28'
due_date: ''
estimated_hours: 10
actual_hours: 0

# === METADATA ===
tags: [settings, qsettings, encryption, configuration, persistence]
effort: medium
risk: medium
---

**Status**: Draft
**Type**: Feature
**Parent**: E01 (Application Framework)
**Created**: 2025-12-28
**Updated**: 2025-12-28

## Executive Summary

Implement persistent application settings management using Qt's QSettings framework, providing cross-platform storage for user preferences, broker configurations, and UI state. This feature includes type-safe settings access, cross-platform persistence (Registry on Windows, plist on macOS, config files on Linux), settings validation with defaults, encryption for sensitive data (API keys and credentials), and migration support for future versions.

## Execution Flow

```
1. Initialize SettingsService on application startup
   → Create QSettings instance with organization "JoohanTech" and app "JTS"
   → Initialize EncryptionService with machine-specific key derivation
   → If initialization fails: ERROR "Failed to initialize settings: {reason}"

2. Register SettingsService in DI Container
   → Container.register(SettingsService, factory, Lifetime.SINGLETON)
   → Ensure single instance throughout application lifecycle

3. Read setting value (get operation)
   → Check if key exists in QSettings
   → If exists: Retrieve value and apply type coercion
   → If not exists: Return provided default value
   → If type coercion fails: WARN "Type coercion failed for {key}, using default"
   → Return: SUCCESS with value (typed or default)

4. Write setting value (set operation)
   → Validate value against schema (if schema defined)
   → If validation fails: ERROR "Invalid value for {key}: {reason}"
   → Store value in QSettings
   → Call QSettings.sync() to persist immediately
   → Return: SUCCESS

5. Read encrypted setting (get_encrypted operation)
   → Retrieve encrypted value from QSettings
   → If not found: Return default value
   → Attempt decryption with EncryptionService
   → If decryption fails: WARN "Decryption failed for {key}, returning empty"
   → Return: Decrypted value or empty string

6. Write encrypted setting (set_encrypted operation)
   → Encrypt plaintext value with EncryptionService
   → Store encrypted value in QSettings
   → Sync to persistent storage
   → NEVER log the plaintext value
   → Return: SUCCESS

7. Settings persistence (automatic)
   → QSettings automatically syncs to platform-specific storage
   → Windows: HKEY_CURRENT_USER\Software\JoohanTech\JTS
   → macOS: ~/Library/Preferences/com.joohantech.jts.plist
   → Linux: ~/.config/JoohanTech/JTS/jts.conf
```

## User Stories

### Primary User Story
**As a** trader
**I want to** save my application preferences and broker credentials securely
**So that** I don't have to reconfigure the application every time I start it

### Additional Stories
- **As a** trader, **I want to** store my broker API keys securely, **So that** they cannot be easily read from my computer if someone accesses my files
- **As a** developer, **I want to** access settings with type safety, **So that** I avoid runtime type errors and get IDE autocomplete
- **As a** user, **I want to** have sensible default settings, **So that** the application works out-of-the-box without requiring extensive configuration

## Acceptance Scenarios

### Scenario 1: Happy Path - First Launch with Defaults
**Given** the application is launched for the first time (no saved settings)
**When** the application requests setting "general/language"
**Then** the SettingsService should return the default value "ko"
**And** no error should be logged

### Scenario 2: Settings Persistence Across Restarts
**Given** the user sets "general/theme" to "dark"
**When** the application is closed and restarted
**Then** the setting "general/theme" should return "dark"
**And** the value should be retrieved from platform-specific storage

### Scenario 3: Encrypted Credential Storage
**Given** the user stores broker API key "secret_key_123"
**When** the encrypted setting is saved to QSettings
**Then** inspecting the raw storage should NOT show "secret_key_123" in plain text
**And** retrieving the setting with get_encrypted should return "secret_key_123"

### Scenario 4: Edge Case - Type Coercion
**Given** a setting "trading/default_quantity" is stored as string "10"
**When** the setting is retrieved with value_type=int
**Then** the value should be returned as integer 10 (not string "10")

### Scenario 5: Error Case - Decryption Failure
**Given** encrypted setting data is corrupted or invalid
**When** attempting to decrypt the setting
**Then** the system should log a warning "Decryption failed for {key}"
**And** return empty string instead of crashing
**And** the application should continue running

## Requirements

### Functional Requirements
- **FR-001**: System MUST persist settings across application restarts
- **FR-002**: System MUST support platform-specific storage (Registry/plist/config files)
- **FR-003**: System MUST encrypt sensitive settings (API keys, passwords) before storage
- **FR-004**: Encrypted settings MUST NOT be readable in plain text from storage
- **FR-005**: System MUST provide default values for all unset settings
- **FR-006**: System MUST validate settings values when schema is defined
- **FR-007**: System MUST support type coercion (string to int, bool, float, Path)
- **FR-008**: System MUST allow clearing all settings (reset to defaults)

### Non-Functional Requirements
- **NFR-001**: Performance: Settings read/write MUST complete in < 10ms
- **NFR-002**: Performance: Encryption/decryption MUST complete in < 50ms
- **NFR-003**: Security: Encrypted values MUST use industry-standard cryptography (Fernet)
- **NFR-004**: Security: No sensitive data MUST be logged (plaintext passwords, API keys)
- **NFR-005**: Reliability: Settings file MUST be properly formatted and readable
- **NFR-006**: Maintainability: All public methods MUST have type hints and docstrings
- **NFR-007**: Compatibility: Settings MUST be UTF-8 encoded to support all characters

### Technical Constraints
- **TC-001**: Must use Qt's QSettings for cross-platform compatibility
- **TC-002**: Must use cryptography library for encryption (Fernet symmetric encryption)
- **TC-003**: Must derive encryption key from machine-specific data (no user passwords)
- **TC-004**: Must call QSettings.sync() after write operations to ensure persistence
- **TC-005**: Must handle decryption failures gracefully without crashing

## Key Entities

### Entity: SettingsService
- **Description**: Cross-platform settings management with encryption support
- **Key Attributes**: `_settings` (QSettings), `_encryption` (EncryptionService)
- **Relationships**: Uses EncryptionService for secure data, injected into all components needing settings

### Entity: EncryptionService
- **Description**: Handles encryption and decryption of sensitive settings
- **Key Attributes**: `_key` (bytes), `_cipher` (Fernet)
- **Relationships**: Used by SettingsService for secure operations

### Entity: SettingsSchema
- **Description**: Defines all application settings with defaults and validation
- **Key Attributes**: Setting definitions with keys, defaults, types, encryption flags
- **Relationships**: Referenced by SettingsService for validation

## Dependencies

### Upstream Dependencies
None (foundation component - no internal dependencies)

### Downstream Impact
- [ ] E01-F01 (MainWindow): Will use SettingsService for window geometry persistence
- [ ] All features: Will use SettingsService for feature-specific configuration

## Gate Checks

### Pre-Implementation Gates
- [x] No [NEEDS CLARIFICATION] markers remain
- [x] Performance requirements specified (< 10ms read/write, < 50ms encryption)
- [x] Security requirements defined (Fernet encryption, no logging sensitive data)
- [x] Scale requirements clear (hundreds of settings, manageable)
- [x] PRD compliance verified (Section 6.2)

### Quality Gates
- [ ] Complexity justified (optimal granularity per auto-split analysis)
- [ ] All requirements testable (unit and integration tests planned)
- [ ] Dependencies identified (none for foundation component)
- [ ] Risk assessment complete (encryption key management noted)

## Tasks Preview

### Implementation Tasks
- [ ] T01 [P] Implement EncryptionService with key derivation
- [ ] T02 [P] Implement SettingsService with QSettings
- [ ] T03 [P] Define SettingsSchema with all application settings
- [ ] T04 Create SettingsDialog UI for editing settings (depends on T02, T03)
- [ ] T05 Add settings validation and error handling (depends on T02, T03)
- [ ] T06 [P] Implement settings export/import for backup

**[P]** = Can be executed in parallel

## Success Criteria

### Acceptance Criteria
- [ ] Settings persist across application restarts
- [ ] Platform-specific storage works correctly (Registry/plist/config files)
- [ ] Encrypted settings cannot be read in plain text from storage
- [ ] Default values are returned for unset settings
- [ ] Invalid settings are rejected with clear error messages
- [ ] Settings can be reset to defaults using clear() method
- [ ] Settings read/write completes in < 10ms
- [ ] Encryption/decryption completes in < 50ms
- [ ] No sensitive data (passwords, API keys) is logged
- [ ] Settings file is properly formatted and UTF-8 encoded

### Definition of Done
- [ ] Code reviewed and approved
- [ ] Tests passing (unit, integration)
  - [ ] Unit tests for SettingsService get/set operations
  - [ ] Unit tests for EncryptionService encryption/decryption
  - [ ] Integration test for settings persistence across restarts
  - [ ] Test settings migration (future versions)
- [ ] Documentation updated (pre-docs, post-docs)
- [ ] Security reviewed (encryption implementation verified)
- [ ] Cross-platform testing complete (Windows, macOS, Linux)
- [ ] 80% test coverage achieved

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| Encryption key loss | Low | High | Document key derivation process, use machine ID (stable) |
| QSettings corruption | Low | Medium | Implement settings export/import for backup, graceful fallback to defaults |
| Platform-specific issues | Medium | Low | Test on all platforms, use Qt's abstraction layer |
| Performance degradation | Low | Low | Benchmark encryption, optimize hot paths |
| Sensitive data logging | Medium | Critical | Code review all logging, never log decrypt values |
| Settings migration failures | Medium | Medium | Version settings schema, test migration paths |

## Notes and Clarifications

### Open Questions
None - All requirements are clear

### Decisions Made
- 2025-12-28: Use QSettings over JSON files for platform-native storage mechanisms
- 2025-12-28: Use cryptography library (Fernet) for industry-standard encryption instead of custom implementation
- 2025-12-28: Derive encryption key from machine ID instead of user password for simpler key management (acceptable for local storage)
- 2025-12-28: Implement graceful decryption failure (return empty string) to prevent app crashes from corrupted settings

### Research Needed
None - QSettings and cryptography library are well-documented

## Artifacts

### Input Documents
- [Product Requirements Document](../../../docs/product-requirements-document.md) (Section 6.2)
- [Parent Spec](../E01.spec.md) (Epic E01)

### Output Artifacts (to be generated)
- [ ] `E01-F02.context.md` - Implementation context and progress
- [ ] `E01-F02.pre-docs.md` - Pre-implementation documentation ✓ (Already created)
- [ ] `E01-F02.post-docs.md` - Post-implementation learnings
- [ ] `E01-F02-implementation-narrative.md` - Comprehensive implementation story
- [ ] Unit tests: `tests/unit/infrastructure/test_settings_service.py`
- [ ] Unit tests: `tests/unit/infrastructure/test_encryption_service.py`
- [ ] Integration tests: `tests/integration/test_settings_persistence.py`

---
*Template Version: 2.0.0 - Enhanced with Speckit features*
