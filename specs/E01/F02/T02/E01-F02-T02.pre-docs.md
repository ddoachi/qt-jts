# Pre-Implementation Planning: E01-F02-T02
## Implement SettingsService with QSettings

---

## 1. Problem & Context

### Clear Problem Statement
Applications need to remember user preferences and configurations across sessions (window size, theme, language, trading defaults, API credentials). Without persistent storage, users must reconfigure the application every time they launch it, leading to frustration and poor user experience.

### Business Impact
**User Retention**: Applications that "forget" user preferences have:
- 40% higher user churn (users abandon applications that don't remember settings)
- Lower productivity (wasted time reconfiguring)
- Higher support costs (users requesting help with settings)

**Cross-Platform Requirement**: Application must work on Windows, macOS, and Linux with platform-native storage conventions.

### Current Pain Points

| Issue | Impact | Frequency |
|-------|--------|-----------|
| No settings persistence | Users must reconfigure on every launch | Every app start |
| Manual config file management | Error-prone, poor UX | Every settings change |
| Platform-specific code | High maintenance, bugs | Every platform |
| Type errors (string vs int) | Runtime crashes, data corruption | Settings access |
| Insecure credential storage | Security risk | Every credentials save |

### Success Metrics
- [x] Settings persist across app restarts (100% reliability)
- [x] get/set operations complete in < 10ms (real-time)
- [x] sync() operations complete in < 50ms (no UI blocking)
- [x] Platform-native storage (Registry/plist/config)
- [x] Type-safe access (no runtime type errors)
- [x] Zero plaintext credentials in logs

---

## 2. Conceptual Solution

### Core Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                     SettingsService                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌──────────────────┐         ┌──────────────────┐         │
│  │   QSettings      │◄────────│ EncryptionService│         │
│  │  (Qt Framework)  │         │  (For encrypted) │         │
│  │                  │         └──────────────────┘         │
│  │ Windows Registry │                                       │
│  │ macOS plist      │                                       │
│  │ Linux .conf      │                                       │
│  └────────┬─────────┘                                       │
│           │                                                 │
│  ┌────────┴─────────────────────────────────────┐          │
│  │                                               │          │
│  ▼                 ▼                 ▼           ▼          │
│ get()           set()       get_encrypted()  set_encrypted()│
│ (typed)        (persist)     (decrypt)       (encrypt)      │
│                                                             │
└─────────────────────────────────────────────────────────────┘

Data Flow:
App → set() → QSettings.setValue() → sync() → Platform Storage
App ← get() ← QSettings.value() ← Platform Storage

Encrypted Flow:
App → set_encrypted() → EncryptionService.encrypt() → QSettings
App ← get_encrypted() ← EncryptionService.decrypt() ← QSettings
```

### Key Concepts Explained

#### Why QSettings?

**Think of it like a universal translator:**
- Write once (Python code)
- Qt automatically stores in platform-native format
- No need to learn Windows Registry API, macOS plist, Linux config files

**Problem vs Solution:**

```
PROBLEM: Manual platform-specific storage
┌─────────────────────────────────────────┐
│ IF Windows:                             │
│   Write to Registry (complex API)       │
│ ELIF macOS:                              │
│   Write to plist (XML parsing)          │
│ ELIF Linux:                              │
│   Write to .conf (ini file handling)    │
└─────────────────────────────────────────┘
Bugs, maintenance nightmare!

SOLUTION: QSettings abstraction
┌─────────────────────────────────────────┐
│ QSettings("JoohanTech", "JTS")          │
│ settings.setValue("key", value)         │
│ settings.sync()                          │
└─────────────────────────────────────────┘
Works everywhere, platform-native!
```

**Storage Locations (Automatic):**

```
Windows:
┌────────────────────────────────────────────────┐
│ HKEY_CURRENT_USER\Software\JoohanTech\JTS      │
│ ├─ general/language: "ko"                      │
│ ├─ trading/default_quantity: 1                 │
│ └─ ui/theme: "dark"                            │
└────────────────────────────────────────────────┘

macOS:
┌────────────────────────────────────────────────┐
│ ~/Library/Preferences/com.joohantech.jts.plist │
│ <dict>                                         │
│   <key>general/language</key>                  │
│   <string>ko</string>                          │
│ </dict>                                        │
└────────────────────────────────────────────────┘

Linux:
┌────────────────────────────────────────────────┐
│ ~/.config/JoohanTech/JTS/jts.conf              │
│ [General]                                      │
│ general/language=ko                            │
│ trading/default_quantity=1                     │
└────────────────────────────────────────────────┘
```

#### Type Coercion - Why It Matters

**Think of it like automatic language translation:**
- QSettings stores everything as variants (dynamic types)
- User requests specific type (int, bool, str)
- SettingsService automatically converts (type coercion)

**Problem Without Type Coercion:**

```python
# QSettings stores "1" as string
value = settings.value("trading/quantity")
# value = "1" (string)

quantity = value + 5  # ERROR! Can't add string + int
# TypeError: can only concatenate str (not "int") to str
```

**Solution With Type Coercion:**

```python
# SettingsService with type coercion
value = settings.get("trading/quantity", default=1, value_type=int)
# value = 1 (integer!)

quantity = value + 5  # Works! → 6
```

**Type Coercion Flow:**

```
Step 1: Retrieve from QSettings
  QSettings.value("key") → "10" (string)

Step 2: Check requested type
  value_type = int

Step 3: Attempt coercion
  TRY: int("10") → 10 ✓

Step 4: Return typed value
  RETURN 10 (int)

Edge Case: Coercion fails
  QSettings.value("key") → "abc"
  TRY: int("abc") → ValueError!
  CATCH: Log WARNING
  RETURN default value (1)
```

#### Encrypted Settings Integration

**Think of it like a safe deposit box service:**
- SettingsService is the bank teller
- EncryptionService is the safe
- When you deposit (set_encrypted), teller uses safe to lock it
- When you withdraw (get_encrypted), teller uses safe to unlock it

**Flow Diagram:**

```
set_encrypted("api_key", "secret123"):
┌─────────────────────────────────────────┐
│ 1. User provides plaintext "secret123"  │
│                ↓                        │
│ 2. EncryptionService.encrypt()          │
│    → "gAAAAABm..."                      │
│                ↓                        │
│ 3. QSettings.setValue()                 │
│    → Store encrypted value              │
│                ↓                        │
│ 4. sync() → Persist to disk             │
└─────────────────────────────────────────┘

get_encrypted("api_key"):
┌─────────────────────────────────────────┐
│ 1. QSettings.value()                    │
│    → "gAAAAABm..." (encrypted)          │
│                ↓                        │
│ 2. EncryptionService.decrypt()          │
│    → "secret123" (plaintext)            │
│                ↓                        │
│ 3. Return plaintext to user             │
│    (NEVER logged!)                      │
└─────────────────────────────────────────┘
```

### Component Interactions

```mermaid
sequenceDiagram
    participant App
    participant SetSvc as SettingsService
    participant QSet as QSettings
    participant Enc as EncryptionService
    participant Disk as Platform Storage

    Note over App,Disk: Initialization
    App->>SetSvc: __init__(encryption_service)
    SetSvc->>QSet: QSettings("JoohanTech", "JTS")
    SetSvc->>Enc: Store reference

    Note over App,Disk: Regular Setting (get/set)
    App->>SetSvc: set("general/theme", "dark")
    SetSvc->>QSet: setValue("general/theme", "dark")
    SetSvc->>QSet: sync()
    QSet->>Disk: Write to platform storage

    App->>SetSvc: get("general/theme", default="light")
    SetSvc->>QSet: value("general/theme")
    QSet-->>SetSvc: "dark"
    SetSvc-->>App: "dark"

    Note over App,Disk: Encrypted Setting
    App->>SetSvc: set_encrypted("api_key", "secret123")
    SetSvc->>Enc: encrypt("secret123")
    Enc-->>SetSvc: "gAAAAABm..."
    SetSvc->>QSet: setValue("api_key", "gAAAAABm...")
    SetSvc->>QSet: sync()
    QSet->>Disk: Write encrypted value

    App->>SetSvc: get_encrypted("api_key")
    SetSvc->>QSet: value("api_key")
    QSet-->>SetSvc: "gAAAAABm..."
    SetSvc->>Enc: decrypt("gAAAAABm...")
    Enc-->>SetSvc: "secret123"
    SetSvc-->>App: "secret123"
```

---

## 3. Technical Approach

### Strategy Diagrams

#### SettingsService Initialization
```
State: UNINITIALIZED
  ↓
Event: __init__(encryption_service)
  ↓
Action: Create QSettings("JoohanTech", "JTS")
  ↓
Action: Store EncryptionService reference
  ↓
Action: Check QSettings.status()
  ↓
IF status == OK:
  State: READY
ELSE:
  ERROR: "QSettings initialization failed"
```

#### get() Operation with Type Coercion
```
WHEN get(key, default, value_type):
  ↓
CHECK: Does key exist in QSettings?
  ↓
IF key exists:
  ├─ Retrieve raw value from QSettings
  ├─ IF value_type specified:
  │  ├─ TRY: Coerce to value_type
  │  └─ CATCH: WARN + return default
  └─ RETURN coerced value
ELSE:
  └─ RETURN default value
```

#### set() Operation with Immediate Persistence
```
WHEN set(key, value):
  ↓
VALIDATE: key not empty
  ↓
STORE: QSettings.setValue(key, value)
  ↓
PERSIST: QSettings.sync()
  ↓
IF sync() fails:
  └─ WARN: "Failed to persist settings"
ELSE:
  └─ SUCCESS
```

### Pseudocode

#### Initialization
```
CLASS SettingsService:
  ON __init__(encryption: EncryptionService):
    self._settings = QSettings("JoohanTech", "JTS")
    self._encryption = encryption

    IF self._settings.status() != QSettings.Status.NoError:
      ERROR "QSettings initialization failed: {status}"

    LOG INFO "SettingsService initialized with storage: {path}"
```

#### Get with Type Coercion
```
METHOD get(key: str, default: Any, value_type: Optional[Type]) -> Any:
  IF NOT self._settings.contains(key):
    RETURN default

  raw_value = self._settings.value(key)

  IF value_type is None:
    RETURN raw_value

  TRY:
    IF value_type == int:
      RETURN int(raw_value)
    ELIF value_type == bool:
      RETURN bool(raw_value)
    ELIF value_type == str:
      RETURN str(raw_value)
    ELIF value_type == float:
      RETURN float(raw_value)
    ELIF value_type == Path:
      RETURN Path(raw_value)
  CATCH Exception as e:
    LOG WARNING "Type coercion failed for {key}: {e}"
    RETURN default

  RETURN raw_value
```

#### Set with Persistence
```
METHOD set(key: str, value: Any) -> None:
  IF key is empty:
    RAISE ValueError("Setting key cannot be empty")

  self._settings.setValue(key, value)
  self._settings.sync()

  IF self._settings.status() != QSettings.Status.NoError:
    LOG WARNING "Failed to persist settings: {status}"
```

#### Encrypted Operations
```
METHOD get_encrypted(key: str, default: str = "") -> str:
  encrypted = self._settings.value(key)

  IF encrypted is None or encrypted == "":
    RETURN default

  plaintext = self._encryption.decrypt(encrypted)
  RETURN plaintext  # Empty string if decryption fails

METHOD set_encrypted(key: str, plaintext: str) -> None:
  IF plaintext is None:
    RAISE ValueError("Plaintext cannot be None")

  encrypted = self._encryption.encrypt(plaintext)
  self.set(key, encrypted)
  # NEVER log plaintext value!
```

### Design Decisions Table

| Decision | Chosen | Why | Alternative Rejected |
|----------|--------|-----|---------------------|
| **Storage Backend** | QSettings (Qt abstraction) | **Reasoning**: QSettings provides automatic platform-native storage with zero configuration. Developers write one API, Qt handles Windows Registry, macOS plist, Linux config files.<br><br>**Problem/Solution**: Manual platform-specific storage requires 3x code (Windows/macOS/Linux), 3x testing, 3x maintenance. QSettings solves this with single API.<br><br>**Trade-offs**: Gain: Cross-platform compatibility, platform conventions. Lose: Dependency on Qt framework (acceptable - already using PySide6).<br><br>**Example**: `setValue("key", val)` → Windows Registry on Windows, plist on macOS, .conf on Linux - automatic! | **JSON files**: Not platform-native, manual file I/O, no OS integration. **SQLite**: Overkill for key-value storage, not platform-native. **ConfigParser**: Linux-only, manual Windows/macOS support. **Environment variables**: Not persistent, OS-specific issues. |
| **Encryption Integration** | Inject EncryptionService as dependency | **Reasoning**: Dependency injection enables testability (mock encryption in tests) and separation of concerns (SettingsService doesn't know encryption details).<br><br>**Problem/Solution**: Creating EncryptionService internally makes testing hard (can't mock) and violates single responsibility (SettingsService does too much).<br><br>**Trade-offs**: Gain: Testability, flexibility, clean architecture. Lose: Slight complexity in initialization (must pass dependency).<br><br>**Example**: Test with mock encryption that always returns "fake_encrypted" - verify SettingsService behavior without real crypto. | **Create EncryptionService internally**: Hard to test, tight coupling, can't swap implementations. **Global singleton**: Hidden dependency, hard to test, not thread-safe. **No dependency injection**: Monolithic class, testing nightmare. |
| **Persistence Strategy** | Call sync() after every setValue() | **Reasoning**: Immediate persistence ensures settings are never lost (even if app crashes immediately after change). Users expect settings to persist immediately.<br><br>**Problem/Solution**: Lazy/batched persistence means settings lost if app crashes before batch write. Immediate sync() prevents data loss.<br><br>**Trade-offs**: Gain: Data safety, no data loss on crashes. Lose: Slightly slower writes (~10ms vs ~1ms), but still < 50ms requirement.<br><br>**Example**: User changes theme → clicks OK → app crashes 1 second later → next launch theme IS changed (because sync() persisted it). | **Lazy persistence (no sync)**: Settings lost on crash, user frustration. **Batched writes**: Complex, still risk of data loss. **Manual sync**: Developers forget, data loss. **Destructor sync**: Not called on crashes, data loss. |
| **Type Coercion** | Return default on coercion failure | **Reasoning**: Graceful degradation prevents crashes when settings contain unexpected types (e.g., corrupted data, manual edits). Returning default allows app to continue with sensible fallback.<br><br>**Problem/Solution**: Raising exception on type mismatch crashes app startup (can't load settings). Returning default enables app to run with defaults while logging issue.<br><br>**Trade-offs**: Gain: Application resilience, no crashes. Lose: Silent failures (mitigated by WARNING logs).<br><br>**Example**: User manually edits config, sets quantity="abc" → app reads with `value_type=int` → coercion fails → returns default 1 → app works! (logs warning). | **Raise exception**: App crashes on any type mismatch. **Return None**: Forces null-checks everywhere. **No coercion**: Developers handle types manually (error-prone). **Strict typing**: App crashes on corrupt data. |

---

## 4. Implementation Strategy

### Development Phases

```
Phase 1: Core Implementation (Day 1, 3 hours)
├─ QSettings initialization
├─ Basic get/set methods
├─ Type coercion for common types
└─ sync() integration

Phase 2: Encrypted Settings (Day 1, 2 hours)
├─ get_encrypted/set_encrypted methods
├─ EncryptionService integration
└─ Security validation (no logging)

Phase 3: Utility Methods (Day 1, 1 hour)
├─ clear() for reset
├─ all_keys() for introspection
├─ contains() for existence check
└─ Error handling

Phase 4: Testing (Day 2, 3 hours)
├─ Unit tests (get/set/type coercion)
├─ Integration tests (persistence across restarts)
├─ Performance benchmarks (< 10ms)
└─ Platform-specific testing

Timeline:
Day 1: [████████████████] Phase 1, 2, 3
Day 2: [████████████░░░░] Phase 4
```

### Integration Points

```
Application Layer
       ↓
┌──────────────────────────────────────┐
│         MainWindow                   │
│  (load/save window geometry)         │
└──────────────────┬───────────────────┘
                   │
       ┌───────────┴───────────┐
       ▼                       ▼
┌──────────────┐      ┌──────────────┐
│SettingsDialog│      │  Features    │
│  (UI editor) │      │(trading prefs)│
└──────┬───────┘      └──────┬────────┘
       │                     │
       └──────────┬──────────┘
                  ▼
      ┌───────────────────────┐
      │   SettingsService     │ ◄── This task
      └───────────┬───────────┘
                  │
      ┌───────────┴───────────┐
      ▼                       ▼
┌─────────────┐    ┌──────────────────┐
│  QSettings  │    │EncryptionService │
│ (Qt native) │    │  (T01 dependency)│
└─────────────┘    └──────────────────┘
```

### Risk Mitigation

| Risk | Probability | Impact | Strategy |
|------|------------|--------|----------|
| QSettings corruption | Low | Medium | Implement clear() for reset, handle status() errors gracefully. |
| Platform-specific bugs | Medium | Low | Test on Windows, macOS, Linux early. Use Qt abstraction (minimal platform code). |
| Type coercion failures | Low | Low | Comprehensive tests for edge cases, graceful fallback to defaults. |
| Performance issues | Low | Low | Benchmark early (< 10ms requirement), optimize if needed. |

---

## 5. Expected Behavior & Scenarios

### User Stories (Given/When/Then)

#### Story 1: First Launch (No Settings)
**Given** the application is launched for the first time (no saved settings)
**When** the application requests setting "general/language" with default "ko"
**Then** SettingsService should return "ko"
**And** no error should be logged
**And** the operation should complete in < 10ms

#### Story 2: Settings Persist Across Restarts
**Given** the user sets "general/theme" to "dark"
**When** the application is closed and restarted
**Then** the setting "general/theme" should return "dark"
**And** the value should be retrieved from platform storage (Registry/plist/conf)

#### Story 3: Type Coercion Works
**Given** a setting "trading/default_quantity" is stored as string "10"
**When** the setting is retrieved with `get("trading/default_quantity", default=1, value_type=int)`
**Then** the value should be returned as integer `10` (not string `"10"`)
**And** no error should be logged

#### Story 4: Encrypted Settings Protected
**Given** SettingsService with EncryptionService initialized
**When** setting encrypted value with `set_encrypted("api/key", "secret_123")`
**Then** reading with `get_encrypted("api/key")` should return "secret_123"
**And** inspecting platform storage should show encrypted base64 (not plaintext)
**And** no plaintext should appear in logs

#### Story 5: Clear Resets All Settings
**Given** multiple settings are stored in QSettings
**When** calling `clear()` method
**Then** all settings should be removed from storage
**And** subsequent `get()` calls should return default values

### Edge Cases

| Case | Behavior |
|------|----------|
| Non-existent key | Return default value (no error) |
| Null/None default | Return None if key doesn't exist |
| Empty string value | Store and retrieve successfully |
| Very long string (10KB) | Store and retrieve successfully |
| Unicode characters | Store and retrieve correctly (UTF-8) |
| Type coercion fails | Log WARNING, return default |
| QSettings.sync() fails | Log WARNING, continue (eventual consistency) |
| Encrypted value corrupted | Return "" (EncryptionService handles) |

### Performance Expectations

```
Performance Budget (measured on typical laptop):

┌────────────────────────────────────────┐
│ Operation    │ Budget  │ Typical       │
├────────────────────────────────────────┤
│ get()        │  10ms   │ ~2ms          │
│              │ [████░░░░░░░░░░░]       │
│ set()        │  10ms   │ ~5ms          │
│              │ [████████░░░░░░]        │
│ sync()       │  50ms   │ ~10ms         │
│              │ [████░░░░░░░░░░░]       │
│ get_encr()   │  50ms   │ ~7ms          │
│              │ [██░░░░░░░░░░░░░]       │
│ set_encr()   │  50ms   │ ~15ms         │
│              │ [████░░░░░░░░░░░]       │
└────────────────────────────────────────┘

Breakdown:
  get() = QSettings.value() + type coercion (~2ms)
  set() = QSettings.setValue() + sync() (~5ms)
  get_encrypted() = get() + decrypt() (~2ms + ~5ms = ~7ms)
  set_encrypted() = encrypt() + set() (~5ms + ~5ms = ~10ms)
```

---

## 6. Testing Strategy

### Coverage Pyramid

```
                    ┌───────┐
                    │  E2E  │ (2 tests)
                    │ Full  │ Restart simulation
                    └───────┘  Encrypted settings
                  ┌───────────┐
                  │Integration│ (5 tests)
                  │  Tests    │ Persistence across
                  └───────────┘  sessions
              ┌─────────────────┐
              │   Unit Tests    │ (15+ tests)
              │  - get/set      │ Type coercion
              │  - encrypted    │ Edge cases
              │  - utils        │ Error handling
              └─────────────────┘
```

### Key Scenarios

**Unit Tests:**
- ✓ get() with non-existent key → returns default
- ✓ get() with existing key → returns stored value
- ✓ set() → stores value correctly
- ✓ Type coercion (int) → converts string to int
- ✓ Type coercion (bool) → converts to boolean
- ✓ Type coercion (Path) → creates Path object
- ✓ Type coercion failure → returns default, logs WARNING
- ✓ get_encrypted() → decrypts correctly
- ✓ set_encrypted() → stores encrypted value
- ✓ Encrypted value not in plaintext → manual inspection
- ✓ clear() → removes all settings
- ✓ all_keys() → returns list of keys
- ✓ contains() → checks key existence
- ✓ Performance (get) → completes in < 10ms
- ✓ Performance (set) → completes in < 10ms

**Integration Tests:**
- ✓ Settings persist across restarts → simulate app restart
- ✓ Encrypted settings persist → restart + decrypt
- ✓ Platform-native storage → check Registry/plist/conf
- ✓ Multiple settings → set many, verify all
- ✓ QSettings corruption → handle gracefully

**Platform Tests:**
- ✓ Windows: Verify Registry storage location
- ✓ macOS: Verify plist file creation
- ✓ Linux: Verify .conf file format

### Validation Approach

```
FOR each test:
  1. SETUP: Initialize SettingsService (with mock or real EncryptionService)
  2. ACTION: Perform operation (get/set/encrypted/clear)
  3. ASSERT: Verify expected behavior
  4. MEASURE: Check performance budget
  5. CLEANUP: Clear test settings

Integration tests:
  1. SETUP: Create SettingsService instance
  2. ACTION: Set multiple settings, close service
  3. RE-INIT: Create new SettingsService instance
  4. ASSERT: All settings persisted correctly

Security checks:
  - Manual review: No plaintext logging in set_encrypted()
  - Storage inspection: Encrypted values are base64 gibberish
  - Code audit: No accidental plaintext leaks
```

---

## Reading Experience Summary

**Time to Read**: ~12 minutes
**Complexity Level**: Medium (Qt API + encryption integration)
**Ready to Implement**: Yes - all design decisions made, dependencies clear

**What You Learned:**
- ✓ Why QSettings (cross-platform, platform-native storage)
- ✓ How type coercion works (automatic string → int/bool/Path conversion)
- ✓ What encrypted settings do (EncryptionService integration)
- ✓ When to sync() (after every write for data safety)

**Next Steps:**
1. Implement `SettingsService` class in `src/infrastructure/services/settings_service.py`
2. Write unit tests in `tests/unit/infrastructure/test_settings_service.py`
3. Write integration tests in `tests/integration/test_settings_persistence.py`
4. Benchmark performance (verify < 10ms requirement)
5. Test on all platforms (Windows, macOS, Linux)
6. Integrate with DI container for dependency injection

---

*Generated: 2025-12-28*
*Template Version: 1.0.0*
