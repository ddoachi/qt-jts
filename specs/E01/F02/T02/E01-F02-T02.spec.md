# Spec: E01-F02-T02 - Implement SettingsService with QSettings

---
# ============================================================================
# SPEC METADATA
# ============================================================================

# === IDENTIFICATION ===
id: E01-F02-T02
clickup_task_id: '86ew020a5'
title: Implement SettingsService with QSettings
type: task

# === HIERARCHY ===
parent: E01-F02
children: []
epic: E01
feature: F02
task: T02
domain: application-framework

# === WORKFLOW ===
status: draft
priority: high

# === TRACKING ===
created: '2025-12-28'
updated: '2025-12-28'
due_date: ''
estimated_hours: 4
actual_hours: 0

# === METADATA ===
tags: [settings, qsettings, persistence, cross-platform, type-safety]
effort: medium
risk: low
parallel: true
---

**Status**: Draft
**Type**: Task
**Parent**: E01-F02 (Settings Management)
**Created**: 2025-12-28
**Updated**: 2025-12-28
**Parallel**: [P] Can be executed in parallel with T01, T03, T06

## Executive Summary

Implement the `SettingsService` class that provides cross-platform persistent storage for application settings using Qt's QSettings framework. This service provides type-safe get/set operations, support for encrypted settings (via EncryptionService), default value handling, and automatic persistence to platform-specific storage locations (Windows Registry, macOS plist, Linux config files).

## Execution Flow

```
1. Initialize SettingsService on application startup
   → Create QSettings instance with organization "JoohanTech" and app "JTS"
   → Initialize EncryptionService for encrypted settings support
   → If QSettings initialization fails: ERROR "Failed to initialize QSettings: {reason}"
   → Return: SUCCESS with initialized service

2. Read setting value (get operation)
   → Check if key exists in QSettings using contains()
   → If exists: Retrieve value using QSettings.value()
   → If not exists: Return provided default value
   → Apply type coercion if value_type specified (str, int, bool, float, Path)
   → If type coercion fails: WARN "Type coercion failed for {key}, using default"
   → Return: Typed value or default

3. Write setting value (set operation)
   → Validate key is not empty
   → Store value in QSettings using setValue()
   → Call QSettings.sync() to persist immediately
   → If sync fails: WARN "Failed to persist settings: {reason}"
   → Return: SUCCESS

4. Read encrypted setting (get_encrypted operation)
   → Retrieve encrypted base64 string from QSettings
   → If not found: Return default value (empty string)
   → Pass encrypted value to EncryptionService.decrypt()
   → If decryption fails: Return empty string (logged by EncryptionService)
   → Return: Decrypted plaintext or empty string

5. Write encrypted setting (set_encrypted operation)
   → Validate plaintext is not None
   → Pass plaintext to EncryptionService.encrypt()
   → Store encrypted base64 string in QSettings
   → Call sync() to persist
   → NEVER log the plaintext value
   → Return: SUCCESS

6. Clear all settings (clear operation)
   → Call QSettings.clear() to remove all keys
   → Call sync() to persist
   → Return: SUCCESS (all settings reset to defaults)

7. Get all settings keys (all_keys operation)
   → Call QSettings.allKeys() to retrieve list
   → Return: List of all setting keys

8. Check if key exists (contains operation)
   → Call QSettings.contains(key)
   → Return: Boolean (True if exists, False otherwise)
```

## User Stories

### Primary User Story
**As a** developer
**I want to** persist application settings across restarts
**So that** user preferences and configurations are remembered

### Additional Stories
- **As a** developer, **I want to** type-safe setting access (int, bool, str, Path), **So that** I avoid runtime type errors and get IDE autocomplete
- **As a** developer, **I want to** use platform-specific storage automatically, **So that** settings integrate with OS conventions (Registry on Windows, etc.)
- **As a** developer, **I want to** encrypt sensitive settings transparently, **So that** credentials are protected without complex code

## Acceptance Scenarios

### Scenario 1: Happy Path - First Launch with Defaults
**Given** the application is launched for the first time (no saved settings)
**When** the application requests setting "general/language" with default "ko"
**Then** SettingsService should return "ko"
**And** no error should be logged

### Scenario 2: Settings Persistence Across Restarts
**Given** the user sets "general/theme" to "dark"
**When** the application is closed and restarted
**Then** the setting "general/theme" should return "dark"
**And** the value should be retrieved from platform-specific storage

### Scenario 3: Type Coercion
**Given** a setting "trading/default_quantity" is stored as string "10"
**When** the setting is retrieved with `value_type=int`
**Then** the value should be returned as integer `10` (not string `"10"`)

### Scenario 4: Encrypted Settings
**Given** SettingsService with EncryptionService initialized
**When** setting encrypted value with `set_encrypted("api/key", "secret_123")`
**Then** reading with `get_encrypted("api/key")` should return "secret_123"
**And** inspecting QSettings storage should NOT show "secret_123" in plain text

### Scenario 5: Clear All Settings
**Given** multiple settings are stored in QSettings
**When** calling `clear()` method
**Then** all settings should be removed from storage
**And** subsequent `get()` calls should return default values

## Requirements

### Functional Requirements
- **FR-001**: System MUST persist settings to platform-specific storage (Registry/plist/config)
- **FR-002**: System MUST support get/set operations with default values
- **FR-003**: System MUST support type coercion (str, int, bool, float, Path)
- **FR-004**: System MUST support encrypted get/set operations (using EncryptionService)
- **FR-005**: System MUST call sync() after all write operations for immediate persistence
- **FR-006**: System MUST handle missing keys gracefully (return defaults)
- **FR-007**: System MUST provide clear() method to reset all settings
- **FR-008**: System MUST provide all_keys() method to list all setting keys
- **FR-009**: System MUST provide contains() method to check key existence

### Non-Functional Requirements
- **NFR-001**: Performance: get/set operations MUST complete in < 10ms
- **NFR-002**: Performance: sync() operations MUST complete in < 50ms
- **NFR-003**: Security: MUST NOT log plaintext values from encrypted settings
- **NFR-004**: Reliability: Type coercion failures MUST NOT crash (return defaults)
- **NFR-005**: Maintainability: All methods MUST have type hints and docstrings
- **NFR-006**: Compatibility: Settings MUST be UTF-8 encoded

### Technical Constraints
- **TC-001**: Must use PySide6.QtCore.QSettings for cross-platform storage
- **TC-002**: Must configure QSettings with organization "JoohanTech" and app "JTS"
- **TC-003**: Must call QSettings.sync() after setValue() operations
- **TC-004**: Must use EncryptionService for get_encrypted/set_encrypted
- **TC-005**: Must handle QSettings status() errors gracefully

## Key Entities

### Entity: SettingsService
- **Description**: Cross-platform settings management with encryption support
- **Key Attributes**:
  - `_settings` (QSettings): Qt settings instance
  - `_encryption` (EncryptionService): Encryption service for sensitive data
- **Key Methods**:
  - `__init__(encryption: EncryptionService)`: Initialize with QSettings and encryption
  - `get(key: str, default: Any, value_type: Type) -> Any`: Get typed setting value
  - `set(key: str, value: Any) -> None`: Set setting value
  - `get_encrypted(key: str, default: str) -> str`: Get encrypted setting
  - `set_encrypted(key: str, plaintext: str) -> None`: Set encrypted setting
  - `clear() -> None`: Clear all settings
  - `all_keys() -> List[str]`: Get all setting keys
  - `contains(key: str) -> bool`: Check if key exists

## Dependencies

### Upstream Dependencies
- [ ] E01-F02-T01 (EncryptionService): Required for encrypted settings support

### Downstream Impact
- [ ] E01-F02-T04 (SettingsDialog): Will use SettingsService for UI
- [ ] E01-F02-T05 (Validation): Will use SettingsService for validation
- [ ] E01-F01 (MainWindow): Will use SettingsService for window geometry
- [ ] All features: Will use SettingsService for configuration

### External Dependencies
- `PySide6.QtCore.QSettings`
- `pathlib.Path` (for Path type coercion)
- `typing` (for type hints)

## Gate Checks

### Pre-Implementation Gates
- [x] No [NEEDS CLARIFICATION] markers remain
- [x] Performance requirements specified (< 10ms get/set, < 50ms sync)
- [x] Security requirements defined (no plaintext logging)
- [x] Platform compatibility requirements clear

### Quality Gates
- [ ] Unit tests for get/set operations
- [ ] Unit tests for type coercion
- [ ] Unit tests for encrypted settings
- [ ] Unit tests for clear/all_keys/contains
- [ ] Integration test for cross-restart persistence
- [ ] Performance tests (< 10ms requirement)

## Success Criteria

### Acceptance Criteria
- [ ] SettingsService initializes successfully with QSettings
- [ ] get/set operations work correctly with defaults
- [ ] Type coercion works for str, int, bool, float, Path
- [ ] Encrypted settings are stored and retrieved correctly
- [ ] Settings persist across application restarts
- [ ] Platform-specific storage is used (Registry/plist/config)
- [ ] clear() removes all settings
- [ ] all_keys() returns all stored keys
- [ ] contains() correctly checks key existence
- [ ] get/set completes in < 10ms
- [ ] No plaintext values from encrypted settings are logged

### Definition of Done
- [ ] Code implemented in `src/infrastructure/services/settings_service.py`
- [ ] Unit tests written in `tests/unit/infrastructure/test_settings_service.py`
- [ ] Integration test in `tests/integration/test_settings_persistence.py`
- [ ] All tests passing (> 90% coverage for this module)
- [ ] Type hints and docstrings added to all methods
- [ ] DI container registration documented
- [ ] Performance benchmarked (< 10ms verified)

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| QSettings corruption | Low | Medium | Implement clear() for reset, test on all platforms |
| Platform-specific issues | Medium | Low | Test on Windows, macOS, Linux, use Qt abstraction |
| Type coercion failures | Low | Low | Graceful fallback to defaults, log warnings |
| Performance degradation | Low | Low | Benchmark early, optimize hot paths |

## Implementation Details

### File Structure
```
src/infrastructure/services/
├── __init__.py
├── encryption_service.py         # From T01
└── settings_service.py           # SettingsService implementation

tests/unit/infrastructure/
├── __init__.py
├── test_encryption_service.py
└── test_settings_service.py      # Unit tests

tests/integration/
├── __init__.py
└── test_settings_persistence.py  # Integration tests
```

### Class Interface
```python
class SettingsService:
    """Cross-platform settings management with encryption support."""

    def __init__(self, encryption: EncryptionService) -> None:
        """Initialize with QSettings and EncryptionService."""

    def get(self, key: str, default: Any = None, value_type: Optional[Type] = None) -> Any:
        """Get setting value with optional type coercion."""

    def set(self, key: str, value: Any) -> None:
        """Set setting value and sync to storage."""

    def get_encrypted(self, key: str, default: str = "") -> str:
        """Get encrypted setting value (decrypted)."""

    def set_encrypted(self, key: str, plaintext: str) -> None:
        """Set encrypted setting value (encrypts before storing)."""

    def clear(self) -> None:
        """Clear all settings (reset to defaults)."""

    def all_keys(self) -> List[str]:
        """Get all setting keys."""

    def contains(self, key: str) -> bool:
        """Check if setting key exists."""
```

### Platform-Specific Storage Locations
```
Windows: HKEY_CURRENT_USER\Software\JoohanTech\JTS
macOS:   ~/Library/Preferences/com.joohantech.jts.plist
Linux:   ~/.config/JoohanTech/JTS/jts.conf
```

## Notes and Clarifications

### Decisions Made
- 2025-12-28: Use QSettings over JSON files for platform-native storage
- 2025-12-28: Inject EncryptionService as dependency for testability
- 2025-12-28: Call sync() after every write for immediate persistence
- 2025-12-28: Return defaults on type coercion failures (graceful degradation)
- 2025-12-28: Use organization "JoohanTech" and app "JTS" for QSettings

### Research Needed
None - QSettings API is well-documented

## Artifacts

### Input Documents
- [Parent Spec](../E01-F02.spec.md) (Feature E01-F02)
- [Qt QSettings Documentation](https://doc.qt.io/qtforpython/PySide6/QtCore/QSettings.html)

### Output Artifacts
- [ ] `src/infrastructure/services/settings_service.py` - Implementation
- [ ] `tests/unit/infrastructure/test_settings_service.py` - Unit tests
- [ ] `tests/integration/test_settings_persistence.py` - Integration tests

---
*Template Version: 2.0.0 - Task-level spec*
