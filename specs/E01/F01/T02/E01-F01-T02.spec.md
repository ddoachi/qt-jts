# Spec: E01-F01-T02 - Implement NavigationBar widget with buttons

---
# ============================================================================
# SPEC METADATA
# ============================================================================

# === IDENTIFICATION ===
id: E01-F01-T02
clickup_task_id: '86ew0209g'
title: Implement NavigationBar widget with buttons
type: task

# === HIERARCHY ===
parent: E01-F01
children: []
epic: E01
feature: F01
task: T02
domain: application-framework

# === WORKFLOW ===
status: draft
priority: high

# === TRACKING ===
created: '2025-12-28'
updated: '2025-12-28'
due_date: ''
estimated_hours: 4
actual_hours: 0

# === METADATA ===
tags: [ui, pyside6, navigation, sidebar, signals, parallel]
effort: medium
risk: low
parallel: true
---

**Status**: Draft
**Type**: Task
**Parent**: E01-F01 (Main Window & Navigation)
**Created**: 2025-12-28
**Updated**: 2025-12-28
**Parallel**: [P] Can be executed in parallel with T01, T04, T06

## Executive Summary

Implement a `NavigationBar` widget as a vertical sidebar containing navigation buttons for all major application views. The widget will use Qt Signal/Slot mechanism to emit navigation events, support visual highlighting of the active view, and provide a clean, professional navigation interface with icons and labels.

## Execution Flow

```
1. Create NavigationBar class inheriting from QWidget
   → Import PySide6.QtWidgets (QWidget, QVBoxLayout, QPushButton)
   → Import PySide6.QtCore.Signal for signal definition
   → Define navigation_requested = Signal(str) for view navigation

2. Initialize NavigationBar structure
   → Create QVBoxLayout with vertical orientation
   → Initialize button registry: self._buttons: Dict[str, QPushButton] = {}
   → Initialize active view tracker: self._active_view: str = ""
   → Set fixed width for sidebar (200px)

3. Define navigation button configuration
   → Create button_config list with view definitions:
     - view_id: str (e.g., "dashboard", "scanner")
     - label: str (e.g., "Dashboard", "Scanner")
     - icon: str (optional, icon path or name)
   → Initial views: Dashboard, Data Collection, Scanner, Backtesting, Settings

4. Create navigation buttons
   → For each view in button_config:
     → Create QPushButton with label
     → Set button properties (checkable=True, fixed height)
     → Apply custom stylesheet for navigation button styling
     → Connect clicked signal to _on_button_clicked(view_id)
     → Store button in self._buttons[view_id]
     → Add button to layout

5. Add spacer and styling
   → Add QSpacerItem at bottom to push buttons to top
   → Apply NavigationBar stylesheet (background, borders)
   → Set object names for CSS-like styling

6. Implement button click handler
   → _on_button_clicked(view_id: str) method:
     → If view_id == self._active_view: Return (already active)
     → Update visual state: _update_active_button(view_id)
     → Emit navigation_requested signal with view_id
     → Log navigation event

7. Implement active button highlighting
   → _update_active_button(view_id: str) method:
     → Uncheck previous active button if exists
     → Set self._buttons[view_id].setChecked(True)
     → Update self._active_view = view_id
     → Apply "active" stylesheet to checked button
```

## User Stories

### Primary User Story
**As a** trader
**I want to** see a clear navigation sidebar with labeled buttons
**So that** I can easily switch between different application features

### Additional Stories
- **As a** trader, **I want to** see which view is currently active with visual highlighting, **So that** I always know my current location in the app
- **As a** developer, **I want to** NavigationBar to emit signals for navigation, **So that** MainWindow can respond without tight coupling

## Acceptance Scenarios

### Scenario 1: Happy Path - NavigationBar Display
**Given** NavigationBar is instantiated
**When** the widget is displayed
**Then** all navigation buttons should be visible
**And** buttons should be arranged vertically
**And** the sidebar width should be 200px
**And** no button should be highlighted initially

### Scenario 2: Button Click Emits Signal
**Given** NavigationBar is displayed
**When** the user clicks the "Scanner" button
**Then** the navigation_requested signal should be emitted with "scanner"
**And** the Scanner button should be highlighted
**And** any previously highlighted button should be unhighlighted

### Scenario 3: Active Button Highlighting
**Given** NavigationBar has "Dashboard" as active view
**When** set_active_view("scanner") is called
**Then** the Dashboard button should be unhighlighted
**And** the Scanner button should be highlighted
**And** self._active_view should be "scanner"

### Scenario 4: Clicking Already Active Button
**Given** NavigationBar has "Dashboard" as active view
**When** the user clicks the "Dashboard" button again
**Then** the navigation_requested signal should NOT be emitted
**And** the Dashboard button should remain highlighted

## Requirements

### Functional Requirements
- **FR-001**: NavigationBar MUST display vertical list of navigation buttons
- **FR-002**: NavigationBar MUST emit navigation_requested(str) signal when button clicked
- **FR-003**: NavigationBar MUST visually highlight the currently active view button
- **FR-004**: NavigationBar MUST support at least 5 navigation views initially
- **FR-005**: NavigationBar MUST prevent re-navigation to already active view
- **FR-006**: NavigationBar MUST provide set_active_view() method for external control

### Non-Functional Requirements
- **NFR-001**: Button click response MUST be instant (< 50ms visual feedback)
- **NFR-002**: NavigationBar styling MUST be consistent across platforms
- **NFR-003**: All public methods MUST have type hints and docstrings

### Technical Constraints
- **TC-001**: Must use PySide6.QtWidgets.QWidget as base class
- **TC-002**: Must use Qt Signal/Slot mechanism for navigation events
- **TC-003**: Must use QPushButton with checkable=True for active state
- **TC-004**: Must use QVBoxLayout for vertical button arrangement

## Key Entities

### Entity: NavigationBar
- **Description**: Vertical sidebar widget with navigation buttons
- **Key Attributes**:
  - `_buttons: Dict[str, QPushButton]` - Registry of navigation buttons
  - `_active_view: str` - Currently active view identifier
  - `navigation_requested: Signal(str)` - Signal emitted on navigation
- **Key Methods**:
  - `__init__()` - Constructor
  - `set_active_view(view_id: str) -> None` - Set active view programmatically
  - `_on_button_clicked(view_id: str) -> None` - Handle button clicks
  - `_update_active_button(view_id: str) -> None` - Update visual highlighting

### Entity: NavigationButton Configuration
- **Description**: Configuration for each navigation button
- **Attributes**: view_id, label, icon (optional)

## Dependencies

### Upstream Dependencies
None - This task can be executed in parallel

### Downstream Impact
- [ ] T03: Will integrate NavigationBar into MainWindow and connect signals

## Implementation Details

### File Structure
```
src/presentation/navigation_bar.py
tests/unit/presentation/test_navigation_bar.py
```

### Code Skeleton
```python
from PySide6.QtWidgets import QWidget, QVBoxLayout, QPushButton, QSpacerItem, QSizePolicy
from PySide6.QtCore import Signal
from typing import Dict, List, NamedTuple

class ButtonConfig(NamedTuple):
    """Configuration for navigation button."""
    view_id: str
    label: str
    icon: str = ""

class NavigationBar(QWidget):
    """Vertical navigation sidebar with view buttons."""

    navigation_requested = Signal(str)  # Emits view_id

    def __init__(self):
        """Initialize navigation bar."""
        super().__init__()
        self._buttons: Dict[str, QPushButton] = {}
        self._active_view: str = ""

        self._setup_ui()

    def _setup_ui(self) -> None:
        """Setup the user interface."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(2)

        # Define navigation buttons
        button_configs: List[ButtonConfig] = [
            ButtonConfig("dashboard", "Dashboard"),
            ButtonConfig("data_collection", "Data Collection"),
            ButtonConfig("scanner", "Scanner"),
            ButtonConfig("backtesting", "Backtesting"),
            ButtonConfig("settings", "Settings"),
        ]

        # Create buttons
        for config in button_configs:
            btn = self._create_button(config)
            self._buttons[config.view_id] = btn
            layout.addWidget(btn)

        # Add spacer to push buttons to top
        spacer = QSpacerItem(20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding)
        layout.addItem(spacer)

        # Set fixed width
        self.setFixedWidth(200)

        # Apply styling
        self.setStyleSheet("""
            NavigationBar {
                background-color: #2c3e50;
                border-right: 1px solid #34495e;
            }
        """)

    def _create_button(self, config: ButtonConfig) -> QPushButton:
        """Create a navigation button.

        Args:
            config: Button configuration

        Returns:
            Configured QPushButton
        """
        btn = QPushButton(config.label)
        btn.setCheckable(True)
        btn.setFixedHeight(50)
        btn.clicked.connect(lambda: self._on_button_clicked(config.view_id))

        # Apply button styling
        btn.setStyleSheet("""
            QPushButton {
                text-align: left;
                padding-left: 15px;
                border: none;
                color: #ecf0f1;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #34495e;
            }
            QPushButton:checked {
                background-color: #3498db;
                font-weight: bold;
            }
        """)

        return btn

    def _on_button_clicked(self, view_id: str) -> None:
        """Handle navigation button click.

        Args:
            view_id: ID of clicked view
        """
        if view_id == self._active_view:
            return  # Already active, ignore

        self._update_active_button(view_id)
        self.navigation_requested.emit(view_id)

    def _update_active_button(self, view_id: str) -> None:
        """Update active button highlighting.

        Args:
            view_id: ID of view to highlight
        """
        # Uncheck previous active button
        if self._active_view and self._active_view in self._buttons:
            self._buttons[self._active_view].setChecked(False)

        # Check new active button
        if view_id in self._buttons:
            self._buttons[view_id].setChecked(True)
            self._active_view = view_id

    def set_active_view(self, view_id: str) -> None:
        """Set active view programmatically.

        Args:
            view_id: ID of view to set as active
        """
        if view_id in self._buttons:
            self._update_active_button(view_id)
```

### Button Configuration
- **Dashboard**: Main overview view
- **Data Collection**: Real-time data monitoring
- **Scanner**: Market scanner for opportunities
- **Backtesting**: Strategy backtesting interface
- **Settings**: Application configuration

## Success Criteria

### Acceptance Criteria
- [ ] NavigationBar widget created with vertical layout
- [ ] All 5 navigation buttons displayed correctly
- [ ] Buttons have consistent styling and sizing
- [ ] Clicking button emits navigation_requested signal
- [ ] Active button is visually highlighted
- [ ] Only one button can be highlighted at a time
- [ ] Clicking active button does not emit signal
- [ ] set_active_view() correctly updates highlighting
- [ ] Sidebar has fixed width of 200px

### Definition of Done
- [ ] Code reviewed and approved
- [ ] Unit tests passing with 80%+ coverage
  - [ ] Test NavigationBar initialization
  - [ ] Test button click emits signal
  - [ ] Test active button highlighting
  - [ ] Test set_active_view() method
  - [ ] Test clicking already active button
- [ ] Code follows PEP 8 style guidelines
- [ ] Docstrings complete for all public methods
- [ ] Visual styling verified on target platforms

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| Button styling inconsistent across platforms | Medium | Low | Test on Linux, macOS, Windows; use platform-agnostic Qt stylesheets |
| Signal/slot connection issues | Low | Medium | Add logging for signal emissions, unit test signal connections |
| Active state not persisting visually | Low | Low | Use checkable buttons, test state management thoroughly |

## Notes and Clarifications

### Design Decisions
- 2025-12-28: Use QPushButton with checkable=True instead of custom toggle widget for simplicity
- 2025-12-28: Fixed width of 200px provides good balance between space and usability
- 2025-12-28: Prevent re-navigation to active view to avoid unnecessary view reloading

### Implementation Notes
- Icons can be added later without changing the core structure
- Stylesheet can be externalized to theme configuration file in future
- Button configuration can be moved to external config for easier customization

---
*Template Version: 2.0.0 - Task Level Spec*
