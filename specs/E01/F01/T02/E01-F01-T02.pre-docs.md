# Pre-Implementation Planning: NavigationBar Widget

**Task ID**: E01-F01-T02
**Title**: Implement NavigationBar widget with buttons
**Estimated Effort**: 4 hours
**Reading Time**: 12-15 minutes

---

## 1. Problem & Context

### Clear Problem Statement
Traders need a simple, visual way to navigate between different application features (Dashboard, Scanner, Data Collection, etc.). Without a navigation interface, users cannot access the application's functionality or understand where they are in the system.

### Business Impact
- **User Experience**: Clear navigation reduces confusion and learning curve
- **Efficiency**: Single-click access to any feature improves workflow
- **Visual Feedback**: Active view highlighting prevents user disorientation

### Current Pain Points

| Issue | Impact | Frequency |
|-------|--------|-----------|
| No navigation UI exists | Cannot switch between features | Blocking |
| No visual indication of current location | Users get lost in the application | High |
| No organized feature access | Features scattered, hard to find | High |

### Success Metrics
- [x] All navigation buttons visible and clickable
- [x] Active button visually distinct from inactive buttons
- [x] Button click emits signal with correct view_id
- [x] Visual feedback appears within 50ms of click
- [x] Sidebar width is consistent (200px fixed)

---

## 2. Conceptual Solution

### Core Architecture

Think of NavigationBar as a **TV remote control**:
- Each button represents a channel (view)
- Clicking a button changes the channel
- The active button lights up to show current channel
- The remote doesn't change the TV directly—it sends a signal

```
┌──────────────────┐
│  NavigationBar   │
│  ┌────────────┐  │ ─── Click ──→ Signal: "scanner"
│  │ Dashboard  │  │
│  ├────────────┤  │
│  │ Scanner ●  │  │ ← Active (highlighted)
│  ├────────────┤  │
│  │ Settings   │  │
│  └────────────┘  │
│       ↓ Spacer   │
└──────────────────┘
   200px wide
```

### Key Concepts Explained

#### Signal/Slot Pattern: The Remote Control

**Real-World Analogy**: When you press a button on your TV remote, it doesn't physically move the TV's dial. Instead:
1. Remote emits infrared signal
2. TV receives signal
3. TV changes channel

Similarly, NavigationBar doesn't change views directly:
1. Button clicked → Signal emitted
2. MainWindow receives signal
3. MainWindow changes view

**Why Use This?**

| Benefit | Description | Example |
|---------|-------------|---------|
| **Decoupling** | NavigationBar doesn't need to know about MainWindow internals | Can test NavigationBar without MainWindow |
| **Reusability** | Same NavigationBar could work with different view containers | Could swap QStackedWidget for tabs later |
| **Clarity** | Signal name clearly describes what happened | `navigation_requested("scanner")` is self-documenting |
| **Flexibility** | Multiple listeners can react to same signal | Could log navigation + switch view |

**Visual Example**:
```
BAD (Tight Coupling):
NavigationBar ──calls──> MainWindow.navigate_to("scanner")
  (NavigationBar must know MainWindow interface)

GOOD (Signal/Slot):
NavigationBar ──emits──> navigation_requested("scanner")
                                    ↓
                         MainWindow receives signal
                         MainWindow decides what to do
```

#### Checkable Buttons: The Radio Button Group

**Real-World Analogy**: Think of old car radios with physical buttons:
- Press one button, it stays down (checked)
- Press another button, first pops up, new one stays down
- Only one button can be down at a time

**States in Our System**:
```
Button States:
┌──────────────┐
│  Unchecked   │  Background: Normal color
│              │  Text: Normal weight
└──────────────┘

┌──────────────┐
│ Checked ✓    │  Background: Highlight color (blue)
│              │  Text: Bold weight
└──────────────┘
```

**State Transitions**:
```
User clicks "Scanner":
  1. Dashboard button: checked → unchecked
  2. Scanner button:    unchecked → checked
  3. All others:        stay unchecked
```

#### Active Button Management: The Spotlight

We track which button is "active" using `_active_view` string:
- Only ONE view can be active at a time
- When switching, we must:
  1. Turn OFF old button's highlight
  2. Turn ON new button's highlight
  3. Update `_active_view` to new view

**Problem**: What if we don't track active view?
- User clicks Scanner twice
- Both times emit signal and switch view
- Waste of processing, causes flickering

**Solution**: Track active view, ignore repeat clicks:
```
IF clicked_view == _active_view:
  RETURN  # Already there, do nothing
ELSE:
  Update highlighting
  Emit signal
```

### Component Interaction Flow

```
Initialization:
Application
    ↓
Creates NavigationBar
    ↓
NavigationBar creates buttons
    ↓
Connects each button to _on_button_clicked
    ↓
Ready for user interaction

User Interaction:
User clicks "Scanner"
    ↓
Button emits clicked signal
    ↓
_on_button_clicked("scanner") called
    ↓
Check if already active? No
    ↓
_update_active_button("scanner")
    ├─ Uncheck "Dashboard" button
    └─ Check "Scanner" button
    ↓
Emit navigation_requested("scanner")
    ↓
MainWindow receives signal
    ↓
MainWindow switches view
```

---

## 3. Technical Approach

### Strategy Overview

**Problem**: Need a vertical sidebar with navigation buttons that emit signals and show active state.

**Solution**: Custom QWidget with:
- QVBoxLayout for vertical stacking
- Checkable QPushButtons for each view
- Qt Signal for navigation events
- Dictionary for O(1) button lookup

### Design Decisions

| Decision | Chosen Approach | Why? | Alternatives Rejected |
|----------|----------------|------|----------------------|
| **Widget Base** | QWidget | **Reasoning**: Maximum flexibility for custom layout and styling. No unnecessary features from heavier widgets. Clean slate for our specific navigation needs. <br><br>**Problem/Solution**: We need a simple container that can hold buttons vertically with custom styling. QWidget provides exactly this—a blank canvas. <br><br>**Trade-offs**: Must implement all behavior ourselves vs inheriting ready-made behavior. But gain complete control over appearance and functionality. <br><br>**Example**: Can set exact width (200px), custom background color, any button arrangement we want. | **QToolBar**: Horizontal by default, designed for tool buttons not navigation. Harder to style as sidebar. <br><br>**QListWidget**: Overkill, brings list selection behavior we don't need. More complex API than needed. |
| **Button Type** | QPushButton (checkable) | **Reasoning**: Checkable property gives us toggle behavior for free. Native Qt button with full styling support. Well-tested, reliable widget. <br><br>**Problem/Solution**: Need buttons that can show "pressed down" state for active view. Checkable QPushButton provides this via `setCheckable(True)` and `setChecked(True/False)`. <br><br>**Trade-offs**: Slightly more complex than basic button, but we need the checked state. More features than needed (we don't use auto-repeat, key shortcuts), but negligible overhead. <br><br>**Example**: `btn.setCheckable(True)` + stylesheet with `QPushButton:checked` selector = automatic visual feedback. | **QRadioButton**: Designed for radio groups, brings group behavior we'd need to fight against. Wrong semantic meaning. <br><br>**Custom QWidget**: Would need to implement all button behavior (hover, press, release, keyboard). Months of work for marginal benefit. |
| **Layout** | QVBoxLayout | **Reasoning**: Purpose-built for vertical stacking. Handles spacing, margins, alignment automatically. Can add spacer to push buttons to top. <br><br>**Problem/Solution**: Need buttons stacked vertically, evenly spaced. QVBoxLayout's `addWidget()` does exactly this with consistent spacing. <br><br>**Trade-offs**: Layout adds minor memory overhead vs manual positioning. But automatic resizing, spacing, and alignment save debugging time. <br><br>**Example**: `layout.addWidget(btn)` × 5 buttons + `layout.addItem(spacer)` = perfect vertical stack with top alignment. | **Manual positioning**: Would need to calculate Y positions for every button. Breaks on resize, different DPI settings. Unmaintainable. <br><br>**QGridLayout**: Overkill for single column. More complex API for no benefit in our use case. |
| **Signal Design** | Signal(str) with view_id | **Reasoning**: Single signal with payload is cleaner than multiple signals. view_id string is flexible, readable. Decouples NavigationBar from view details. <br><br>**Problem/Solution**: Need to tell MainWindow which view was requested. Emitting view_id string is simple, type-safe (with type hints), and self-documenting. <br><br>**Trade-offs**: Runtime string validation needed vs compile-time enum safety. But strings are more flexible (can add views dynamically without changing NavigationBar). <br><br>**Example**: `navigation_requested.emit("scanner")` is clear. Receiver can validate view_id against registry. | **Multiple signals** (dashboard_clicked, scanner_clicked): Explosion of signals, need to connect each individually. Adding new view requires code changes. <br><br>**Signal(int) index**: Magic numbers, not self-documenting. Brittle when view order changes. |
| **Button Lookup** | Dict[str, QPushButton] | **Reasoning**: O(1) lookup by view_id. Matches view registry pattern in MainWindow. Easy to validate view_id before access. <br><br>**Problem/Solution**: When setting active view, need fast button lookup. Dict provides instant access: `self._buttons[view_id].setChecked(True)`. <br><br>**Trade-offs**: Small memory overhead for hash table vs list. But enables clear code and prevents off-by-one errors from indexed access. <br><br>**Example**: `self._buttons["scanner"]` is readable vs `self._buttons[2]` which requires documentation. | **List**: Would need to search by view_id or store parallel lists (indices + view_ids). O(n) search time, error-prone index management. <br><br>**No storage**: Could search widget tree every time. O(n) search through children, very slow. |

### Pseudocode

```
WHEN NavigationBar is created:
  CREATE QVBoxLayout with vertical orientation
  SET layout margins to 0 and spacing to 2px

  DEFINE button configurations:
    - ("dashboard", "Dashboard")
    - ("data_collection", "Data Collection")
    - ("scanner", "Scanner")
    - ("backtesting", "Backtesting")
    - ("settings", "Settings")

  FOR EACH configuration:
    CREATE QPushButton with label
    SET checkable to True
    SET fixed height to 50px
    APPLY navigation button stylesheet
    CONNECT clicked signal to _on_button_clicked(view_id)
    STORE button in _buttons dict
    ADD button to layout

  ADD spacer item to push buttons to top
  SET fixed width to 200px
  APPLY NavigationBar background stylesheet


WHEN _on_button_clicked(view_id) is called:
  IF view_id equals _active_view:
    RETURN  # Already active, ignore

  CALL _update_active_button(view_id)
  EMIT navigation_requested signal with view_id


WHEN _update_active_button(view_id) is called:
  IF _active_view is not empty:
    GET previous button from _buttons dict
    SET checked to False

  GET new button from _buttons dict
  SET checked to True
  UPDATE _active_view to view_id


WHEN set_active_view(view_id) is called:
  IF view_id exists in _buttons:
    CALL _update_active_button(view_id)
```

---

## 4. Implementation Strategy

### Development Phases

```
Phase 1: Basic Structure (60 min)
├─ Create navigation_bar.py file
├─ Define NavigationBar class
├─ Setup __init__ and _setup_ui
├─ Create QVBoxLayout
└─ Apply basic styling

Phase 2: Button Creation (60 min)
├─ Define ButtonConfig data structure
├─ Create button configurations
├─ Implement _create_button method
├─ Apply button styling
└─ Test button appearance

Phase 3: Signal/Slot Logic (60 min)
├─ Define navigation_requested signal
├─ Implement _on_button_clicked
├─ Implement _update_active_button
├─ Connect all signals
└─ Test signal emission

Phase 4: Public API (30 min)
├─ Implement set_active_view method
├─ Add validation and error handling
├─ Write docstrings
└─ Code cleanup

Phase 5: Testing (30 min)
├─ Write unit tests
├─ Test signal emission
├─ Test active state management
└─ Manual visual testing
```

### Integration Points

```
NavigationBar Integration:

         NavigationBar
              │
              │ navigation_requested(str) signal
              ↓
         MainWindow
              │
              ↓
         _on_navigation_requested(view_id)
              │
              ↓
         QStackedWidget.setCurrentWidget()
```

**External Dependencies**:
- `PySide6.QtWidgets.QWidget`: Base class
- `PySide6.QtWidgets.QPushButton`: Button widgets
- `PySide6.QtWidgets.QVBoxLayout`: Vertical layout
- `PySide6.QtCore.Signal`: Signal definition

**No Upstream Dependencies**: Can be developed in parallel with MainWindow!

### Risk Mitigation

| Risk | Probability | Impact | Mitigation Strategy |
|------|------------|--------|-------------------|
| Button styling inconsistent across platforms | Medium | Low | Test on Linux, macOS, Windows. Use platform-agnostic Qt stylesheets. Document platform-specific quirks. Use QSS selectors like `QPushButton:checked` that Qt handles correctly everywhere. |
| Signal not emitted on button click | Low | High | Add logging in _on_button_clicked to verify calls. Test signal connections with QSignalSpy in unit tests. Verify lambda captures view_id correctly. Add debug output for troubleshooting. |
| Active button state desynchronized | Low | Medium | Single source of truth in `_active_view` string. Validate state before every update. Log all state changes. Unit test all state transitions thoroughly. |
| Clicking already active button causes flicker | Low | Low | Check `if view_id == _active_view: return` before emitting signal. Prevents unnecessary view reloading in MainWindow. |

---

## 5. Expected Behavior & Scenarios

### User Stories

**Story 1: Initial Display**
```
GIVEN: NavigationBar is created and displayed
WHEN:  Widget is first shown
THEN:  - All 5 buttons are visible
       - Buttons are vertically stacked
       - Sidebar width is 200px
       - No button is highlighted (no active view yet)
       - Background is dark blue-gray (#2c3e50)
```

**Story 2: First Navigation**
```
GIVEN: NavigationBar is displayed with no active view
WHEN:  User clicks "Scanner" button
THEN:  - Scanner button becomes highlighted (blue background, bold text)
       - navigation_requested signal emitted with "scanner"
       - _active_view updated to "scanner"
       - No other buttons are highlighted
```

**Story 3: Switching Views**
```
GIVEN: "Dashboard" button is currently active
WHEN:  User clicks "Scanner" button
THEN:  - Dashboard button unhighlights (back to normal)
       - Scanner button highlights (blue background, bold)
       - navigation_requested("scanner") signal emitted
       - Visual transition is smooth (< 50ms)
```

**Story 4: Clicking Active Button**
```
GIVEN: "Scanner" button is currently active
WHEN:  User clicks "Scanner" button again
THEN:  - Scanner button remains highlighted
       - NO signal is emitted
       - _active_view stays "scanner"
       - No unnecessary processing occurs
```

### Edge Cases

| Case | Expected Behavior |
|------|------------------|
| set_active_view with invalid view_id | Button not in registry, no change, no error (silent fail) |
| Rapid clicking (2+ buttons in 100ms) | All clicks processed, last click wins, all signals emitted |
| External set_active_view("dashboard") | Dashboard highlights, no signal emitted (external control) |
| Double-click same button | First click processed, second ignored (already active) |
| Button created but not added to layout | Button exists in dict, but invisible (layout issue) |

### Performance Expectations

**Time Budget**:
```
NavigationBar Initialization:
├─ Widget creation:        < 10ms
├─ Button creation (×5):   < 25ms
├─ Layout setup:           < 10ms
├─ Styling application:    < 20ms
└─ Total:                  < 70ms ✓

Button Click Response:
├─ Click detection:        < 5ms
├─ State check:            < 1ms
├─ Visual update:          < 30ms
├─ Signal emission:        < 5ms
└─ Total:                  < 50ms ✓ (meets NFR-001)
```

---

## 6. Testing Strategy

### Coverage Pyramid

```
      /\
     /E2E\        1 test: Click button in running app
    /------\
   /  INT  \      2 tests: Signal connection, state sync
  /----------\
 /   UNIT    \   10 tests: All methods, edge cases
/──────────────\
```

### Key Scenarios

**Unit Tests** (10 scenarios):
- ✓ Test NavigationBar initialization creates all buttons
- ✓ Test buttons are checkable
- ✓ Test sidebar has fixed width of 200px
- ✓ Test _on_button_clicked updates active state
- ✓ Test _on_button_clicked emits navigation_requested signal
- ✓ Test clicking already active button does NOT emit signal
- ✓ Test _update_active_button unchecks previous button
- ✓ Test _update_active_button checks new button
- ✓ Test set_active_view updates highlighting
- ✓ Test set_active_view with invalid view_id

**Integration Tests** (2 scenarios):
- ✓ Test signal connection to MainWindow
- ✓ Test button click → signal → view switch flow

**Manual Verification**:
- [ ] Hover effect appears on mouse-over
- [ ] Active button visually distinct on all platforms
- [ ] Button text is readable with good contrast
- [ ] Sidebar doesn't resize when buttons clicked

### Validation Approach

**Testing Pattern**: Given-When-Then with QSignalSpy

```python
def test_button_click_emits_signal():
    # GIVEN
    nav_bar = NavigationBar()
    spy = QSignalSpy(nav_bar.navigation_requested)

    # WHEN
    nav_bar._on_button_clicked("scanner")

    # THEN
    assert len(spy) == 1
    assert spy[0] == ["scanner"]
```

**Mock Strategy**: NavigationBar has no dependencies, doesn't need mocking!

---

## Visual Reference

### Widget Hierarchy

```
NavigationBar (QWidget)
│
├─── QVBoxLayout
│    │
│    ├─── QPushButton ("Dashboard")    ──┐
│    ├─── QPushButton ("Data Collection") │
│    ├─── QPushButton ("Scanner")         │ 50px height each
│    ├─── QPushButton ("Backtesting")     │
│    ├─── QPushButton ("Settings")       ─┘
│    │
│    └─── QSpacerItem (vertical stretch)
│
└─── Fixed width: 200px
```

### State Machine

```
Button State Machine:

     [Unchecked] ◄───────────────────┐
         │                           │
         │ User clicks this button   │ User clicks
         │ (not currently active)    │ different button
         ↓                           │
     [Checked] ──────────────────────┘
         │
         │ User clicks this button again
         │ (already active)
         ↓
     [Checked] (no change)
```

### Color Scheme

| State | Background | Text | Border |
|-------|-----------|------|--------|
| Normal | Transparent | #ecf0f1 (light) | None |
| Hover | #34495e (dark gray) | #ecf0f1 | None |
| Checked | #3498db (blue) | #ffffff (white) | None |

---

## Reading Checklist

After reading this document, you should be able to answer:

- [x] What is the Signal/Slot pattern and why use it?
- [x] How do checkable buttons work?
- [x] Why track `_active_view` instead of just using button states?
- [x] What happens when you click an already-active button?
- [x] How does NavigationBar communicate with MainWindow?
- [x] Why use a dictionary to store buttons?

**Ready to implement?** Signal pattern understood, button management clear, styling approach defined.

---

*Document Type: Pre-Implementation Planning*
*Target Audience: Developers*
*Last Updated: 2025-12-28*
