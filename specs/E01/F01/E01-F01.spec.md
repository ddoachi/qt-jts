# Spec: E01-F01 - Main Window & Navigation

---
# ============================================================================
# SPEC METADATA
# ============================================================================

# === IDENTIFICATION ===
id: E01-F01
clickup_task_id: ''    # REQUIRED - Empty string if not yet created in ClickUp
title: Main Window & Navigation
type: feature

# === HIERARCHY ===
parent: E01
children: []
epic: E01
feature: F01
domain: application-framework

# === WORKFLOW ===
status: draft
priority: high

# === TRACKING ===
created: '2025-12-28'
updated: '2025-12-28'
due_date: ''
estimated_hours: 12
actual_hours: 0

# === METADATA ===
tags: [ui, navigation, pyside6, main-window]
effort: medium
risk: low
---

**Status**: Draft
**Type**: Feature
**Parent**: E01 (Application Framework)
**Created**: 2025-12-28
**Updated**: 2025-12-28

## Executive Summary

Implement the core application window with sidebar navigation system, enabling users to switch between different functional views (Dashboard, Data Collection, Scanner, Backtesting, etc.). This feature provides the foundational UI structure for the entire application, including a responsive main window with Qt stacked widgets, professional navigation bar with visual feedback, status bar for connection monitoring, and cross-platform window geometry persistence.

## Execution Flow

```
1. Application startup initializes MainWindow
   → Resolve dependencies from DI Container (SettingsService, Logger)
   → Create QStackedWidget for view management
   → Initialize NavigationBar with button configuration

2. Register all application views
   → Each feature module registers its view with view_id
   → Add view widget to QStackedWidget
   → Configure navigation button in NavigationBar
   → If registration fails: ERROR "Failed to register view {view_id}: {reason}"

3. Restore window geometry from settings
   → Load saved geometry from SettingsService
   → If geometry exists: Restore window size and position
   → If invalid geometry: WARN "Invalid window geometry, using defaults"
   → Set minimum window size to prevent unusable state

4. Display default view (Dashboard)
   → Navigate to "dashboard" view
   → Highlight corresponding navigation button
   → Update status bar with initial connection status

5. User clicks navigation button
   → NavigationBar emits navigation_requested(view_id) signal
   → MainWindow receives signal and validates view_id
   → If view not registered: ERROR "View {view_id} not found"
   → Switch QStackedWidget to target view
   → Update active button highlighting
   → Return: SUCCESS with view displayed

6. Application shutdown
   → Save current window geometry to settings
   → Cleanup view resources
   → Disconnect signal/slot connections
   → If save fails: WARN "Failed to save window geometry"
```

## User Stories

### Primary User Story
**As a** trader
**I want to** easily navigate between different application features using a clear sidebar navigation
**So that** I can quickly access the tools I need without confusion or excessive clicking

### Additional Stories
- **As a** trader, **I want to** see my window size and position restored when I restart the app, **So that** I don't have to resize and reposition the window every time
- **As a** trader, **I want to** see which view is currently active in the navigation bar, **So that** I always know where I am in the application
- **As a** trader, **I want to** see broker connection status in the status bar, **So that** I know if I'm connected before attempting trades

## Acceptance Scenarios

### Scenario 1: Happy Path - First Launch
**Given** the application is launched for the first time (no saved settings)
**When** the main window is displayed
**Then** the window should appear with default size (1280x800) centered on screen
**And** the Dashboard view should be displayed
**And** the Dashboard navigation button should be highlighted

### Scenario 2: Navigation Between Views
**Given** the main window is displayed with Dashboard view active
**When** the user clicks the "Scanner" navigation button
**Then** the content area should switch to the Scanner view
**And** the Scanner navigation button should be highlighted
**And** the Dashboard button should no longer be highlighted
**And** the view switch should complete in < 100ms

### Scenario 3: Window Geometry Persistence
**Given** the user has resized and moved the main window to custom position
**When** the user closes and restarts the application
**Then** the window should appear in the same size and position as before closing

### Scenario 4: Error Case - Invalid View Navigation
**Given** the main window is initialized
**When** internal code attempts to navigate to unregistered view "nonexistent"
**Then** the system should log an error "View nonexistent not found"
**And** the current view should remain displayed
**And** no crash or exception dialog should appear

## Requirements

### Functional Requirements
- **FR-001**: System MUST provide a main window with navigation bar, content area, and status bar
- **FR-002**: System MUST support registration of views with unique identifiers
- **FR-003**: System MUST switch between registered views when navigation buttons are clicked
- **FR-004**: System MUST highlight the currently active view in the navigation bar
- **FR-005**: System MUST persist window geometry (size and position) across application restarts
- **FR-006**: System MUST restore saved window geometry on application startup
- **FR-007**: System MUST display connection status indicators in the status bar

### Non-Functional Requirements
- **NFR-001**: Performance: Main window MUST appear within 500ms of application launch
- **NFR-002**: Performance: View switching MUST complete in < 100ms (instant visual feedback)
- **NFR-003**: Usability: Window MUST remain responsive during view loading operations
- **NFR-004**: Compatibility: Window MUST render consistently across Linux, macOS, and Windows
- **NFR-005**: Maintainability: All public methods MUST have type hints and docstrings

### Technical Constraints
- **TC-001**: Must use PySide6 QMainWindow as base class
- **TC-002**: Must use QStackedWidget for view management
- **TC-003**: Must integrate with QSettings for geometry persistence
- **TC-004**: Must use dependency injection for SettingsService and Logger
- **TC-005**: Must use Qt Signal/Slot mechanism for navigation events

## Key Entities

### Entity: MainWindow
- **Description**: Core application window managing navigation and view lifecycle
- **Key Attributes**: `_stack` (QStackedWidget), `_nav_bar` (NavigationBar), `_views` (dict), `_status_bar` (StatusBar)
- **Relationships**: Contains NavigationBar, manages multiple view widgets

### Entity: NavigationBar
- **Description**: Sidebar widget with navigation buttons
- **Key Attributes**: `_buttons` (dict of QPushButton), `_active_view` (str)
- **Relationships**: Emits signals to MainWindow, contained by MainWindow

### Entity: StatusBar
- **Description**: Bottom status bar showing connection and system status
- **Key Attributes**: Connection indicators, status messages
- **Relationships**: Updated by MainWindow and service events

## Dependencies

### Upstream Dependencies
- [ ] E01-F03: DI Container (for service resolution)
- [ ] E01-F02: SettingsService (for geometry persistence)
- [ ] E01-F04: Logger (for error and info logging)

### Downstream Impact
- [ ] All feature views: Will register themselves with MainWindow
- [ ] Navigation system: Foundation for all view-based features

## Gate Checks

### Pre-Implementation Gates
- [x] No [NEEDS CLARIFICATION] markers remain
- [x] Performance requirements specified (< 500ms launch, < 100ms switching)
- [x] Security requirements defined (N/A for this feature)
- [x] Scale requirements clear (single window, ~10 views)
- [x] PRD compliance verified (Section 6.1)

### Quality Gates
- [ ] Complexity justified (optimal granularity per auto-split analysis)
- [ ] All requirements testable
- [ ] Dependencies identified and documented
- [ ] Risk assessment complete

## Tasks Preview

### Implementation Tasks
- [ ] T01 [P] Create MainWindow skeleton with QStackedWidget
- [ ] T02 [P] Implement NavigationBar widget with buttons
- [ ] T03 Implement view registration and switching (depends on T01, T02)
- [ ] T04 [P] Add StatusBar with connection indicators
- [ ] T05 Implement window geometry persistence (depends on T01, F02)
- [ ] T06 [P] Add application icon and window styling

**[P]** = Can be executed in parallel

## Success Criteria

### Acceptance Criteria
- [ ] Main window launches with default view (Dashboard) displayed
- [ ] Navigation buttons switch between views correctly
- [ ] Active view is visually highlighted in navigation bar
- [ ] Window geometry persists and restores across application restarts
- [ ] Status bar displays connection status indicators
- [ ] Application can be closed gracefully with proper cleanup
- [ ] Window appears in < 500ms after launch
- [ ] View switching completes in < 100ms
- [ ] Window remains responsive during all operations
- [ ] Consistent appearance across Linux, macOS, Windows

### Definition of Done
- [ ] Code reviewed and approved
- [ ] Tests passing (unit, integration, UI tests)
  - [ ] Unit tests for MainWindow view registration
  - [ ] Unit tests for NavigationBar signal emission
  - [ ] Integration test for view switching flow
  - [ ] UI test for window geometry persistence
- [ ] Documentation updated (pre-docs, post-docs)
- [ ] Performance validated (startup < 500ms, switching < 100ms)
- [ ] Cross-platform testing complete
- [ ] 80% test coverage achieved

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| Qt version incompatibility | Low | Medium | Pin PySide6 version, test on multiple Qt versions |
| Platform-specific geometry issues | Medium | Low | Test geometry persistence on all platforms, use fallback defaults |
| Navigation state inconsistency | Low | Medium | Use single source of truth (_active_view), validate on every navigation |
| Memory leaks from view switching | Low | High | Properly cleanup views, use weak references where appropriate |
| Slow view initialization blocks UI | Medium | Medium | Load views lazily, show loading indicator, use background threads |

## Notes and Clarifications

### Open Questions
None - All requirements are clear

### Decisions Made
- 2025-12-28: Use QStackedWidget instead of QTabWidget for greater control over navigation UI
- 2025-12-28: Implement signal-based navigation to decouple NavigationBar from MainWindow
- 2025-12-28: Support view registry pattern to allow dynamic view registration from feature modules

### Research Needed
None - Qt patterns are well-established

## Artifacts

### Input Documents
- [Product Requirements Document](../../../docs/product-requirements-document.md) (Section 6.1)
- [Parent Spec](../E01.spec.md) (Epic E01)

### Output Artifacts (to be generated)
- [ ] `E01-F01.context.md` - Implementation context and progress
- [ ] `E01-F01.pre-docs.md` - Pre-implementation documentation ✓ (Already created)
- [ ] `E01-F01.post-docs.md` - Post-implementation learnings
- [ ] `E01-F01-implementation-narrative.md` - Comprehensive implementation story
- [ ] Unit tests: `tests/unit/presentation/test_main_window.py`
- [ ] Unit tests: `tests/unit/presentation/test_navigation_bar.py`
- [ ] Integration tests: `tests/integration/test_navigation_flow.py`

---
*Template Version: 2.0.0 - Enhanced with Speckit features*
