# Pre-Implementation Planning: MainWindow Skeleton with QStackedWidget

**Task ID**: E01-F01-T01
**Title**: Create MainWindow skeleton with QStackedWidget
**Estimated Effort**: 2 hours
**Reading Time**: 10-12 minutes

---

## 1. Problem & Context

### Clear Problem Statement
We need a foundational window structure that can host multiple application views (Dashboard, Scanner, Data Collection, etc.) and allow seamless switching between them. Without this foundation, we cannot build any feature views or navigation system.

### Business Impact
- **Unblocks Development**: Enables all feature teams to start building their views
- **User Experience Foundation**: Provides the container for all trader interactions
- **Navigation System Base**: Creates the infrastructure for view management

### Current Pain Points

| Issue | Impact | Frequency |
|-------|--------|-----------|
| No main window structure exists | Cannot launch application | Blocking |
| No view container available | Cannot display any features | Blocking |
| No view switching mechanism | Cannot navigate between features | Blocking |

### Success Metrics
- [x] MainWindow can be instantiated without errors
- [x] QStackedWidget is set as central widget
- [x] Window appears centered at 1280x800 size
- [x] Views can be registered programmatically
- [x] Views can be switched programmatically
- [x] Initialization completes in < 100ms

---

## 2. Conceptual Solution

### Core Architecture

Think of MainWindow as a **picture frame with multiple paintings** behind it:
- The frame (MainWindow) stays fixed
- The paintings (views) can be swapped in and out
- Only one painting is visible at a time
- The QStackedWidget is like a carousel that rotates to show different paintings

```
┌─────────────────────────────────────────┐
│  MainWindow (QMainWindow)               │
│  ┌───────────────────────────────────┐  │
│  │  QStackedWidget                   │  │
│  │  ┌─────────────────────────────┐  │  │
│  │  │ View 1 (visible)            │  │  │
│  │  │                             │  │  │
│  │  └─────────────────────────────┘  │  │
│  │  ┌─────────────────────────────┐  │  │
│  │  │ View 2 (hidden)             │  │  │
│  │  └─────────────────────────────┘  │  │
│  │  ┌─────────────────────────────┐  │  │
│  │  │ View 3 (hidden)             │  │  │
│  │  └─────────────────────────────┘  │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

### Key Concepts Explained

#### QStackedWidget: The View Carousel

**Real-World Analogy**: Think of a Rolodex card holder. You have many cards (views), but only one is visible at a time. You can flip to any card by name.

**How It Works**:
1. Add multiple widgets (cards) to the stack
2. Each widget gets an index (0, 1, 2, ...)
3. Call `setCurrentWidget()` or `setCurrentIndex()` to show a specific widget
4. All other widgets remain in memory but are hidden

**Why Use This?**
| Benefit | Description |
|---------|-------------|
| Fast Switching | Widgets stay in memory, switching is instant |
| Simple API | Just add widgets and call `setCurrentWidget()` |
| Memory Efficient | Only active widget is rendered |
| State Preservation | Hidden widgets retain their state |

#### View Registry: The Phone Book

Instead of remembering numeric indices (0, 1, 2), we use meaningful names:
- "dashboard" → Dashboard widget
- "scanner" → Scanner widget
- "settings" → Settings widget

```python
# BAD: Hard to remember, brittle
self._stack.setCurrentIndex(2)  # What is view 2?

# GOOD: Clear, maintainable
self.navigate_to("scanner")  # Obvious what happens
```

### Component Interactions

```
Application Startup Flow:

1. DI Container creates MainWindow
   ↓
2. MainWindow.__init__(settings, logger)
   ↓
3. Create QStackedWidget
   ↓
4. Set as central widget
   ↓
5. Setup window properties
   ↓
6. Ready to register views
```

**View Registration Flow**:
```
Feature Module
    ↓
    calls register_view("scanner", widget)
    ↓
MainWindow validates view_id is unique
    ↓
MainWindow stores in _views dict
    ↓
MainWindow adds to QStackedWidget
    ↓
Widget ready for navigation
```

---

## 3. Technical Approach

### Strategy Overview

**Problem**: We need a window that can host multiple views efficiently.

**Solution**: Use Qt's QMainWindow + QStackedWidget pattern:
- QMainWindow provides window framework (title bar, menu bar area, status bar area)
- QStackedWidget provides view container with built-in switching
- Python dict provides O(1) lookup by view name

**Before → After Comparison**:

| Aspect | Before | After |
|--------|--------|-------|
| Window | No window exists | Professional QMainWindow |
| Views | No container | QStackedWidget ready |
| Navigation | Impossible | Programmatic switching |
| Lookup | N/A | Fast dict-based registry |

### Design Decisions

| Decision | Chosen Approach | Why? | Alternatives Rejected |
|----------|----------------|------|----------------------|
| **Window Base Class** | QMainWindow | **Reasoning**: Provides professional window framework with menu bar, status bar, and toolbar areas out of the box. Native window decorations and platform integration. <br><br>**Problem/Solution**: We need professional window features (menus, status bar) that traders expect in desktop applications. QMainWindow provides these pre-configured. <br><br>**Trade-offs**: Slightly heavier than QWidget, but we gain professional features. More structure than QDialog, but that's desired for main window. <br><br>**Example**: `self.setCentralWidget()` automatically handles layout, `self.statusBar()` provides status area for connection indicators. | **QWidget**: Too basic, requires manual layout of all window areas. No status bar support. <br><br>**QDialog**: Designed for modal dialogs, not main windows. Wrong semantic meaning. |
| **View Container** | QStackedWidget | **Reasoning**: Purpose-built for showing one widget at a time from a collection. Zero-index lookup, automatic visibility management, preserves widget state when hidden. <br><br>**Problem/Solution**: We need instant view switching without destroying/recreating widgets. QStackedWidget keeps all widgets in memory but only renders the visible one, giving instant switches. <br><br>**Trade-offs**: Uses more memory than loading views on-demand, but we prioritize speed over memory. Memory cost is negligible with modern RAM. <br><br>**Example**: Switching from Dashboard to Scanner: `stack.setCurrentWidget(scanner_widget)` takes ~5ms, while recreating widget would take 100ms+. | **QTabWidget**: Displays tabs UI, but we want custom navigation sidebar. Forces tab visual style. <br><br>**Manual show/hide**: Requires tracking visibility state manually. Error-prone state management. |
| **View Lookup** | Dict[str, QWidget] | **Reasoning**: O(1) lookup by meaningful string keys. Pythonic, readable, flexible. Built-in key validation via `in` operator. <br><br>**Problem/Solution**: Need fast lookup by human-readable names ("dashboard" not index 0). Dict provides instant lookup while maintaining semantic clarity. <br><br>**Trade-offs**: Slightly more memory than list (stores hash table), but enables readable code. Dict keys are strings (small overhead) vs integers. <br><br>**Example**: `navigate_to("scanner")` is clear vs `navigate_to(2)` which requires documentation. | **List with indices**: Requires remembering numeric positions. Brittle when view order changes. <br><br>**OrderedDict**: Unnecessary ordering guarantee. Standard dict maintains insertion order in Python 3.7+. |
| **Dependency Injection** | Constructor injection | **Reasoning**: Explicit dependencies visible in constructor signature. Easy to test with mocks. Follows SOLID principles (dependency inversion). No hidden global state. <br><br>**Problem/Solution**: MainWindow needs SettingsService and Logger. Constructor injection makes these dependencies explicit and testable. Can easily swap with test doubles. <br><br>**Trade-offs**: Slightly more verbose constructor, but gains testability and clarity. Must have DI container in place. <br><br>**Example**: `MainWindow(settings, logger)` shows exactly what's needed. Test with `MainWindow(FakeSettings(), FakeLogger())`. | **Service Locator**: Hidden dependencies, hard to test. Global state coupling. <br><br>**Global imports**: Tight coupling, impossible to mock in tests. Violates dependency inversion. |

### Pseudocode

```
WHEN MainWindow is created:
  ACCEPT settings service and logger via constructor
  STORE references to injected dependencies

  CREATE QStackedWidget instance
  SET QStackedWidget as central widget

  INITIALIZE empty view registry dict

  SET window title to "JTS Trading Platform"
  SET window size to 1280 x 800
  SET minimum size to 800 x 600

  CALCULATE center position of primary screen
  MOVE window to center position

  LOG "MainWindow initialized successfully"


WHEN register_view(view_id, widget) is called:
  IF view_id already exists in registry:
    RAISE ValueError with duplicate error message

  STORE widget in registry with view_id as key
  ADD widget to QStackedWidget

  LOG "View registered: {view_id}"


WHEN navigate_to(view_id) is called:
  IF view_id NOT in registry:
    LOG ERROR "View {view_id} not found"
    RETURN False

  GET widget from registry using view_id
  SET QStackedWidget current widget to target widget

  LOG DEBUG "Navigated to {view_id}"
  RETURN True
```

---

## 4. Implementation Strategy

### Development Phases

```
Phase 1: Basic Structure (30 min)
├─ Create main_window.py file
├─ Define MainWindow class
├─ Setup __init__ with DI parameters
└─ Create _setup_ui method

Phase 2: Core Components (30 min)
├─ Initialize QStackedWidget
├─ Set as central widget
├─ Configure window properties
└─ Implement _center_on_screen

Phase 3: View Registry (30 min)
├─ Implement register_view method
├─ Add validation logic
├─ Implement navigate_to method
└─ Add error handling

Phase 4: Testing (30 min)
├─ Write unit tests
├─ Test view registration
├─ Test navigation
└─ Verify error cases
```

### Integration Points

```
MainWindow Integration Map:

         DI Container
              ↓
         [Creates]
              ↓
         MainWindow ←──── SettingsService (injected)
              │      └──── Logger (injected)
              │
              ├── Creates: QStackedWidget
              │
              ├── Later: NavigationBar (T02)
              │           ↓
              │      [Connects signals]
              │
              └── Later: StatusBar (T04)
```

**External Dependencies**:
- `PySide6.QtWidgets.QMainWindow`: Base class
- `PySide6.QtWidgets.QStackedWidget`: View container
- `PySide6.QtCore.QSize`: Size specification
- `SettingsService`: Configuration (from E01-F02)
- `Logger`: Event logging (from E01-F04)

### Risk Mitigation

| Risk | Probability | Impact | Mitigation Strategy |
|------|------------|--------|-------------------|
| QStackedWidget fails to initialize | Very Low | High | Add try-except around creation, validate instance before use, fallback to basic QWidget container |
| Center calculation incorrect for multi-monitor | Medium | Low | Use QApplication.primaryScreen() for consistent reference, test on multi-monitor setups, validate geometry after centering |
| View registry key collision | Low | Medium | Validate uniqueness in register_view, raise clear ValueError with existing view info, log all registrations for debugging |
| Injected dependencies are None | Low | High | Add constructor validation, raise TypeError if None, document required dependencies clearly |

---

## 5. Expected Behavior & Scenarios

### User Stories

**Story 1: Application Launch**
```
GIVEN: User starts the application
WHEN:  MainWindow is created
THEN:  - Window appears centered on screen
       - Window size is 1280x800
       - Window is empty (no views yet)
       - Window title shows "JTS Trading Platform"
```

**Story 2: View Registration**
```
GIVEN: MainWindow is initialized
WHEN:  Feature module calls register_view("scanner", scanner_widget)
THEN:  - Widget is added to internal registry
       - Widget is added to QStackedWidget
       - Registration is logged
       - No exception is raised
```

**Story 3: View Navigation**
```
GIVEN: Two views are registered ("dashboard", "scanner")
  AND: Dashboard is currently displayed
WHEN:  navigate_to("scanner") is called
THEN:  - QStackedWidget switches to scanner widget
       - Method returns True (success)
       - Navigation is logged
       - Scanner view becomes visible
```

### Edge Cases

| Case | Expected Behavior |
|------|------------------|
| Navigate to unregistered view | Log error, return False, current view remains |
| Register duplicate view_id | Raise ValueError immediately, reject registration |
| Register with empty view_id | Raise ValueError with clear message |
| Navigate before any views registered | Log error, return False, no crash |
| Call navigate_to with None | Type error caught, logged, return False |
| Window closed immediately after creation | No errors, cleanup succeeds |

### Performance Expectations

**Time Budget**:
```
MainWindow Initialization:
├─ Object creation:        < 10ms
├─ QStackedWidget setup:   < 20ms
├─ Window property config: < 30ms
├─ Screen centering:       < 20ms
└─ Total:                  < 100ms ✓

View Registration (per view):
├─ Validation:             < 1ms
├─ Dict insert:            < 1ms
├─ QStackedWidget add:     < 10ms
└─ Total:                  < 15ms ✓

View Navigation:
├─ Registry lookup:        < 1ms
├─ QStackedWidget switch:  < 5ms
└─ Total:                  < 10ms ✓
```

---

## 6. Testing Strategy

### Coverage Pyramid

```
      /\
     /E2E\        1 test: Launch and verify window
    /------\
   /  INT  \      2 tests: DI integration, view registration flow
  /----------\
 /   UNIT    \   8 tests: All methods, edge cases, errors
/──────────────\
```

### Key Scenarios

**Unit Tests** (8 scenarios):
- ✓ Test MainWindow initialization with valid dependencies
- ✓ Test window properties (size, title, minimum size)
- ✓ Test QStackedWidget is set as central widget
- ✓ Test register_view adds widget to registry and stack
- ✓ Test register_view raises ValueError for duplicate view_id
- ✓ Test navigate_to switches to registered view
- ✓ Test navigate_to returns False for unregistered view
- ✓ Test _center_on_screen positions window correctly

**Integration Tests** (2 scenarios):
- ✓ Test MainWindow with real SettingsService and Logger
- ✓ Test view registration → navigation flow end-to-end

**Manual Verification**:
- [ ] Window appears centered on multiple monitor setups
- [ ] Window appears with correct size on different DPI settings
- [ ] Window title bar shows correct text on all platforms

### Validation Approach

**Approach**: Test-Driven Development (TDD)

1. **Write Test First**: Define expected behavior in test
2. **Run Test (Fails)**: Verify test fails as expected
3. **Implement Code**: Write minimal code to pass test
4. **Run Test (Passes)**: Verify implementation works
5. **Refactor**: Clean up code while keeping tests green

**Example TDD Cycle**:
```python
# 1. Write failing test
def test_navigate_to_unregistered_view_returns_false():
    window = MainWindow(settings, logger)
    result = window.navigate_to("nonexistent")
    assert result is False

# 2. Implement
def navigate_to(self, view_id: str) -> bool:
    if view_id not in self._views:
        self._logger.error(f"View {view_id} not found")
        return False
    # ... rest of implementation

# 3. Test passes ✓
```

---

## Visual Reference

### Window Hierarchy

```
QMainWindow (MainWindow)
│
├─── Title Bar (system managed)
│    └─── "JTS Trading Platform"
│
├─── Central Widget Area
│    └─── QStackedWidget
│         ├─── View 1 (QWidget)
│         ├─── View 2 (QWidget)
│         └─── View 3 (QWidget)
│
└─── (Reserved for Status Bar - T04)
```

### State Diagram

```
[Created] ─── init(settings, logger) ──→ [Initialized]
                                              │
                                              │ register_view()
                                              ↓
                                         [View Registered]
                                              │
                                              │ navigate_to()
                                              ↓
                                         [View Displayed]
                                              │
                                              │ navigate_to()
                                              ↓
                                         [Different View]
```

---

## Reading Checklist

After reading this document, you should be able to answer:

- [x] What problem does MainWindow solve?
- [x] Why do we use QStackedWidget instead of tabs?
- [x] How does the view registry work?
- [x] What happens when you navigate to an invalid view?
- [x] What are the performance targets?
- [x] What dependencies does MainWindow need?

**Ready to implement?** All concepts clear, design decisions justified, implementation path outlined.

---

*Document Type: Pre-Implementation Planning*
*Target Audience: Developers*
*Last Updated: 2025-12-28*
