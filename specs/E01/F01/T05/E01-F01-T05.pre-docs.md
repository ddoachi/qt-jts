# Pre-Implementation Planning: Window Geometry Persistence

**Task ID**: E01-F01-T05
**Title**: Implement window geometry persistence
**Estimated Effort**: 2 hours
**Reading Time**: 10-12 minutes

---

## 1. Problem & Context

### Clear Problem Statement
Every time traders restart the application, they must manually resize and reposition the window to their preferred setup. This wastes time and creates frustration, especially for traders who use specific multi-monitor configurations.

### Business Impact
- **User Experience**: Eliminating repetitive window setup improves satisfaction
- **Productivity**: Traders can immediately start trading instead of adjusting windows
- **Professional Polish**: Remembering user preferences shows attention to detail

### Current Pain Points

| Issue | Impact | Frequency |
|-------|--------|-----------|
| Window size resets to default | Must resize every launch | Every session |
| Window position resets | Must reposition every launch | Every session |
| Multi-monitor setup lost | Must move to external monitor again | Daily (for multi-monitor users) |

### Success Metrics
- [x] Window size and position restored on next launch
- [x] Works correctly with multiple monitors
- [x] Handles monitor disconnection gracefully
- [x] Restoration completes in < 100ms
- [x] First launch uses sensible defaults (centered, 1280×800)

---

## 2. Conceptual Solution

### Core Architecture

Think of window geometry persistence as a **bookmark in a book**:
- Close book → Insert bookmark at current page
- Reopen book → Bookmark shows where you left off
- Lost bookmark → Start from beginning (default page)

```
Session Flow:

Application Launch:
  → Check for saved geometry
  → If found: Restore window to saved size/position
  → If not found: Use defaults (1280×800, centered)

Application Close:
  → Save current window geometry
  → Store in settings (QSettings/SettingsService)

Next Launch:
  → Repeat cycle ✓
```

### Key Concepts Explained

#### QWidget Geometry Saving: The Snapshot

**Real-World Analogy**: Like taking a photo of your workspace arrangement:
- Photo captures exact desk positions
- Can recreate arrangement from photo
- If furniture moved, photo helps restore original layout

**Qt's Built-in Methods**:
```python
# Taking the snapshot
geometry_bytes = self.saveGeometry()
# Returns QByteArray with window size, position, state

# Restoring from snapshot
self.restoreGeometry(geometry_bytes)
# Restores window to saved size, position, state
```

**What's Saved?**

| Data | Description | Example |
|------|-------------|---------|
| Window size | Width and height in pixels | 1280×800 |
| Window position | X,Y coordinates on screen | (100, 50) |
| Window state | Maximized, minimized, normal | Normal |
| Frame geometry | Including title bar and borders | OS-dependent |

**Why Use Qt's Methods?**

- Handles platform differences automatically (Windows vs macOS vs Linux)
- Includes window decorations (title bar, borders)
- Stores state (maximized, minimized)
- Single method call vs manually tracking multiple properties

#### Geometry Validation: The Safety Check

**Problem**: Saved geometry might be invalid:
- User had window on external monitor, now disconnected
- Screen resolution changed
- Monitor configuration changed (different arrangement)

**Real-World Analogy**: Like GPS coordinates:
- Coordinates saved when you parked car
- If parking lot demolished, coordinates point to nothing
- Validation checks if coordinates still valid (location exists)

**Validation Strategy**:
```python
WHEN restoring geometry:
  1. Restore geometry bytes
  2. Check if window center is on ANY screen:
     FOR EACH available screen:
       IF screen contains window center point:
         RETURN Valid ✓

  3. If NOT on any screen:
     WARN "Window off-screen"
     Re-center on primary screen
```

**Why Center Point?**

- Window might span multiple monitors (intentional)
- At least center should be accessible to user
- Can drag window even if edges are off-screen
- More forgiving than requiring entire window on-screen

#### Settings Integration: The Filing Cabinet

**Real-World Analogy**: Filing cabinet with labeled folders:
- "Window Geometry" folder stores window data
- Each app launch: Open folder, read data
- Each app close: Open folder, write new data

**SettingsService API**:
```python
# Save geometry
self._settings.set("window/geometry", geometry_bytes)

# Load geometry
geometry_bytes = self._settings.get("window/geometry")
```

**Backend**: QSettings (cross-platform)
- Windows: Registry (`HKEY_CURRENT_USER\Software\JTS Trading`)
- macOS: plist file (`~/Library/Preferences/com.jtstrading.plist`)
- Linux: INI file (`~/.config/JTS Trading/settings.conf`)

### Component Interaction Flow

```
Application Launch:
  MainWindow.__init__()
       ↓
  _setup_ui() (creates widgets)
       ↓
  _restore_geometry()
       ├─ settings.get("window/geometry")
       │       ↓
       │  If geometry exists:
       │    ├─ restoreGeometry(geometry_bytes)
       │    ├─ Validate window is on-screen
       │    └─ If off-screen: _center_on_screen()
       │
       └─ If no geometry:
            └─ _use_default_geometry()
                 ├─ resize(1280, 800)
                 └─ _center_on_screen()

Application Close:
  closeEvent(event)
       ↓
  _save_geometry()
       ├─ geometry_bytes = saveGeometry()
       ├─ settings.set("window/geometry", geometry_bytes)
       └─ LOG "Geometry saved"
       ↓
  parent.closeEvent(event)  # Continue normal shutdown
```

---

## 3. Technical Approach

### Strategy Overview

**Problem**: Need to save and restore window size and position across application restarts, with validation for multi-monitor configurations.

**Solution**: Use Qt's `saveGeometry()`/`restoreGeometry()` paired with SettingsService for persistence, with validation to handle monitor disconnection.

### Design Decisions

| Decision | Chosen Approach | Why? | Alternatives Rejected |
|----------|----------------|------|----------------------|
| **Save Method** | QWidget.saveGeometry() | **Reasoning**: Qt's built-in method handles all platform-specific details (window decorations, maximized state, etc.). Single QByteArray contains all geometry data. Robust, tested across millions of Qt applications. <br><br>**Problem/Solution**: Window geometry includes platform-specific details (title bar height varies by OS). saveGeometry() encapsulates all this complexity into one opaque QByteArray. <br><br>**Trade-offs**: Opaque binary format vs human-readable JSON. But we don't need to inspect geometry data, and Qt handles format changes between versions. <br><br>**Example**: `geometry = self.saveGeometry()` captures size, position, maximized state, etc. One line vs 10+ lines tracking each property. | **Manual tracking** (width, height, x, y): Must handle window decorations manually. Breaks on different themes. Miss edge cases (maximized state). <br><br>**JSON storage**: Would need to serialize/deserialize each property. More code, more bugs. |
| **Restore Timing** | After `_setup_ui()` completes | **Reasoning**: Widgets must be created before restoring geometry. If restored too early, Qt may override with default size. Calling after setup ensures all constraints (minimum size) are already set. <br><br>**Problem/Solution**: Qt's layout system calculates initial size based on widgets. Restoring before this completes can cause conflicts. Waiting until after _setup_ui() ensures stable state. <br><br>**Trade-offs**: Brief flicker of default size before restore (on slow machines). But ensures correctness. Could optimize with hidden window trick if needed. <br><br>**Example**: `_setup_ui()` sets minimum size 800×600, then `_restore_geometry()` restores saved 1600×900. If reversed, restore might be ignored. | **Before setup**: Qt's layout may override restored geometry. <br><br>**In showEvent**: Too late, window already visible at default size. User sees flicker. |
| **Validation** | Check window center on screens | **Reasoning**: Window center is most important point—must be accessible for user to drag window. More forgiving than requiring entire window on-screen (user might intentionally span monitors). Fast check (O(screens) which is usually 1-3). <br><br>**Problem/Solution**: User saved geometry with window on monitor 2. Monitor 2 now disconnected. If we restore blindly, window is off-screen and inaccessible. Checking center point detects this. <br><br>**Trade-offs**: Window edges might be off-screen (acceptable). But center always accessible. Could be more strict (require entire window on-screen), but that prevents intentional multi-monitor spanning. <br><br>**Example**: Window center at (2500, 1080). No screen contains that point. Detected as invalid, window re-centered on primary screen. | **No validation**: Window could be completely off-screen, inaccessible. <br><br>**Entire window on-screen**: Breaks intentional multi-monitor setups. Too restrictive. |
| **Fallback Strategy** | Re-center on primary screen | **Reasoning**: Primary screen is always available (by definition). Centering puts window in predictable location. Non-destructive (doesn't modify saved geometry). User can manually move to desired screen. <br><br>**Problem/Solution**: Validation detects off-screen window. Need safe fallback. Primary screen center guarantees visible, accessible window. <br><br>**Trade-offs**: User must manually reposition if they reconnect monitor. But better than invisible window. Could add "remember last screen ID" but complex with minimal benefit. <br><br>**Example**: External monitor disconnected. Validation fails. Window repositioned to laptop screen center. User can immediately access application. | **Keep off-screen**: Window inaccessible, user thinks app crashed. <br><br>**Remember screen ID**: Complex, screen IDs change, brittle. |
| **Storage Key** | "window/geometry" | **Reasoning**: Hierarchical key structure organizes settings logically. "window/" prefix groups all window-related settings. "geometry" is clear, descriptive name. Follows Qt convention. <br><br>**Problem/Solution**: Settings can have hundreds of keys. Grouping related keys (window/geometry, window/state) makes them discoverable and maintainable. <br><br>**Trade-offs**: Slightly longer key string vs flat namespace. But organization beats brevity for maintainability. <br><br>**Example**: All window settings in one place: `window/geometry`, `window/state`, `window/last_view`. Easy to find, easy to document. | **Flat key** ("geometry"): Clutters global namespace. Hard to find related settings. <br><br>**Deep nesting** ("ui/window/main/geometry"): Overkill for our scope. |

### Pseudocode

```
WHEN MainWindow.__init__() executes:
  # ... existing initialization ...
  CALL _setup_ui()
  CALL _restore_geometry()


WHEN _restore_geometry() is called:
  GET geometry_bytes FROM settings.get("window/geometry")

  IF geometry_bytes exists AND is QByteArray:
    SUCCESS = restoreGeometry(geometry_bytes)

    IF SUCCESS:
      IF _validate_geometry():
        LOG INFO "Window geometry restored"
        RETURN
      ELSE:
        LOG WARNING "Invalid saved geometry (off-screen)"
        CALL _use_default_geometry()
    ELSE:
      LOG WARNING "Failed to restore geometry"
      CALL _use_default_geometry()

  ELSE:
    LOG WARNING "No saved geometry found"
    CALL _use_default_geometry()


WHEN _use_default_geometry() is called:
  RESIZE window to (1280, 800)
  SET minimum size to (800, 600)
  CALL _center_on_screen()


WHEN _validate_geometry() is called:
  GET window frame geometry (position + size)
  CALCULATE window center point

  GET all available screens FROM QApplication.screens()

  FOR EACH screen IN screens:
    IF screen.geometry() CONTAINS center point:
      RETURN True  # Valid, window is on a screen

  RETURN False  # Invalid, window is off all screens


WHEN _center_on_screen() is called:
  GET primary screen FROM QApplication.primaryScreen()
  GET screen available geometry (excludes taskbar)

  GET window frame geometry
  CALCULATE center point of screen
  MOVE window frame center to screen center

  MOVE window to calculated position
  LOG DEBUG "Window centered on screen"


WHEN closeEvent(event) is called:
  LOG DEBUG "Window closing, saving geometry"
  CALL _save_geometry()
  CALL parent.closeEvent(event)  # Continue normal shutdown


WHEN _save_geometry() is called:
  TRY:
    GET geometry_bytes FROM saveGeometry()
    CALL settings.set("window/geometry", geometry_bytes)
    LOG INFO "Window geometry saved"
  EXCEPT exception:
    LOG WARNING "Failed to save geometry: {exception}"
```

---

## 4. Implementation Strategy

### Development Phases

```
Phase 1: Save/Restore Basic (30 min)
├─ Implement _save_geometry method
├─ Implement _restore_geometry method
├─ Override closeEvent to save
├─ Test save → close → relaunch → restore

Phase 2: Default Handling (30 min)
├─ Implement _use_default_geometry method
├─ Implement _center_on_screen method
├─ Test first launch (no saved geometry)
└─ Test centered positioning

Phase 3: Validation (45 min)
├─ Implement _validate_geometry method
├─ Test with multiple monitors
├─ Test with disconnected monitor
└─ Verify fallback to defaults

Phase 4: Edge Cases (15 min)
├─ Test maximized window state
├─ Test very small screen
├─ Test screen resolution change
└─ Handle settings unavailable

Phase 5: Testing (15 min)
├─ Write unit tests
├─ Test geometry persistence flow
└─ Manual cross-platform testing
```

### Integration Points

```
Dependencies:
  T01 (MainWindow skeleton) ───┐
                               ├──► T05 (This task)
  E01-F02 (SettingsService) ───┘

Modified Components:
  MainWindow (from T01):
    ├─ Add _restore_geometry() to __init__
    ├─ Add _save_geometry() method
    ├─ Add _validate_geometry() method
    ├─ Add _center_on_screen() method
    ├─ Add _use_default_geometry() method
    └─ Override closeEvent()

External Dependencies:
  ├─ SettingsService.get("window/geometry")
  ├─ SettingsService.set("window/geometry", data)
  └─ QApplication.screens() (for validation)
```

### Risk Mitigation

| Risk | Probability | Impact | Mitigation Strategy |
|------|------------|--------|-------------------|
| Restored geometry places window off-screen | Medium | Medium | **Strategy**: Validate geometry after restore. Check window center is on any available screen. If validation fails, re-center on primary screen. Log warning for debugging. **Detection**: User reports window not visible. **Recovery**: Delete saved geometry, restart (forces default centered window). |
| SettingsService not available at startup | Low | High | **Strategy**: Wrap settings access in try-except. If settings unavailable, catch exception and use defaults. Log error clearly. Don't crash, degrade gracefully. **Detection**: Exception during _restore_geometry. **Recovery**: Use default geometry, log error, continue launch. |
| Geometry corruption in settings file | Low | Medium | **Strategy**: Validate geometry_bytes is QByteArray before restore. If restore fails, catch and use defaults. QSettings handles corrupt data gracefully (returns None). **Detection**: restoreGeometry() returns False. **Recovery**: Log warning, use default geometry. Consider clearing corrupt setting. |
| Multi-monitor changes between sessions | Medium | Low | **Strategy**: Validate geometry against CURRENT screen configuration. Don't assume saved geometry is still valid. Re-center if screens changed. **Detection**: Window off-screen after monitor change. **Recovery**: Validation detects, re-centers automatically. |

---

## 5. Expected Behavior & Scenarios

### User Stories

**Story 1: First Launch (No Saved Geometry)**
```
GIVEN: Application launched for first time
  AND: No geometry saved in settings
WHEN:  MainWindow initializes
THEN:  - Warning logged: "No saved geometry found"
       - Window size set to 1280×800
       - Window centered on primary screen
       - Window is visible and accessible
```

**Story 2: Geometry Restoration**
```
GIVEN: User previously resized window to 1600×900
  AND: User moved window to position (100, 50)
  AND: User closed application (geometry saved)
WHEN:  Application launches again
THEN:  - Geometry restored from settings
       - Window appears at position (100, 50)
       - Window size is 1600×900
       - Validation passes (window on-screen)
       - Info logged: "Window geometry restored"
```

**Story 3: Geometry Saving on Close**
```
GIVEN: Window at custom position (200, 100) with size 1400×800
WHEN:  User clicks close button
THEN:  - closeEvent triggered
       - _save_geometry() called
       - Geometry saved to settings as "window/geometry"
       - Info logged: "Window geometry saved"
       - Application closes normally
```

**Story 4: Invalid Geometry (Monitor Disconnected)**
```
GIVEN: Geometry saved with window on external monitor (position 2000, 100)
  AND: External monitor now disconnected
WHEN:  Application launches
THEN:  - Geometry restore attempted
       - Validation fails (window off-screen)
       - Warning logged: "Invalid saved geometry (off-screen)"
       - Window re-centered on primary screen (laptop)
       - Window uses saved size (if reasonable) or default size
       - Window is visible and accessible
```

### Edge Cases

| Case | Expected Behavior |
|------|------------------|
| Maximized window saved | Restore to maximized state on next launch |
| Screen resolution decreased | Validate fails if window larger than screen, use defaults |
| Minimum size increased after save | Restored size respects new minimum (Qt handles automatically) |
| Settings file deleted | Treated as first launch, uses defaults, no crash |
| restoreGeometry() returns False | Log warning, use default geometry |
| User has 3 monitors → disconnects 2 | Validation catches, re-centers on remaining monitor |

### Performance Expectations

**Time Budget**:
```
Geometry Restoration:
├─ Settings read:          < 10ms
├─ restoreGeometry():      < 30ms
├─ Validation:             < 10ms (iterate screens)
└─ Total:                  < 50ms ✓ (well under 100ms target)

Geometry Saving:
├─ saveGeometry():         < 20ms
├─ Settings write:         < 30ms
└─ Total:                  < 50ms ✓

Centering Calculation:
├─ Get screen geometry:    < 5ms
├─ Calculate position:     < 1ms
├─ Move window:            < 10ms
└─ Total:                  < 20ms ✓
```

---

## 6. Testing Strategy

### Coverage Pyramid

```
        /\
       /E2E\       2 tests: Full save/restore cycle, monitor change
      /------\
     /  INT  \     2 tests: Settings integration, screen validation
    /----------\
   /   UNIT    \  8 tests: All methods, edge cases
  /──────────────\
```

### Key Scenarios

**Unit Tests** (8 scenarios):
- ✓ Test _restore_geometry with valid saved geometry
- ✓ Test _restore_geometry with no saved geometry
- ✓ Test _restore_geometry with invalid geometry
- ✓ Test _save_geometry saves to settings
- ✓ Test _validate_geometry with on-screen window
- ✓ Test _validate_geometry with off-screen window
- ✓ Test _center_on_screen positions correctly
- ✓ Test _use_default_geometry sets size and centers

**Integration Tests** (2 scenarios):
- ✓ Test full cycle: save → close → relaunch → restore
- ✓ Test validation with mocked screen configuration

**End-to-End Tests** (2 scenarios):
- ✓ Manual test: Resize, move, close, relaunch → verify restored
- ✓ Manual test: Disconnect monitor, relaunch → verify re-centered

### Validation Approach

**Mock Strategy**: Mock QSettings for deterministic tests

```python
def test_restore_geometry_with_saved_data():
    # Mock settings to return saved geometry
    mock_settings = MagicMock()
    saved_geometry = QByteArray()  # Simulate saved data
    mock_settings.get.return_value = saved_geometry

    window = MainWindow(mock_settings, logger)

    # Verify restoreGeometry called with saved data
    # Verify geometry restored correctly
```

**Screen Mocking**: Mock QApplication.screens() for validation tests

```python
def test_validate_geometry_off_screen():
    window = MainWindow(settings, logger)
    window.move(5000, 5000)  # Way off-screen

    # Mock screens to return limited geometry
    with patch('PySide6.QtWidgets.QApplication.screens') as mock_screens:
        mock_screen = MagicMock()
        mock_screen.geometry.return_value = QRect(0, 0, 1920, 1080)
        mock_screens.return_value = [mock_screen]

        result = window._validate_geometry()

        assert result is False  # Window center not on any screen
```

---

## Visual Reference

### Geometry Persistence Flow

```
┌──────────── Session 1 ────────────┐
│                                   │
│  User resizes/moves window        │
│         ↓                         │
│  Window: 1600×900 at (100, 50)   │
│         ↓                         │
│  User closes application          │
│         ↓                         │
│  closeEvent() triggered           │
│         ↓                         │
│  _save_geometry()                 │
│         ↓                         │
│  settings.set("window/geometry")  │
│         ↓                         │
│  [Data saved to disk]             │
│         ↓                         │
│  Application exits                │
└───────────────────────────────────┘

┌──────────── Session 2 ────────────┐
│                                   │
│  Application launches             │
│         ↓                         │
│  MainWindow.__init__()            │
│         ↓                         │
│  _restore_geometry()              │
│         ↓                         │
│  settings.get("window/geometry")  │
│         ↓                         │
│  [Read saved data from disk]      │
│         ↓                         │
│  restoreGeometry(saved_data)      │
│         ↓                         │
│  _validate_geometry()             │
│         ↓                         │
│  ✓ Valid: Window at (100, 50)    │
│     1600×900 size                 │
│         ↓                         │
│  User continues work              │
└───────────────────────────────────┘
```

### Validation Logic

```
restoreGeometry(saved_data)
         ↓
Window positioned at saved location
         ↓
_validate_geometry()
         ↓
Get window center point (cx, cy)
         ↓
For each screen:
  ┌────────────────────────┐
  │ Screen 1: (0,0)-      │
  │   (1920,1080)          │
  │   Contains (cx,cy)? ✓  │ ──→ VALID
  └────────────────────────┘

OR

  ┌────────────────────────┐
  │ Screen 1: (0,0)-      │
  │   (1920,1080)          │
  │   Contains (3000,100)?│
  │   NO                   │
  │                        │
  │ No other screens       │ ──→ INVALID
  └────────────────────────┘
         ↓
  _use_default_geometry()
  _center_on_screen()
```

---

## Reading Checklist

After reading this document, you should be able to answer:

- [x] How does Qt save/restore window geometry?
- [x] When is geometry saved and restored?
- [x] Why validate geometry after restoration?
- [x] What happens if saved geometry is off-screen?
- [x] How does centering on screen work?
- [x] Where is geometry data stored?

**Ready to implement?** Save/restore pattern clear, validation strategy understood, fallback handling defined.

---

*Document Type: Pre-Implementation Planning*
*Target Audience: Developers*
*Last Updated: 2025-12-28*
