# Spec: E01-F01-T05 - Implement window geometry persistence

---
# ============================================================================
# SPEC METADATA
# ============================================================================

# === IDENTIFICATION ===
id: E01-F01-T05
clickup_task_id: '86ew0209u'
title: Implement window geometry persistence
type: task

# === HIERARCHY ===
parent: E01-F01
children: []
epic: E01
feature: F01
task: T05
domain: application-framework

# === WORKFLOW ===
status: draft
priority: medium

# === TRACKING ===
created: '2025-12-28'
updated: '2025-12-28'
due_date: ''
estimated_hours: 2
actual_hours: 0

# === METADATA ===
tags: [ui, pyside6, settings, persistence, qsettings]
effort: small
risk: medium
parallel: false
---

**Status**: Draft
**Type**: Task
**Parent**: E01-F01 (Main Window & Navigation)
**Created**: 2025-12-28
**Updated**: 2025-12-28
**Dependencies**: T01 (MainWindow skeleton), E01-F02 (SettingsService)

## Executive Summary

Implement window geometry persistence to save and restore the MainWindow's size, position, and state across application restarts. Use SettingsService (backed by QSettings) to store window geometry, ensuring traders don't need to resize and reposition the window every time they launch the application.

## Execution Flow

```
1. Add geometry persistence to MainWindow initialization
   → In MainWindow.__init__(), after _setup_ui()
   → Call _restore_geometry() method
   → If geometry exists in settings: Restore window size and position
   → If no geometry or invalid: Use default size and center on screen

2. Implement _restore_geometry() method
   → Access SettingsService to get "window/geometry" setting
   → If setting exists and is valid QByteArray:
     → Call self.restoreGeometry(geometry_bytes)
     → Validate restored geometry is on screen
     → If window is off-screen: Re-center window
   → If setting doesn't exist or is invalid:
     → WARN "No saved geometry, using defaults"
     → Use default size (1280x800) and center on screen
   → Log restoration result

3. Implement _save_geometry() method
   → Get current window geometry: self.saveGeometry()
   → Convert to QByteArray
   → Save to SettingsService: "window/geometry" = geometry_bytes
   → Log successful save
   → If save fails: WARN "Failed to save window geometry: {error}"

4. Hook geometry saving to application close
   → Override closeEvent(event: QCloseEvent) method
   → Call _save_geometry() before closing
   → Call parent closeEvent to allow normal shutdown
   → Ensure geometry is saved even on abnormal shutdown (if possible)

5. Implement _validate_geometry() helper
   → Check if restored window is visible on any screen
   → Get all available screens: QApplication.screens()
   → Check if window center point is within any screen bounds
   → Return True if valid, False if off-screen

6. Implement _center_on_screen() helper
   → Get primary screen: QApplication.primaryScreen()
   → Get screen geometry: screen.availableGeometry()
   → Calculate center position: (screen_width - window_width) / 2
   → Move window to calculated position
   → Log centering action

7. Add window state persistence (optional enhancement)
   → Save window state (maximized, minimized): self.saveState()
   → Restore window state on startup: self.restoreState()
   → Store in "window/state" setting

8. Handle multi-monitor edge cases
   → If user had window on external monitor that's now disconnected
   → Validate geometry before restoring
   → Fall back to primary screen if invalid
   → Ensure window is always accessible
```

## User Stories

### Primary User Story
**As a** trader
**I want to** have my window size and position restored when I restart the app
**So that** I don't have to resize and reposition the window every time I launch it

### Additional Stories
- **As a** trader with multiple monitors, **I want to** have the window appear on the correct monitor where I left it
- **As a** trader, **I want to** have the window appear in a usable location even if I disconnect external monitors

## Acceptance Scenarios

### Scenario 1: Happy Path - First Launch (No Saved Geometry)
**Given** the application is launched for the first time
**When** MainWindow is initialized
**Then** the window should appear with default size (1280x800)
**And** the window should be centered on the primary screen
**And** a warning should be logged: "No saved geometry, using defaults"

### Scenario 2: Geometry Restoration
**Given** the user has previously resized the window to 1600x900
**And** moved the window to position (100, 50)
**And** closed the application
**When** the application is launched again
**Then** the window should appear at position (100, 50)
**And** the window should have size 1600x900
**And** the restoration should be logged

### Scenario 3: Geometry Saving on Close
**Given** the window is at custom position (200, 100) with size 1400x800
**When** the user closes the application
**Then** the geometry should be saved to SettingsService
**And** the save should be logged
**And** the application should close normally

### Scenario 4: Invalid Geometry (External Monitor Disconnected)
**Given** the saved geometry places window on external monitor
**And** the external monitor is now disconnected
**When** the application is launched
**Then** the geometry validation should detect off-screen window
**And** the window should be re-centered on primary screen
**And** the window should use saved size if reasonable, or default size
**And** a warning should be logged about invalid geometry

## Requirements

### Functional Requirements
- **FR-001**: MainWindow MUST save geometry (size and position) on application close
- **FR-002**: MainWindow MUST restore saved geometry on application startup
- **FR-003**: MainWindow MUST validate restored geometry to ensure window is visible
- **FR-004**: MainWindow MUST fall back to default geometry if saved geometry is invalid
- **FR-005**: MainWindow MUST center window on screen when using default geometry
- **FR-006**: MainWindow MUST handle multi-monitor configurations correctly

### Non-Functional Requirements
- **NFR-001**: Geometry restoration MUST complete in < 100ms
- **NFR-002**: Invalid geometry MUST NOT cause application startup failure
- **NFR-003**: Geometry saving MUST NOT block application shutdown

### Technical Constraints
- **TC-001**: Must use SettingsService for persistence
- **TC-002**: Must use QWidget.saveGeometry() and restoreGeometry() methods
- **TC-003**: Must validate geometry against current screen configuration
- **TC-004**: Must be compatible with Qt's geometry management

## Key Entities

### Entity: MainWindow (Enhanced)
- **Description**: MainWindow with geometry persistence
- **New Methods**:
  - `_restore_geometry() -> None` - Restore saved window geometry
  - `_save_geometry() -> None` - Save current window geometry
  - `_validate_geometry() -> bool` - Validate restored geometry
  - `_center_on_screen() -> None` - Center window on primary screen
  - `closeEvent(event: QCloseEvent) -> None` - Override to save geometry

### Settings Keys
- **window/geometry**: QByteArray - Saved window geometry
- **window/state**: QByteArray - Saved window state (optional)

## Dependencies

### Upstream Dependencies
- [ ] T01: MainWindow skeleton (REQUIRED)
- [ ] E01-F02: SettingsService (REQUIRED)

### Downstream Impact
None - This is a self-contained enhancement to MainWindow

## Implementation Details

### File Structure
```
src/presentation/main_window.py (modified)
tests/unit/presentation/test_main_window_geometry.py
```

### Code Skeleton
```python
from PySide6.QtWidgets import QMainWindow, QApplication
from PySide6.QtCore import QByteArray, QPoint, QRect
from PySide6.QtGui import QCloseEvent

class MainWindow(QMainWindow):
    """Main application window with geometry persistence."""

    def __init__(self, settings: SettingsService, logger: Logger):
        """Initialize main window."""
        super().__init__()
        self._settings = settings
        self._logger = logger
        # ... existing initialization ...

        self._setup_ui()
        self._restore_geometry()

    def _restore_geometry(self) -> None:
        """Restore window geometry from settings."""
        geometry_bytes = self._settings.get("window/geometry")

        if geometry_bytes and isinstance(geometry_bytes, (QByteArray, bytes)):
            # Attempt to restore saved geometry
            success = self.restoreGeometry(QByteArray(geometry_bytes))

            if success and self._validate_geometry():
                self._logger.info("Window geometry restored")
            else:
                self._logger.warning("Invalid saved geometry, using defaults")
                self._use_default_geometry()
        else:
            self._logger.warning("No saved geometry, using defaults")
            self._use_default_geometry()

    def _use_default_geometry(self) -> None:
        """Set default window size and position."""
        self.resize(1280, 800)
        self.setMinimumSize(800, 600)
        self._center_on_screen()

    def _validate_geometry(self) -> bool:
        """Validate that window is visible on a screen.

        Returns:
            True if window is on a valid screen, False otherwise
        """
        window_rect = self.frameGeometry()
        window_center = window_rect.center()

        # Check if window center is on any available screen
        for screen in QApplication.screens():
            if screen.geometry().contains(window_center):
                return True

        self._logger.warning("Window is off-screen")
        return False

    def _center_on_screen(self) -> None:
        """Center window on primary screen."""
        screen = QApplication.primaryScreen()
        screen_geometry = screen.availableGeometry()

        window_geometry = self.frameGeometry()
        center_point = screen_geometry.center()
        window_geometry.moveCenter(center_point)

        self.move(window_geometry.topLeft())
        self._logger.debug("Window centered on screen")

    def _save_geometry(self) -> None:
        """Save window geometry to settings."""
        try:
            geometry_bytes = self.saveGeometry()
            self._settings.set("window/geometry", geometry_bytes)
            self._logger.info("Window geometry saved")
        except Exception as e:
            self._logger.warning(f"Failed to save window geometry: {e}")

    def closeEvent(self, event: QCloseEvent) -> None:
        """Handle window close event.

        Args:
            event: Close event
        """
        self._logger.debug("Window closing, saving geometry")
        self._save_geometry()

        # Call parent implementation
        super().closeEvent(event)
```

### SettingsService Integration
```python
# In SettingsService (E01-F02)
class SettingsService:
    def get(self, key: str) -> Any:
        """Get setting value."""
        return self._settings.value(key)

    def set(self, key: str, value: Any) -> None:
        """Set setting value."""
        self._settings.setValue(key, value)
        self._settings.sync()
```

## Success Criteria

### Acceptance Criteria
- [ ] Window geometry saved on application close
- [ ] Window geometry restored on application startup
- [ ] Default geometry used on first launch
- [ ] Window centered on screen when using defaults
- [ ] Invalid geometry detected and handled gracefully
- [ ] Off-screen windows re-centered on primary screen
- [ ] Multi-monitor configurations handled correctly
- [ ] Geometry restoration completes in < 100ms
- [ ] No exceptions thrown during geometry operations

### Definition of Done
- [ ] Code reviewed and approved
- [ ] Unit tests passing with 80%+ coverage
  - [ ] Test first launch (no saved geometry)
  - [ ] Test geometry restoration
  - [ ] Test geometry saving
  - [ ] Test invalid geometry handling
  - [ ] Test off-screen window detection
  - [ ] Test multi-monitor scenarios
- [ ] Manual testing on different screen configurations
- [ ] Code follows PEP 8 style guidelines
- [ ] Docstrings complete for all methods

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| Restored geometry places window off-screen | Medium | Medium | Validate geometry, fall back to centered defaults |
| SettingsService not available at startup | Low | High | Handle gracefully, use defaults if settings unavailable |
| Geometry corruption in settings file | Low | Medium | Validate geometry data, clear corrupt settings |
| Multi-monitor changes between sessions | Medium | Low | Validate against current screen config, re-center if needed |

## Notes and Clarifications

### Design Decisions
- 2025-12-28: Use QWidget.saveGeometry()/restoreGeometry() for robust, Qt-native persistence
- 2025-12-28: Validate geometry on restore to handle monitor disconnection gracefully
- 2025-12-28: Save geometry in closeEvent to ensure it's always saved, even on abnormal shutdown

### Implementation Notes
- QSettings automatically handles QByteArray serialization
- Window state (maximized, etc.) can be added later if needed
- Consider adding user preference to reset window geometry in Settings view

### Platform Considerations
- Windows: Geometry includes window decorations (title bar, borders)
- macOS: Geometry may differ due to unified title/toolbar
- Linux: Depends on window manager, test on major DEs (GNOME, KDE)

---
*Template Version: 2.0.0 - Task Level Spec*
