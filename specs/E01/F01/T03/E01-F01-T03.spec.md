# Spec: E01-F01-T03 - Implement view registration and switching

---
# ============================================================================
# SPEC METADATA
# ============================================================================

# === IDENTIFICATION ===
id: E01-F01-T03
clickup_task_id: '86ew0209j'
title: Implement view registration and switching
type: task

# === HIERARCHY ===
parent: E01-F01
children: []
epic: E01
feature: F01
task: T03
domain: application-framework

# === WORKFLOW ===
status: draft
priority: high

# === TRACKING ===
created: '2025-12-28'
updated: '2025-12-28'
due_date: ''
estimated_hours: 4
actual_hours: 0

# === METADATA ===
tags: [ui, pyside6, navigation, integration, signals]
effort: medium
risk: medium
parallel: false
---

**Status**: Draft
**Type**: Task
**Parent**: E01-F01 (Main Window & Navigation)
**Created**: 2025-12-28
**Updated**: 2025-12-28
**Dependencies**: T01 (MainWindow skeleton), T02 (NavigationBar widget)

## Executive Summary

Integrate the NavigationBar widget into MainWindow and implement the complete view registration and switching mechanism. Connect NavigationBar signals to MainWindow slots, synchronize navigation state between components, and ensure smooth view transitions. This task brings together T01 and T02 to create a fully functional navigation system.

## Execution Flow

```
1. Integrate NavigationBar into MainWindow layout
   → Create NavigationBar instance in MainWindow.__init__()
   → Modify MainWindow layout to include sidebar area
   → Create QHBoxLayout combining NavigationBar and QStackedWidget
   → Set QHBoxLayout as central widget layout

2. Connect NavigationBar signals to MainWindow slots
   → Connect navigation_requested signal to _on_navigation_requested slot
   → Log signal connection for debugging

3. Enhance register_view() method
   → Accept optional metadata: display_name, icon
   → Register view in MainWindow._views registry
   → Add widget to QStackedWidget
   → Configure corresponding NavigationBar button (if exists)
   → Log successful registration with metadata

4. Implement _on_navigation_requested slot
   → Validate view_id exists in registry
   → If not found: Log error, show error message to user
   → Call _perform_view_switch(view_id)
   → Update NavigationBar active state
   → Log navigation event

5. Implement _perform_view_switch method
   → Get current widget from QStackedWidget
   → Call onDeactivate() lifecycle hook if widget supports it
   → Switch QStackedWidget to target view
   → Call onActivate() lifecycle hook if widget supports it
   → Measure and log switch duration
   → If switch takes > 100ms: WARN "Slow view switch detected"

6. Implement view lifecycle hooks support
   → Define optional interface: ViewLifecycle
     - onActivate() -> None: Called when view becomes active
     - onDeactivate() -> None: Called when view becomes inactive
   → Check if widget implements interface before calling

7. Synchronize navigation state
   → After successful switch: Call NavigationBar.set_active_view(view_id)
   → Ensure visual state matches actual state
   → Handle edge cases (view registration after navigation bar created)

8. Implement initial view navigation
   → In MainWindow.show() or after all views registered:
   → Navigate to default view (typically "dashboard")
   → Set corresponding button as active in NavigationBar
```

## User Stories

### Primary User Story
**As a** trader
**I want to** click navigation buttons and instantly see the corresponding view
**So that** I can efficiently switch between different application features

### Additional Stories
- **As a** developer, **I want to** register views with a simple API, **So that** I can easily add new features to the application
- **As a** trader, **I want to** view switches to complete quickly (< 100ms), **So that** the application feels responsive

## Acceptance Scenarios

### Scenario 1: Happy Path - View Registration and Switching
**Given** MainWindow is initialized with NavigationBar integrated
**When** a view is registered with register_view("scanner", scanner_widget)
**Then** the view should be added to QStackedWidget
**And** when the user clicks "Scanner" in NavigationBar
**Then** the navigation_requested signal should be emitted
**And** MainWindow should receive the signal
**And** the QStackedWidget should switch to scanner_widget
**And** the Scanner button should be highlighted
**And** the switch should complete in < 100ms

### Scenario 2: Lifecycle Hooks Called
**Given** a view widget implements ViewLifecycle interface
**When** navigating away from the view
**Then** the view's onDeactivate() method should be called
**And** when navigating to the view
**Then** the view's onActivate() method should be called

### Scenario 3: State Synchronization
**Given** MainWindow has multiple views registered
**When** the user clicks "Dashboard", then "Scanner", then "Dashboard" again
**Then** each navigation should update both QStackedWidget and NavigationBar
**And** the highlighted button should always match the displayed view
**And** no state desynchronization should occur

### Scenario 4: Error Case - Invalid View Navigation
**Given** MainWindow has only "dashboard" view registered
**When** internal code attempts to navigate to "nonexistent" view
**Then** an error should be logged
**And** the current view should remain displayed
**And** the NavigationBar highlighting should not change
**And** no exception should be raised

## Requirements

### Functional Requirements
- **FR-001**: MainWindow MUST integrate NavigationBar into layout
- **FR-002**: MainWindow MUST connect NavigationBar.navigation_requested to handler
- **FR-003**: MainWindow MUST switch views when navigation signal received
- **FR-004**: MainWindow MUST synchronize NavigationBar active state with displayed view
- **FR-005**: MainWindow MUST support optional view lifecycle hooks (onActivate, onDeactivate)
- **FR-006**: MainWindow MUST validate view_id before navigation
- **FR-007**: MainWindow MUST log all navigation events

### Non-Functional Requirements
- **NFR-001**: Performance: View switching MUST complete in < 100ms
- **NFR-002**: Performance: View switch latency MUST be logged if > 100ms
- **NFR-003**: Reliability: Navigation state MUST remain synchronized at all times
- **NFR-004**: Usability: Navigation errors MUST not crash the application

### Technical Constraints
- **TC-001**: Must use Qt Signal/Slot mechanism for navigation events
- **TC-002**: Must maintain single source of truth for active view state
- **TC-003**: Must support views that don't implement lifecycle hooks
- **TC-004**: Must measure view switch performance

## Key Entities

### Entity: MainWindow (Enhanced)
- **Description**: Main window with integrated navigation
- **New Attributes**:
  - `_nav_bar: NavigationBar` - Navigation sidebar widget
- **Enhanced Methods**:
  - `register_view(view_id: str, widget: QWidget, display_name: str = "") -> None`
  - `_on_navigation_requested(view_id: str) -> None` - Signal handler
  - `_perform_view_switch(view_id: str) -> bool` - Core switching logic

### Entity: ViewLifecycle (Interface)
- **Description**: Optional interface for view widgets
- **Methods**:
  - `onActivate() -> None` - Called when view becomes visible
  - `onDeactivate() -> None` - Called when view becomes hidden

## Dependencies

### Upstream Dependencies
- [ ] T01: MainWindow skeleton with QStackedWidget (REQUIRED)
- [ ] T02: NavigationBar widget (REQUIRED)

### Downstream Impact
- [ ] T05: Will use the integrated navigation system
- [ ] All feature views: Will register themselves using this mechanism

## Implementation Details

### File Structure
```
src/presentation/main_window.py (modified)
src/presentation/view_lifecycle.py (new - interface)
tests/unit/presentation/test_main_window_navigation.py
tests/integration/test_view_switching.py
```

### Code Skeleton
```python
# view_lifecycle.py
from typing import Protocol

class ViewLifecycle(Protocol):
    """Optional interface for view lifecycle management."""

    def onActivate(self) -> None:
        """Called when view becomes active."""
        ...

    def onDeactivate(self) -> None:
        """Called when view becomes inactive."""
        ...

# main_window.py (enhanced)
from PySide6.QtWidgets import QMainWindow, QStackedWidget, QWidget, QHBoxLayout
from PySide6.QtCore import Slot
from typing import Dict
import time

class MainWindow(QMainWindow):
    """Main application window with integrated navigation."""

    def __init__(self, settings: SettingsService, logger: Logger):
        """Initialize main window."""
        super().__init__()
        self._settings = settings
        self._logger = logger
        self._stack = QStackedWidget()
        self._views: Dict[str, QWidget] = {}
        self._nav_bar = NavigationBar()

        self._setup_ui()
        self._connect_signals()

    def _setup_ui(self) -> None:
        """Setup the user interface."""
        # Create main layout
        central_widget = QWidget()
        layout = QHBoxLayout(central_widget)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # Add navigation bar and stack
        layout.addWidget(self._nav_bar)
        layout.addWidget(self._stack)

        self.setCentralWidget(central_widget)

        # Set window properties
        self.setWindowTitle("JTS Trading Platform")
        self.resize(1280, 800)
        self.setMinimumSize(800, 600)

        self._logger.info("MainWindow UI setup complete")

    def _connect_signals(self) -> None:
        """Connect signals and slots."""
        self._nav_bar.navigation_requested.connect(self._on_navigation_requested)
        self._logger.debug("Navigation signals connected")

    def register_view(self, view_id: str, widget: QWidget,
                     display_name: str = "") -> None:
        """Register a view widget.

        Args:
            view_id: Unique identifier for the view
            widget: Widget to register
            display_name: Display name for logging (optional)

        Raises:
            ValueError: If view_id already exists
        """
        if view_id in self._views:
            raise ValueError(f"View {view_id} already registered")

        self._views[view_id] = widget
        self._stack.addWidget(widget)

        name = display_name or view_id
        self._logger.info(f"Registered view: {name} ({view_id})")

    @Slot(str)
    def _on_navigation_requested(self, view_id: str) -> None:
        """Handle navigation request from NavigationBar.

        Args:
            view_id: ID of view to navigate to
        """
        self._logger.debug(f"Navigation requested: {view_id}")

        if view_id not in self._views:
            self._logger.error(f"View {view_id} not found")
            return

        success = self._perform_view_switch(view_id)

        if success:
            # Synchronize NavigationBar state
            self._nav_bar.set_active_view(view_id)

    def _perform_view_switch(self, view_id: str) -> bool:
        """Perform the actual view switch.

        Args:
            view_id: ID of view to switch to

        Returns:
            True if switch successful, False otherwise
        """
        start_time = time.perf_counter()

        # Get current and target widgets
        current_widget = self._stack.currentWidget()
        target_widget = self._views[view_id]

        # Call lifecycle hooks
        if hasattr(current_widget, 'onDeactivate'):
            current_widget.onDeactivate()

        # Perform switch
        self._stack.setCurrentWidget(target_widget)

        if hasattr(target_widget, 'onActivate'):
            target_widget.onActivate()

        # Measure performance
        duration_ms = (time.perf_counter() - start_time) * 1000

        if duration_ms > 100:
            self._logger.warning(f"Slow view switch to {view_id}: {duration_ms:.2f}ms")
        else:
            self._logger.debug(f"Switched to {view_id} in {duration_ms:.2f}ms")

        return True

    def navigate_to(self, view_id: str) -> bool:
        """Navigate to a view programmatically.

        Args:
            view_id: ID of view to navigate to

        Returns:
            True if navigation successful, False otherwise
        """
        if view_id not in self._views:
            self._logger.error(f"View {view_id} not found")
            return False

        success = self._perform_view_switch(view_id)

        if success:
            self._nav_bar.set_active_view(view_id)

        return success
```

## Success Criteria

### Acceptance Criteria
- [ ] NavigationBar integrated into MainWindow layout
- [ ] Navigation signal connected to MainWindow handler
- [ ] Clicking navigation button switches QStackedWidget view
- [ ] NavigationBar highlighting synchronized with displayed view
- [ ] View lifecycle hooks called when supported
- [ ] Navigation to unregistered view handled gracefully
- [ ] View switch duration measured and logged
- [ ] Slow view switches (> 100ms) generate warnings
- [ ] State remains synchronized across all navigation paths

### Definition of Done
- [ ] Code reviewed and approved
- [ ] Unit tests passing with 80%+ coverage
  - [ ] Test NavigationBar integration
  - [ ] Test signal/slot connection
  - [ ] Test view switching logic
  - [ ] Test lifecycle hook calls
  - [ ] Test state synchronization
  - [ ] Test error handling for invalid views
- [ ] Integration tests passing
  - [ ] End-to-end navigation flow test
  - [ ] Multiple sequential navigations test
  - [ ] Navigation state consistency test
- [ ] Performance verified (< 100ms view switches)
- [ ] Code follows PEP 8 style guidelines

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| State desynchronization between NavigationBar and QStackedWidget | Medium | High | Use single source of truth, validate state consistency, add unit tests |
| Signal/slot connection failures | Low | High | Add connection validation, log connection status, test thoroughly |
| Slow view switches degrade UX | Medium | Medium | Measure performance, log slow switches, optimize heavy views |
| Lifecycle hooks called in wrong order | Low | Medium | Document call order, add debug logging, test with mock views |

## Notes and Clarifications

### Design Decisions
- 2025-12-28: Use optional ViewLifecycle interface instead of required base class for flexibility
- 2025-12-28: Measure view switch performance to identify bottlenecks early
- 2025-12-28: Synchronize state after switch completes to ensure consistency

### Implementation Notes
- View widgets should be lightweight and load data lazily to ensure fast switches
- Consider adding loading indicator for slow-loading views in future enhancement
- ViewLifecycle hooks can be used for pausing/resuming data streams

---
*Template Version: 2.0.0 - Task Level Spec*
