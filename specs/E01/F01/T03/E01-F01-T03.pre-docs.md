# Pre-Implementation Planning: View Registration and Switching Integration

**Task ID**: E01-F01-T03
**Title**: Implement view registration and switching
**Estimated Effort**: 4 hours
**Reading Time**: 12-15 minutes

---

## 1. Problem & Context

### Clear Problem Statement
We have two isolated components (MainWindow with QStackedWidget from T01, NavigationBar from T02) that need to work together. The missing piece is the wiring that connects navigation button clicks to actual view switches, with proper state synchronization and lifecycle management.

### Business Impact
- **Feature Completion**: Enables actual navigation functionality for traders
- **System Integration**: Brings together all navigation components into working system
- **Quality Foundation**: Proper lifecycle hooks enable clean view activation/deactivation

### Current Pain Points

| Issue | Impact | Frequency |
|-------|--------|-----------|
| NavigationBar and MainWindow are disconnected | Navigation buttons do nothing | Blocking |
| No signal/slot connection exists | Button clicks don't trigger view changes | Blocking |
| State can desynchronize | Active button might not match visible view | High risk |
| No view lifecycle management | Can't pause/resume data streams on view switch | Medium |

### Success Metrics
- [x] Button click switches QStackedWidget to correct view
- [x] Active button highlighting matches displayed view
- [x] View switch completes in < 100ms
- [x] Lifecycle hooks called in correct order
- [x] State synchronized across all navigation paths
- [x] Invalid navigation handled gracefully (no crashes)

---

## 2. Conceptual Solution

### Core Architecture

Think of this integration as a **symphony conductor**:
- Musicians (views) are ready to play
- Conductor (MainWindow) coordinates when each plays
- Audience requests (NavigationBar signals) tell conductor what to play
- Conductor ensures smooth transitions between pieces

```
User Click Flow:

User clicks "Scanner" button
         ↓
NavigationBar emits signal: navigation_requested("scanner")
         ↓
MainWindow receives signal: _on_navigation_requested("scanner")
         ↓
MainWindow validates "scanner" is registered
         ↓
MainWindow performs view switch
    ├─ Call current view.onDeactivate() if exists
    ├─ Switch QStackedWidget to scanner
    └─ Call scanner.onActivate() if exists
         ↓
MainWindow updates NavigationBar: set_active_view("scanner")
         ↓
Scanner button highlights, old button unhighlights
```

### Key Concepts Explained

#### Signal/Slot Connection: The Telephone System

**Real-World Analogy**: Think of an old office intercom system:
- NavigationBar presses intercom button (emits signal)
- Wire connects intercom to MainWindow's phone (signal/slot connection)
- MainWindow's phone rings (slot is called)
- MainWindow picks up and acts on the message

**Connection Setup**:
```python
# This is like running a wire from NavigationBar to MainWindow
self._nav_bar.navigation_requested.connect(self._on_navigation_requested)

# Now when NavigationBar emits:
self.navigation_requested.emit("scanner")

# MainWindow's method automatically gets called:
def _on_navigation_requested(self, view_id: str):
    # Handle the message
```

**Why This Pattern?**

| Benefit | Description | Example |
|---------|-------------|---------|
| **Loose Coupling** | Components don't reference each other directly | NavigationBar doesn't import MainWindow |
| **Testability** | Can test signal emission separately from handling | Mock slot to verify signal emitted |
| **Flexibility** | Can connect multiple slots to one signal | Log navigation + switch view |
| **Qt Integration** | Works seamlessly with Qt's event system | Automatic thread-safe delivery |

#### State Synchronization: The Single Source of Truth

**Problem**: Two places track active view:
1. NavigationBar: Which button is highlighted
2. QStackedWidget: Which widget is visible

**Solution**: MainWindow is the authority:
```
Truth Flow:
MainWindow decides to switch view
    ↓
MainWindow switches QStackedWidget (visual truth)
    ↓
MainWindow tells NavigationBar to update (button truth)
    ↓
Both now synchronized ✓
```

**Before/After Comparison**:

| Scenario | Bad Approach | Good Approach |
|----------|-------------|---------------|
| Button Click | NavigationBar updates itself, emits signal, MainWindow switches view | NavigationBar emits signal, MainWindow switches view AND updates NavigationBar |
| Programmatic Navigation | MainWindow switches view, might forget to update NavigationBar | MainWindow switches view, always updates NavigationBar (enforced in code) |
| Result | Desync possible | Always synchronized |

#### View Lifecycle Hooks: The Stage Manager

**Real-World Analogy**: Theater stage transitions:
- **onDeactivate**: Actor exits stage, lights dim
- Stage rotates to new scene
- **onActivate**: New actor enters, lights up

**Optional Interface Pattern**:
```python
# Views CAN implement this, but don't have to
class ViewLifecycle(Protocol):
    def onActivate(self) -> None:
        """Called when view becomes visible"""
        pass

    def onDeactivate(self) -> None:
        """Called when view becomes hidden"""
        pass

# Check if view implements the interface:
if hasattr(widget, 'onActivate'):
    widget.onActivate()
```

**Use Cases**:
```
Dashboard View:
  onActivate → Start live price updates
  onDeactivate → Pause price updates (save CPU)

Scanner View:
  onActivate → Resume scan engine
  onDeactivate → Pause scan engine

Data Collection View:
  onActivate → Show real-time connection status
  onDeactivate → Nothing (keep collecting in background)
```

**Why Optional?**

- Simple views (Settings page) don't need lifecycle management
- Don't force every view to implement unused methods
- Views can opt-in to lifecycle management as needed

### Component Integration Map

```
┌─────────────────────────────────────────────────┐
│                  MainWindow                     │
│                                                 │
│  ┌──────────────┐         ┌─────────────────┐  │
│  │              │ signal  │                 │  │
│  │ NavigationBar├────────►│ _on_navigation_ │  │
│  │              │         │   requested()   │  │
│  └──────────────┘         └────────┬────────┘  │
│                                    │            │
│                                    ↓            │
│                           _perform_view_switch  │
│                                    │            │
│  ┌─────────────────────────────────┼─────────┐ │
│  │      QStackedWidget             ↓         │ │
│  │   ┌──────────────┐  ┌──────────────┐     │ │
│  │   │ View 1       │  │ View 2       │     │ │
│  │   │ onDeactivate │  │ onActivate   │     │ │
│  │   └──────────────┘  └──────────────┘     │ │
│  └─────────────────────────────────────────┘ │
│                                               │
│  [State Sync] set_active_view()               │
│          │                                     │
│          └─────────────┐                      │
└────────────────────────┼──────────────────────┘
                         ↓
                  NavigationBar
                  (button highlight)
```

---

## 3. Technical Approach

### Strategy Overview

**Problem**: Need to integrate NavigationBar and MainWindow so button clicks switch views with synchronized state.

**Solution**: Use Qt's Signal/Slot mechanism to connect components, implement centralized view switching with lifecycle hooks, and enforce state synchronization after every switch.

### Design Decisions

| Decision | Chosen Approach | Why? | Alternatives Rejected |
|----------|----------------|------|----------------------|
| **Signal Connection** | Connect in `_connect_signals()` method | **Reasoning**: Centralized connection setup makes signal flow visible and debuggable. All connections in one place for maintenance. Easy to log connection status for troubleshooting. <br><br>**Problem/Solution**: Signal/slot connections are invisible in code. Centralizing them in one method makes the wiring explicit and documentable. <br><br>**Trade-offs**: Extra method vs inline connection. But clarity and maintainability win over brevity. <br><br>**Example**: `_connect_signals()` clearly shows NavigationBar → MainWindow connection. Developer knows where to look for all connections. | **Inline in `__init__`**: Clutters initialization logic, hard to find connections later. <br><br>**Lazy connection**: Connect on first use. Complex, can miss connections, harder to debug. |
| **View Switch Logic** | Separate `_perform_view_switch()` method | **Reasoning**: Single Responsibility Principle—one method does view switching. Can be called from multiple places (signal handler, programmatic navigation). Easy to test and measure performance. <br><br>**Problem/Solution**: View switching has multiple steps (deactivate, switch, activate, measure). Separate method encapsulates this complexity and allows reuse. <br><br>**Trade-offs**: Extra method call overhead (~1μs) vs code clarity. Performance impact negligible, clarity critical. <br><br>**Example**: Both `_on_navigation_requested()` and `navigate_to()` call same `_perform_view_switch()`. Single place to add logging, timing, error handling. | **Inline in signal handler**: Duplicated code if we add programmatic navigation. Hard to test. <br><br>**Multiple methods**: One per view? Explosion of methods, violates DRY. |
| **State Sync** | Always call `set_active_view()` after switch | **Reasoning**: Enforced synchronization prevents state drift. Every navigation path must sync state—no way to forget. Simple rule: "switch then sync" always. <br><br>**Problem/Solution**: Easy to forget to update NavigationBar after programmatic navigation. Making it part of the switch flow guarantees consistency. <br><br>**Trade-offs**: Slight coupling to NavigationBar. But worth it to prevent hard-to-debug state desync issues. <br><br>**Example**: Both signal-based and programmatic navigation execute same code path: `_perform_view_switch()` → `set_active_view()`. Impossible to desync. | **Manual sync**: Developer must remember to call `set_active_view()`. Easy to forget, causes bugs. <br><br>**NavigationBar auto-sync**: Would need reverse connection (MainWindow → NavigationBar signal). More complex, bidirectional coupling. |
| **Lifecycle Hooks** | Optional Protocol interface | **Reasoning**: Flexibility for views that need lifecycle management without forcing it on all views. Python's `hasattr()` provides clean optional interface checking. Views opt-in to complexity only if needed. <br><br>**Problem/Solution**: Some views need to start/stop data streams on activate/deactivate. Others don't care. Optional interface lets each view decide. <br><br>**Trade-offs**: Runtime check (`hasattr`) vs compile-time interface. But Python doesn't have compile-time interfaces anyway, and runtime check is fast (<1μs). <br><br>**Example**: Simple Settings view has no lifecycle methods—works fine. Complex Dashboard implements both—gets lifecycle callbacks. | **Required base class**: Forces all views to extend base class. Rigid, limits view design freedom. <br><br>**Always call methods**: Would need stub implementations in every view. Boilerplate noise. <br><br>**Separate registration**: `register_with_lifecycle()` vs `register()`. API complexity, easy to use wrong one. |
| **Performance Monitoring** | Measure and log switch duration | **Reasoning**: Proactive performance monitoring catches slow views early. Logging slow switches (>100ms) helps identify bottlenecks before users complain. Hard numbers beat assumptions. <br><br>**Problem/Solution**: View switches should be instant (<100ms per NFR). Measuring every switch detects slow views immediately during development. <br><br>**Trade-offs**: Small overhead of timing (~10μs). Worth it to catch 100ms+ slow switches. Logging has minimal impact. <br><br>**Example**: Switch takes 150ms → Warning logged with view_id → Developer optimizes before release. | **No monitoring**: Slow switches discovered by user complaints after release. <br><br>**Separate profiling**: Only measure during performance testing. Misses real-world slowness. |

### Pseudocode

```
WHEN MainWindow._setup_ui() completes:
  CREATE NavigationBar instance
  CREATE QHBoxLayout with NavigationBar + QStackedWidget
  SET as central widget


WHEN MainWindow._connect_signals() is called:
  CONNECT _nav_bar.navigation_requested TO _on_navigation_requested
  LOG "Navigation signals connected"


WHEN _on_navigation_requested(view_id) is called:
  LOG DEBUG "Navigation requested: {view_id}"

  IF view_id NOT in _views registry:
    LOG ERROR "View {view_id} not found"
    RETURN  # Invalid view, do nothing

  SUCCESS = _perform_view_switch(view_id)

  IF SUCCESS:
    CALL _nav_bar.set_active_view(view_id)  # Sync state


WHEN _perform_view_switch(view_id) is called:
  START timer

  GET current_widget from QStackedWidget
  GET target_widget from _views[view_id]

  IF current_widget has onDeactivate method:
    CALL current_widget.onDeactivate()

  SWITCH QStackedWidget to target_widget

  IF target_widget has onActivate method:
    CALL target_widget.onActivate()

  MEASURE duration

  IF duration > 100ms:
    LOG WARNING "Slow view switch: {view_id} took {duration}ms"
  ELSE:
    LOG DEBUG "Switched to {view_id} in {duration}ms"

  RETURN True


WHEN navigate_to(view_id) is called (programmatic):
  IF view_id NOT in _views:
    LOG ERROR "View {view_id} not found"
    RETURN False

  SUCCESS = _perform_view_switch(view_id)

  IF SUCCESS:
    CALL _nav_bar.set_active_view(view_id)  # Sync state

  RETURN SUCCESS
```

---

## 4. Implementation Strategy

### Development Phases

```
Phase 1: Layout Integration (45 min)
├─ Modify _setup_ui to create QHBoxLayout
├─ Create NavigationBar instance
├─ Add NavigationBar and QStackedWidget to layout
└─ Test visual appearance

Phase 2: Signal Connection (30 min)
├─ Create _connect_signals method
├─ Connect navigation_requested signal
├─ Add connection logging
└─ Test signal fires on button click

Phase 3: Core Switching (60 min)
├─ Implement _on_navigation_requested
├─ Implement _perform_view_switch
├─ Add performance timing
├─ Test view switching works

Phase 4: Lifecycle Hooks (45 min)
├─ Create view_lifecycle.py Protocol
├─ Add hasattr checks in _perform_view_switch
├─ Test with mock views
└─ Document lifecycle interface

Phase 5: State Sync (30 min)
├─ Add set_active_view calls after switches
├─ Test state synchronization
├─ Test programmatic navigation
└─ Verify no desync possible

Phase 6: Testing (30 min)
├─ Write unit tests
├─ Write integration tests
├─ Manual testing
└─ Performance verification
```

### Integration Points

```
Dependencies:
  T01 (MainWindow skeleton) ─┐
                             ├──► T03 (This task)
  T02 (NavigationBar)    ────┘

Components Modified:
  ├─ MainWindow (from T01)
  │  ├─ Add _nav_bar attribute
  │  ├─ Modify _setup_ui layout
  │  ├─ Add _connect_signals method
  │  ├─ Add _on_navigation_requested slot
  │  ├─ Add _perform_view_switch method
  │  └─ Enhance navigate_to method
  │
  └─ New Files Created:
     └─ view_lifecycle.py (Protocol definition)
```

### Risk Mitigation

| Risk | Probability | Impact | Mitigation Strategy |
|------|------------|--------|-------------------|
| State desynchronization between NavigationBar and QStackedWidget | Medium | High | **Strategy**: Enforce state sync in code structure. Every view switch MUST call `set_active_view()`. Use integration tests to verify state consistency. Add assertion checks in debug builds. **Detection**: Log both stack current index and nav bar active view on every switch. **Recovery**: If desync detected, log error and resync immediately. |
| Signal/slot connection fails silently | Low | High | **Strategy**: Add connection validation using Qt's connection return value. Log all connection attempts. Use QSignalSpy in tests to verify signals fire. **Detection**: No view switch on button click. **Recovery**: Check connection logs, verify signal signature matches slot signature exactly. |
| Slow view switches degrade UX | Medium | Medium | **Strategy**: Measure every switch, log slow ones. Set performance budget (100ms). Optimize heavy views (lazy load data, background threads). Add loading indicators for slow views. **Detection**: Warning logs for >100ms switches. **Recovery**: Profile slow view initialization, move heavy operations to background. |
| Lifecycle hooks called in wrong order | Low | Medium | **Strategy**: Document exact call order. Add logging to track sequence. Test with mock views that assert call order. **Detection**: Views behave incorrectly (e.g., try to update after deactivation). **Recovery**: Review and fix call sequence in _perform_view_switch. |
| Exception in lifecycle hook crashes app | Low | High | **Strategy**: Wrap lifecycle calls in try-except. Log exceptions but continue view switch. View switch should not fail due to buggy lifecycle implementation. **Detection**: View switch fails or app crashes. **Recovery**: Add exception handling, log error, continue operation. |

---

## 5. Expected Behavior & Scenarios

### User Stories

**Story 1: First Complete Navigation**
```
GIVEN: MainWindow is initialized with NavigationBar integrated
  AND: Dashboard and Scanner views are registered
WHEN:  User clicks "Scanner" button
THEN:  - navigation_requested("scanner") signal emitted
       - _on_navigation_requested("scanner") called
       - QStackedWidget switches to scanner view
       - Scanner button highlights in NavigationBar
       - Dashboard button unhighlights
       - Switch completes in < 100ms
       - No errors logged
```

**Story 2: Lifecycle Hooks Execution**
```
GIVEN: Dashboard view implements ViewLifecycle interface
  AND: Dashboard is currently displayed
WHEN:  User navigates to Scanner
THEN:  - Dashboard.onDeactivate() is called BEFORE switch
       - QStackedWidget switches to Scanner
       - Scanner.onActivate() is called AFTER switch (if implemented)
       - All calls complete successfully
```

**Story 3: Programmatic Navigation**
```
GIVEN: MainWindow has multiple views registered
WHEN:  Code calls mainwindow.navigate_to("settings")
THEN:  - View switches to Settings
       - Settings button highlights
       - Previous button unhighlights
       - State synchronized (same as user click)
       - Method returns True
```

**Story 4: Invalid View Handling**
```
GIVEN: MainWindow has views registered
WHEN:  Code calls navigate_to("nonexistent")
THEN:  - Error logged: "View nonexistent not found"
       - Current view remains displayed
       - NavigationBar highlighting unchanged
       - Method returns False
       - No exception raised
```

### Edge Cases

| Case | Expected Behavior |
|------|------------------|
| Navigate to current view | Switch happens, but visually no change. Lifecycle hooks still called. |
| Lifecycle hook raises exception | Exception caught and logged, view switch completes anyway |
| Multiple rapid button clicks | All clicks processed, last one wins, state consistent |
| Navigate before any views registered | Error logged, returns False, no crash |
| NavigationBar.set_active_view during programmatic navigation | State stays consistent (set_active_view called after switch) |

### Performance Expectations

**Time Budget**:
```
View Switch Complete Flow:
├─ Signal emission:          < 5ms
├─ View validation:          < 1ms
├─ onDeactivate() call:      < 20ms (view-dependent)
├─ QStackedWidget switch:    < 5ms
├─ onActivate() call:        < 20ms (view-dependent)
├─ NavigationBar sync:       < 5ms
├─ Logging:                  < 1ms
└─ Total:                    < 60ms ✓ (well under 100ms target)

Critical Path (user-visible delay):
├─ Button click to visual change: < 50ms
└─ Visual change to fully loaded: < 100ms total
```

---

## 6. Testing Strategy

### Coverage Pyramid

```
        /\
       /E2E\       2 tests: Full navigation flow, state consistency
      /------\
     /  INT  \     4 tests: Signal connections, lifecycle hooks
    /----------\
   /   UNIT    \  10 tests: All methods, edge cases, errors
  /──────────────\
```

### Key Scenarios

**Unit Tests** (10 scenarios):
- ✓ Test _connect_signals establishes connection
- ✓ Test _on_navigation_requested validates view_id
- ✓ Test _on_navigation_requested calls _perform_view_switch
- ✓ Test _perform_view_switch switches QStackedWidget
- ✓ Test _perform_view_switch calls onDeactivate if exists
- ✓ Test _perform_view_switch calls onActivate if exists
- ✓ Test _perform_view_switch logs slow switches (>100ms)
- ✓ Test navigate_to returns False for invalid view
- ✓ Test state sync after successful switch
- ✓ Test state unchanged after failed switch

**Integration Tests** (4 scenarios):
- ✓ Test NavigationBar signal → MainWindow slot connection
- ✓ Test complete navigation flow (button click → view switch)
- ✓ Test lifecycle hooks called in correct order
- ✓ Test state consistency across multiple navigations

**End-to-End Tests** (2 scenarios):
- ✓ Test full user journey: Launch → Register views → Navigate
- ✓ Test state synchronization: Button highlighting matches visible view

### Validation Approach

**Testing Pattern**: Mock views with lifecycle tracking

```python
class MockView(QWidget):
    def __init__(self):
        super().__init__()
        self.activated = False
        self.deactivated = False

    def onActivate(self):
        self.activated = True

    def onDeactivate(self):
        self.deactivated = True

def test_lifecycle_hooks_called():
    # Setup
    main_window = MainWindow(settings, logger)
    view1 = MockView()
    view2 = MockView()
    main_window.register_view("view1", view1)
    main_window.register_view("view2", view2)

    # Navigate to view1
    main_window.navigate_to("view1")
    assert view1.activated is True

    # Navigate to view2
    main_window.navigate_to("view2")
    assert view1.deactivated is True  # Old view deactivated
    assert view2.activated is True     # New view activated
```

---

## Visual Reference

### Integration Architecture

```
┌─────────────────── MainWindow Layout ───────────────────┐
│                                                          │
│  ┌─────────────┐         ┌────────────────────────┐    │
│  │             │         │  QStackedWidget        │    │
│  │ Navigation  │         │  ┌──────────────────┐  │    │
│  │    Bar      │         │  │ Dashboard        │  │    │
│  │             │         │  │ (View 1)         │  │    │
│  │ • Dashboard │         │  └──────────────────┘  │    │
│  │ • Scanner ● │         │  ┌──────────────────┐  │    │
│  │ • Settings  │         │  │ Scanner          │  │    │
│  │             │         │  │ (View 2) VISIBLE │  │    │
│  └─────────────┘         │  └──────────────────┘  │    │
│       200px              │  ┌──────────────────┐  │    │
│                          │  │ Settings         │  │    │
│  Signal Flow:            │  │ (View 3)         │  │    │
│  Button Click            │  └──────────────────┘  │    │
│       ↓                  └────────────────────────┘    │
│  navigation_requested            ↑                     │
│       ↓                           │                     │
│  _on_navigation_requested    Switch widget             │
│       ↓                           │                     │
│  _perform_view_switch ────────────┘                    │
│       ↓                                                 │
│  set_active_view (sync state)                          │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### State Flow Diagram

```
[Button Clicked]
      ↓
[Signal Emitted] ──→ navigation_requested("scanner")
      ↓
[Signal Received] ──→ _on_navigation_requested()
      ↓
[Validate View] ──→ view_id in registry?
      │                    │
      NO                   YES
      ↓                    ↓
[Log Error]         [Perform Switch]
[Return]                  ↓
                    [Call onDeactivate]
                          ↓
                    [Switch QStackedWidget]
                          ↓
                    [Call onActivate]
                          ↓
                    [Measure Duration]
                          ↓
                    [Sync NavigationBar]
                          ↓
                    [Navigation Complete]
```

---

## Reading Checklist

After reading this document, you should be able to answer:

- [x] How does a button click result in a view switch?
- [x] What is the Signal/Slot pattern and how is it used here?
- [x] Why do we need state synchronization?
- [x] What are lifecycle hooks and when are they called?
- [x] How do we prevent state desynchronization?
- [x] What happens if a view switch is slow?

**Ready to implement?** Integration pattern clear, signal flow understood, lifecycle management defined.

---

*Document Type: Pre-Implementation Planning*
*Target Audience: Developers*
*Last Updated: 2025-12-28*
