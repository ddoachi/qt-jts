# Pre-Implementation Planning: StatusBar with Connection Indicators

**Task ID**: E01-F01-T04
**Title**: Add StatusBar with connection indicators
**Estimated Effort**: 4 hours
**Reading Time**: 10-12 minutes

---

## 1. Problem & Context

### Clear Problem Statement
Traders need continuous visibility into broker connection status (Interactive Brokers, Alpaca) and system state. Without visual indicators, traders might attempt trades while disconnected, leading to failures and frustration. System messages need a dedicated display area.

### Business Impact
- **Trading Safety**: Prevents trade attempts when disconnected
- **User Confidence**: Clear status reduces anxiety about connection state
- **System Transparency**: Visible messages improve troubleshooting

### Current Pain Points

| Issue | Impact | Frequency |
|-------|--------|-----------|
| No connection status visibility | Traders don't know if connected to brokers | Constant |
| No system message display | Users miss important notifications | High |
| No time reference | Hard to correlate events with timestamps | Medium |

### Success Metrics
- [x] Connection indicators visible at all times
- [x] Status updates appear within 50ms
- [x] Timestamp accurate to within 1 second
- [x] StatusBar doesn't resize or shift main content
- [x] Indicators color-coded for quick scanning

---

## 2. Conceptual Solution

### Core Architecture

Think of StatusBar as an **airplane cockpit instrument panel**:
- Critical indicators always visible (connection lights)
- Status messages like radio communications
- Clock for time reference
- Compact, bottom-of-screen placement

```
┌───────────────────── StatusBar (25px height) ─────────────────────┐
│                                                                    │
│  ●IB:Connected  ●Alpaca:Disconnected     Ready      14:32:15     │
│  └─Indicators─┘                      └─Message─┘  └─Clock─┘      │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
     Green          Gray                Center          Right
```

### Key Concepts Explained

#### Connection Indicators: The Traffic Light

**Real-World Analogy**: Like traffic lights or LED status indicators:
- **Green** = Connected (safe to proceed)
- **Gray** = Disconnected (do not proceed)
- Pill-shaped badges for modern appearance

**Visual Design**:
```
Disconnected State:
┌────────────────┐
│ ●IB: Disconnected │  Gray background, white text
└────────────────┘

Connected State:
┌────────────────┐
│ ●IB: Connected │  Green background, white text
└────────────────┘
```

**Why Pill Shape?**

| Reason | Benefit |
|--------|---------|
| Modern | Professional, contemporary look |
| Compact | Saves space in status bar |
| Clear | Easy to distinguish from background |
| Scannable | Color coding works at a glance |

#### Auto-Updating Timestamp: The Digital Clock

**Real-World Analogy**: Like a digital clock on a microwave or car dashboard—updates automatically every second without user action.

**How It Works**:
```
1. Create QTimer that fires every 1000ms (1 second)
2. Connect timer.timeout signal to _update_timestamp slot
3. In _update_timestamp:
   - Get current time from QDateTime
   - Format as "HH:MM:SS"
   - Update label text
4. Timer runs continuously while app is open
```

**Why QTimer?**

- Qt's built-in solution for periodic updates
- Automatically integrates with event loop
- Minimal CPU usage (fires once per second)
- Can be stopped/started easily

#### Temporary Messages: The Toast Notification

**Real-World Analogy**: Like notification banners that auto-dismiss:
- Show message: "Loading market data..."
- After 3 seconds, message clears
- Back to default "Ready" state

**Two Message Modes**:
```python
# Persistent (stays until cleared)
statusbar.show_message("Connected to TWS", duration=0)

# Temporary (auto-clears after 3 seconds)
statusbar.show_message("Data loaded", duration=3000)
```

**Implementation**: QTimer.singleShot for auto-clear:
```python
if duration > 0:
    QTimer.singleShot(duration, self.clear_message)
    # After 'duration' milliseconds, clear_message() called once
```

### Component Layout

```
QHBoxLayout (horizontal arrangement):

┌─────────────────────────────────────────────────────────┐
│ [IB Indicator] [Alpaca Indicator] [Spacer─────────]    │
│                                                          │
│    [Status Message Label (centered)]                     │
│                                                          │
│              [────────Spacer] [Timestamp Label]         │
└─────────────────────────────────────────────────────────┘
   Left side           Center              Right side

Spacers push content to left/center/right positions
```

---

## 3. Technical Approach

### Strategy Overview

**Problem**: Need a fixed-height status bar with connection indicators, messages, and timestamp.

**Solution**: Custom QWidget with QHBoxLayout, QLabel widgets for indicators/messages, QTimer for timestamp updates.

### Design Decisions

| Decision | Chosen Approach | Why? | Alternatives Rejected |
|----------|----------------|------|----------------------|
| **Base Widget** | Custom QWidget | **Reasoning**: Full control over layout, styling, and behavior. No unnecessary features from QStatusBar (like size grips we don't need). Clean implementation. <br><br>**Problem/Solution**: Qt's QStatusBar has built-in behaviors (size grip, message timeout) that conflict with our custom design. Custom QWidget gives clean slate. <br><br>**Trade-offs**: Must implement everything ourselves vs inheriting ready-made features. But we gain exact control over appearance and avoid fighting QStatusBar's opinions. <br><br>**Example**: Want exact 25px height. QStatusBar resizes based on content. QWidget with `setFixedHeight(25)` guarantees size. | **QStatusBar**: Built-in message timeout we can't customize. Size grip appears by default. Harder to add custom indicator widgets. <br><br>**QToolBar**: Wrong semantic meaning. Designed for tools, not status. |
| **Indicators** | QLabel with styled background | **Reasoning**: QLabel supports text + rich styling via stylesheets. Can dynamically update text and background color. Lightweight, no unnecessary features. <br><br>**Problem/Solution**: Need pill-shaped badges with text. QLabel with `border-radius: 10px` stylesheet creates pill shape. Changing `background-color` updates connection state. <br><br>**Trade-offs**: QLabel is read-only vs clickable button. But status indicators shouldn't be clickable (view-only), so perfect fit. <br><br>**Example**: `QLabel { background-color: #27ae60; border-radius: 10px; }` creates green pill. Update stylesheet to change color on disconnect. | **QPushButton**: Implies clickability we don't want. More complex than needed. <br><br>**Custom QWidget**: Overkill for simple text display. Would need to implement painting ourselves. |
| **Timestamp Update** | QTimer with 1000ms interval | **Reasoning**: Qt's standard solution for periodic updates. Integrates seamlessly with event loop. Minimal CPU usage. Easy to start/stop. <br><br>**Problem/Solution**: Need timestamp to update every second. QTimer fires timeout signal every 1000ms, we update label. Automatic, reliable, efficient. <br><br>**Trade-offs**: 1-second timer running continuously. But overhead is negligible (~0.01% CPU). Could update less frequently (every 5s), but users expect real-time clock. <br><br>**Example**: `timer.start(1000)` → fires every 1000ms → `_update_timestamp()` called → label updates with current time. | **Manual polling**: Would need background thread. Complex, error-prone. <br><br>**System timer events**: Lower-level, harder to manage than QTimer. |
| **Message Auto-Clear** | QTimer.singleShot | **Reasoning**: Qt's one-shot timer perfect for delayed actions. No need to manage timer lifecycle. Simpler than creating/destroying QTimer instances. <br><br>**Problem/Solution**: Show message, auto-clear after N milliseconds. `singleShot(N, callback)` does exactly this in one line. <br><br>**Trade-offs**: No way to cancel early if another message arrives (fires no matter what). But acceptable—new message just overwrites old one anyway. <br><br>**Example**: `QTimer.singleShot(3000, self.clear_message)` → after 3000ms, `clear_message()` called once. | **QTimer instance**: Must create, start, connect, delete timer. More code for same result. <br><br>**Threading.Timer**: Python's timer, but Qt events might not be thread-safe. QTimer guaranteed safe. |
| **Layout** | QHBoxLayout with spacers | **Reasoning**: QHBoxLayout naturally creates left-to-right arrangement. QSpacerItem with Expanding policy automatically fills space, pushing widgets to desired positions. Standard Qt pattern for flexible layouts. <br><br>**Problem/Solution**: Want indicators left, message center, timestamp right. Add widgets + spacers in order: `[indicators] [spacer] [message] [spacer] [timestamp]`. Spacers automatically adjust to window width. <br><br>**Trade-offs**: Spacers take minimal memory. But much simpler than calculating positions manually or using nested layouts. <br><br>**Example**: Window width 1280px → spacers automatically share extra space → message stays centered, timestamp stays right-aligned. | **Manual positioning**: Would need to recalculate on resize. Complex, error-prone. <br><br>**QGridLayout**: More complex than needed for single row. Harder to read code. |

### Pseudocode

```
WHEN StatusBar is created:
  CREATE QHBoxLayout with minimal margins
  SET spacing to 10px between widgets

  CREATE connection indicators:
    IB_indicator = create_indicator("IB: Disconnected", connected=False)
    Alpaca_indicator = create_indicator("Alpaca: Disconnected", connected=False)

  ADD IB_indicator to layout
  ADD Alpaca_indicator to layout

  ADD expanding spacer (pushes next items to center/right)

  CREATE status message label
  SET initial text to "Ready"
  APPLY text styling (color, font size)
  ADD to layout

  ADD expanding spacer (pushes timestamp to right)

  CREATE timestamp label
  APPLY text styling
  ADD to layout

  SET fixed height to 25px
  APPLY StatusBar background styling


WHEN create_indicator(text, connected) is called:
  CREATE QLabel with text
  SELECT color based on connected:
    IF connected: color = green (#27ae60)
    ELSE: color = gray (#95a5a6)

  APPLY stylesheet:
    - background-color: {color}
    - color: white
    - padding: 2px 8px
    - border-radius: 10px (pill shape)

  RETURN configured label


WHEN _start_timer() is called:
  CREATE QTimer instance
  CONNECT timeout signal to _update_timestamp slot
  START timer with 1000ms interval
  CALL _update_timestamp() immediately (don't wait 1 second)


WHEN _update_timestamp() is called:
  GET current time from QDateTime.currentDateTime()
  FORMAT as "HH:MM:SS" (24-hour format)
  UPDATE timestamp label text


WHEN set_ib_status(connected, message) is called:
  UPDATE indicator text:
    IF connected: "IB: Connected"
    ELSE: "IB: Disconnected"

  UPDATE indicator color:
    IF connected: green
    ELSE: gray

  IF message provided:
    SET tooltip to message

  LOG status change


WHEN show_message(message, duration) is called:
  UPDATE status label text to message

  IF duration > 0:
    SCHEDULE auto-clear after duration milliseconds
    USING QTimer.singleShot(duration, clear_message)


WHEN clear_message() is called:
  RESET status label text to "Ready"
```

---

## 4. Implementation Strategy

### Development Phases

```
Phase 1: Basic Structure (60 min)
├─ Create status_bar.py file
├─ Define StatusBar class
├─ Setup QHBoxLayout
├─ Apply basic styling
└─ Test visual appearance

Phase 2: Connection Indicators (60 min)
├─ Implement create_indicator method
├─ Create IB and Alpaca indicators
├─ Implement set_ib_status method
├─ Implement set_alpaca_status method
└─ Test status updates

Phase 3: Status Messages (30 min)
├─ Create status message label
├─ Implement show_message method
├─ Implement clear_message method
├─ Test auto-clear with duration
└─ Test persistent messages

Phase 4: Timestamp (45 min)
├─ Create timestamp label
├─ Implement _update_timestamp method
├─ Setup QTimer with 1-second interval
├─ Test timestamp accuracy
└─ Test visual formatting

Phase 5: Integration & Testing (45 min)
├─ Write unit tests
├─ Test all status update methods
├─ Test timer functionality
├─ Manual visual verification
└─ Cross-platform testing
```

### Integration Points

```
StatusBar Integration:

         StatusBar (standalone)
              │
              │ (Created by MainWindow in T03)
              ↓
         MainWindow adds to layout
              │
              │
              ├──────────────────────────────┐
              │                              │
         Connection Events            System Events
         (from E02/E03)              (from application)
              │                              │
              ↓                              ↓
         set_ib_status()              show_message()
         set_alpaca_status()
```

**External Dependencies**:
- `PySide6.QtWidgets.QWidget`: Base class
- `PySide6.QtWidgets.QLabel`: Indicators and messages
- `PySide6.QtCore.QTimer`: Timestamp updates
- `PySide6.QtCore.QDateTime`: Time formatting

**No Upstream Task Dependencies**: Can develop in parallel!

### Risk Mitigation

| Risk | Probability | Impact | Mitigation Strategy |
|------|------------|--------|-------------------|
| Timer stops updating timestamp | Low | Low | **Strategy**: Verify timer is started in init. Log timer start/stop events. Add unit test with QTest.qWait to verify updates. Check timer.isActive() status. **Detection**: Timestamp frozen. **Recovery**: Restart timer, add error logging. |
| Status updates lag or freeze UI | Low | Medium | **Strategy**: Keep update methods lightweight (just text/color changes). No heavy operations in update methods. Test with rapid status changes. Measure update duration in debug builds. **Detection**: Visual lag on status change. **Recovery**: Profile and optimize if needed. |
| Color scheme inconsistent across platforms | Medium | Low | **Strategy**: Use hex colors (#27ae60) instead of named colors. Test on Linux, macOS, Windows. Use Qt stylesheets which are platform-agnostic. Verify colors in different themes. **Detection**: Colors look different on different OS. **Recovery**: Adjust colors based on platform testing feedback. |
| Timestamp format ambiguous (AM/PM vs 24-hour) | Low | Low | **Strategy**: Use 24-hour format (HH:MM:SS) which is unambiguous. Standard in trading applications. Add format to tooltip if needed. **Detection**: User confusion about time. **Recovery**: Add AM/PM if requested, document format. |

---

## 5. Expected Behavior & Scenarios

### User Stories

**Story 1: Initial Display**
```
GIVEN: Application launches
WHEN:  MainWindow displays StatusBar
THEN:  - IB indicator shows "IB: Disconnected" (gray)
       - Alpaca indicator shows "Alpaca: Disconnected" (gray)
       - Status message shows "Ready"
       - Timestamp shows current time (e.g., "14:32:15")
       - StatusBar height is exactly 25px
       - Background is light gray with top border
```

**Story 2: Connection Established**
```
GIVEN: StatusBar showing both brokers disconnected
WHEN:  Connection established to Interactive Brokers
  AND: set_ib_status(True, "Connected to TWS") is called
THEN:  - IB indicator turns green
       - IB indicator text changes to "IB: Connected"
       - Tooltip shows "Connected to TWS"
       - Visual update appears within 50ms
       - Alpaca remains gray (unchanged)
```

**Story 3: Temporary Message**
```
GIVEN: StatusBar showing "Ready"
WHEN:  show_message("Loading market data...", duration=3000) is called
THEN:  - Status message immediately changes to "Loading market data..."
       - After 3 seconds, message automatically clears to "Ready"
       - No user action required
```

**Story 4: Timestamp Updates**
```
GIVEN: StatusBar is displayed
WHEN:  1 second elapses
THEN:  - Timestamp updates to new current time
       - Update is visible to user
       - Format remains "HH:MM:SS"
WHEN:  Another second elapses
THEN:  - Timestamp updates again
       - Continuous updates every second
```

### Edge Cases

| Case | Expected Behavior |
|------|------------------|
| Both brokers connected | Both indicators green, no interference between them |
| Rapid status changes (connect/disconnect) | All updates processed, last state wins, no visual glitches |
| Message longer than available space | Text truncates with ellipsis (...), tooltip shows full message |
| show_message called while auto-clear pending | New message overwrites old, new timer replaces old timer |
| Application idle for hours | Timestamp continues updating accurately, no drift |
| System time changes | Timestamp reflects new system time on next update (1s max delay) |

### Performance Expectations

**Time Budget**:
```
StatusBar Initialization:
├─ Widget creation:        < 20ms
├─ Layout setup:           < 10ms
├─ Styling application:    < 15ms
├─ Timer start:            < 5ms
└─ Total:                  < 50ms ✓

Status Update (set_ib_status):
├─ Text update:            < 5ms
├─ Color update:           < 10ms
├─ Tooltip update:         < 2ms
└─ Total:                  < 20ms ✓ (well under 50ms target)

Timestamp Update (every second):
├─ Get current time:       < 1ms
├─ Format string:          < 1ms
├─ Update label:           < 3ms
└─ Total:                  < 5ms ✓
```

---

## 6. Testing Strategy

### Coverage Pyramid

```
        /\
       /E2E\       1 test: StatusBar in full app
      /------\
     /  INT  \     2 tests: Timer updates, layout integration
    /----------\
   /   UNIT    \  8 tests: All methods, edge cases
  /──────────────\
```

### Key Scenarios

**Unit Tests** (8 scenarios):
- ✓ Test StatusBar initialization creates all widgets
- ✓ Test set_ib_status updates indicator color and text
- ✓ Test set_alpaca_status updates indicator color and text
- ✓ Test show_message updates status label
- ✓ Test show_message with duration auto-clears after timeout
- ✓ Test clear_message resets to "Ready"
- ✓ Test _update_timestamp formats time correctly
- ✓ Test timer fires and updates timestamp

**Integration Tests** (2 scenarios):
- ✓ Test timer updates timestamp every second (use QTest.qWait)
- ✓ Test StatusBar added to MainWindow layout correctly

**Manual Verification**:
- [ ] Visual appearance matches design on all platforms
- [ ] Colors are clearly distinguishable
- [ ] Text is readable at normal viewing distance
- [ ] Timestamp updates smoothly without flicker

### Validation Approach

**Testing Pattern**: Mock time for deterministic tests

```python
def test_timestamp_format():
    statusbar = StatusBar()

    # Mock current time
    with patch('PySide6.QtCore.QDateTime.currentDateTime') as mock_dt:
        mock_dt.return_value.toString.return_value = "14:32:15"

        statusbar._update_timestamp()

        assert statusbar._timestamp_label.text() == "14:32:15"
```

**Timer Testing**: Use QTest.qWait

```python
def test_auto_clear_message():
    statusbar = StatusBar()

    statusbar.show_message("Test", duration=1000)  # 1 second
    assert statusbar._status_label.text() == "Test"

    QTest.qWait(1100)  # Wait 1.1 seconds

    assert statusbar._status_label.text() == "Ready"
```

---

## Visual Reference

### Widget Layout

```
┌──────────── StatusBar (Fixed 25px height) ────────────┐
│                                                        │
│  ●IB:Connected  ●Alpaca:Disconnected                  │
│  └───────┬───────┘                                     │
│       QLabel with                                      │
│       border-radius:10px                               │
│                                                        │
│                     Status Message                     │
│                    └────┬─────┘                        │
│                      QLabel                            │
│                    (centered)                          │
│                                                        │
│                                          14:32:15      │
│                                         └───┬────┘     │
│                                          QLabel        │
│                                       (right-aligned)  │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### Color States

```
Connection Indicator States:

Disconnected:
┌──────────────────┐
│ ●IB: Disconnected │  Background: #95a5a6 (gray)
└──────────────────┘  Text: white

Connected:
┌──────────────────┐
│ ●IB: Connected    │  Background: #27ae60 (green)
└──────────────────┘  Text: white

Hover (future enhancement):
┌──────────────────┐
│ ●IB: Connected    │  Background: slightly darker
└──────────────────┘  Cursor: pointer (if clickable)
```

---

## Reading Checklist

After reading this document, you should be able to answer:

- [x] What information does StatusBar display?
- [x] How do connection indicators change appearance?
- [x] How does the timestamp stay updated?
- [x] What's the difference between persistent and temporary messages?
- [x] Why use QWidget instead of QStatusBar?
- [x] How does the layout keep widgets positioned correctly?

**Ready to implement?** Widget structure clear, styling approach defined, timer pattern understood.

---

*Document Type: Pre-Implementation Planning*
*Target Audience: Developers*
*Last Updated: 2025-12-28*
