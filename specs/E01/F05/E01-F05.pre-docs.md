# Pre-Implementation Docs: E01-F05 - Error Handling

**Feature**: Error Handling
**Spec ID**: E01-F05
**Created**: 2025-12-28
**Estimated Effort**: 8 hours
**Reading Time**: 12-15 minutes

---

## 1. Problem & Context

### Clear Problem Statement

**Problem**: Applications fail. When they do, users see cryptic error messages or the app crashes entirely, leading to frustration and lost work. Developers get bug reports with no useful information. We need a systematic way to handle errors gracefully.

**Example Without Error Handling**:
```python
def connect_to_broker():
    connection = broker_api.connect()  # Raises exception
    return connection  # âŒ App crashes, user sees Python traceback
```

**Example With Error Handling**:
```python
def connect_to_broker():
    try:
        connection = broker_api.connect()
        return connection
    except ConnectionError as e:
        # âœ… User sees: "ì¦ê¶Œì‚¬ ì—°ê²° ì‹¤íŒ¨. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”."
        # âœ… Developer sees: Full traceback in logs
        # âœ… App keeps running
        raise BrokerConnectionError(
            message=f"Failed to connect: {e}",
            user_message="ì¦ê¶Œì‚¬ ì—°ê²° ì‹¤íŒ¨. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.",
            recoverable=True
        )
```

### Business Impact

**Why This Matters**:
- **User Trust**: Crashes destroy confidence; graceful errors build trust
- **Productivity**: Users can continue working instead of restarting
- **Debugging**: Rich error context speeds up bug fixes
- **Professionalism**: Polished error handling separates quality software
- **Data Safety**: Graceful recovery prevents data loss

### Current Pain Points

| Issue | Impact | Frequency | Severity |
|-------|--------|-----------|----------|
| Unhandled exceptions crash app | User loses work, data | Every error | ğŸ”´ Critical |
| Python tracebacks shown to users | Confusion, unprofessional | Every error | ğŸ”´ High |
| No error logging | Can't debug production issues | Every error | ğŸ”´ High |
| Korean users see English errors | Language barrier | Every error | ğŸŸ¡ Medium |
| No recovery mechanism | Manual restart required | Common | ğŸŸ¡ Medium |

### Success Metrics

- âœ… Zero crashes from handled errors (app keeps running)
- âœ… 100% of errors logged with context and tracebacks
- âœ… User-friendly Korean error messages for all error types
- âœ… Error handling overhead < 10ms
- âœ… Automatic recovery for transient errors (network, etc.)
- âœ… Clear, actionable error messages (< 200 chars)

---

## 2. Conceptual Solution

### Core Architecture

Think of error handling like a **safety net** ğŸ—ï¸:
- **Application Code**: Trapeze artists (can fall)
- **Exception Classes**: Different types of falls (slip, miss, lose grip)
- **Error Handler**: The safety net (catches all falls)
- **Recovery Strategies**: Medics who help you back up
- **User Dialogs**: Announcer explaining what happened
- **Logs**: Incident reports for investigation

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          ERROR HANDLING ARCHITECTURE                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                     â”‚
â”‚  Application Code                                  â”‚
â”‚       â”‚                                             â”‚
â”‚       â”œâ”€â”€> Something fails                          â”‚
â”‚       â”‚    throw ApplicationError                   â”‚
â”‚       â”‚                                             â”‚
â”‚       â–¼                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚     Exception Hierarchy     â”‚                   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚                   â”‚
â”‚  â”‚  â”‚ ApplicationError     â”‚   â”‚ (Base)            â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚                   â”‚
â”‚  â”‚       â”‚                      â”‚                   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚                   â”‚
â”‚  â”‚  â”‚ ValidationError       â”‚  â”‚ (Specific types)  â”‚
â”‚  â”‚  â”‚ BrokerConnectionError â”‚  â”‚                   â”‚
â”‚  â”‚  â”‚ DataNotFoundError     â”‚  â”‚                   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                â”‚                                     â”‚
â”‚                â–¼                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚      ErrorHandler           â”‚                   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚                   â”‚
â”‚  â”‚  â”‚ 1. Log error         â”‚   â”‚                   â”‚
â”‚  â”‚  â”‚ 2. Show dialog       â”‚   â”‚                   â”‚
â”‚  â”‚  â”‚ 3. Try recovery      â”‚   â”‚                   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚                   â”‚
â”‚  â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚      â”‚                 â”‚                            â”‚
â”‚      â–¼                 â–¼                            â”‚
â”‚   Logger          QMessageBox                      â”‚
â”‚  (logs)          (user sees)                       â”‚
â”‚                                                     â”‚
â”‚  Global Exception Hook (sys.excepthook)            â”‚
â”‚  â””â”€â”€> Catches all unhandled exceptions             â”‚
â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Concepts Explained

#### Concept 1: Exception Hierarchy

**Real-World Analogy**: Think of **medical triage** ğŸ¥

Different injuries need different treatments:
- **Minor (Recoverable)**: Scraped knee â†’ bandage and continue
- **Moderate**: Sprained ankle â†’ treatment and rest, then continue
- **Severe (Unrecoverable)**: Broken leg â†’ hospital, stop activity

**Our Exception Hierarchy**:
```
Exception (Python built-in)
    â”‚
    â””â”€> ApplicationError (our base)
            â”‚
            â”œâ”€> ValidationError (user input problems)
            â”‚   â””â”€> Recoverable: yes
            â”‚       User message: "ì…ë ¥ ì˜¤ë¥˜: ..."
            â”‚
            â”œâ”€> BrokerConnectionError (network/API issues)
            â”‚   â””â”€> Recoverable: yes (retry possible)
            â”‚       User message: "ì¦ê¶Œì‚¬ ì—°ê²° ì‹¤íŒ¨. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”."
            â”‚
            â”œâ”€> BrokerAuthenticationError (login failed)
            â”‚   â””â”€> Recoverable: maybe (user can re-enter credentials)
            â”‚       User message: "ì¸ì¦ ì‹¤íŒ¨. ê³„ì • ì •ë³´ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”."
            â”‚
            â””â”€> DataNotFoundError (missing data)
                â””â”€> Recoverable: no (data truly doesn't exist)
                    User message: "ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
```

**Problem vs Solution**:

âŒ **Without Hierarchy** (generic exceptions):
```python
raise Exception("Something went wrong")
# Can't tell what happened, how severe, or if recoverable
```

âœ… **With Hierarchy** (typed exceptions):
```python
raise BrokerConnectionError(
    message="Connection timeout after 30s",  # For developers
    user_message="ì¦ê¶Œì‚¬ ì—°ê²° ì‹¤íŒ¨. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.",  # For users
    recoverable=True,  # Can retry
    broker_name="eBest",  # Context
    timeout=30  # More context
)
# Clear type, severity, user message, and debugging context
```

**Why Use This?**

| Benefit | Description | Example |
|---------|-------------|---------|
| Type Safety | Catch specific error types | `except ValidationError: ...` |
| Clear Intent | Error name explains what happened | BrokerConnectionError vs Exception |
| Rich Context | Store error-specific metadata | Validation field name, broker name |
| Recovery | Know if error is recoverable | Retry connection vs give up |
| User Messages | Tailored messages per error type | Korean messages for each scenario |

**Concrete Example from Our System**:
```python
# ValidationError - user can fix input
raise ValidationError(
    message=f"Email format invalid: {email}",
    user_message="ì…ë ¥ ì˜¤ë¥˜: ì´ë©”ì¼ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.",
    field="email",
    value=email,
    recoverable=True
)

# BrokerConnectionError - automatic retry possible
raise BrokerConnectionError(
    message=f"Connection timeout: {broker}",
    user_message=f"ì¦ê¶Œì‚¬ ì—°ê²° ì‹¤íŒ¨: {broker}\nì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.",
    broker_name=broker,
    timeout=30,
    recoverable=True
)
```

#### Concept 2: Dual Messages (Technical + User)

**Real-World Analogy**: Think of **pilot announcements** âœˆï¸

- **Cockpit (Technical)**: "Hydraulic pressure drop in system 2, initiating backup"
- **Cabin (User)**: "We're experiencing minor turbulence. Please remain seated."

Same problem, different audiences.

**Our Approach**:
```python
class ApplicationError(Exception):
    def __init__(
        self,
        message: str,        # For developers/logs (technical)
        user_message: str,   # For users/dialogs (friendly)
        **context            # Extra debugging info
    ):
        self.message = message
        self.user_message = user_message
        self.context = context
```

**Visual Diagram**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Same Error, Two Views          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                         â”‚
â”‚  TECHNICAL (Log File):                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ BrokerConnectionError:          â”‚   â”‚
â”‚  â”‚ Connection timeout after 30s    â”‚   â”‚
â”‚  â”‚ broker: eBest                   â”‚   â”‚
â”‚  â”‚ endpoint: api.ebestsec.co.kr    â”‚   â”‚
â”‚  â”‚ traceback: [full stack trace]   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                         â”‚
â”‚  USER (Dialog):                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ âš ï¸ ì¦ê¶Œì‚¬ ì—°ê²° ì‹¤íŒ¨               â”‚   â”‚
â”‚  â”‚                                 â”‚   â”‚
â”‚  â”‚ eBest ì„œë²„ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.  â”‚   â”‚
â”‚  â”‚ ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.        â”‚   â”‚
â”‚  â”‚                                 â”‚   â”‚
â”‚  â”‚           [í™•ì¸]                â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Why Use This?**

| Benefit | Description | Example |
|---------|-------------|---------|
| Developer Debugging | Full details in logs | Exact timeout, endpoint, stack |
| User Clarity | Simple, actionable messages | "Connection failed, try again" |
| Localization | User messages in Korean | ì¦ê¶Œì‚¬ ì—°ê²° ì‹¤íŒ¨ |
| Professionalism | Don't overwhelm users | Hide technical jargon |

#### Concept 3: Recovery Strategies

**Real-World Analogy**: Think of **automatic car systems** ğŸš—

Modern cars have recovery strategies:
- **Low fuel** â†’ Show warning, find gas station
- **Tire pressure low** â†’ Inflate or use spare
- **Engine overheating** â†’ Reduce power, turn on cooling

Errors can have automatic fixes too!

**How Recovery Works**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      RECOVERY STRATEGY PATTERN          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                         â”‚
â”‚  1. Error occurs                        â”‚
â”‚     BrokerConnectionError               â”‚
â”‚            â†“                            â”‚
â”‚  2. ErrorHandler.handle(error)          â”‚
â”‚     â”œâ”€> Log error                       â”‚
â”‚     â”œâ”€> Show dialog                     â”‚
â”‚     â””â”€> Check for recovery strategy     â”‚
â”‚            â†“                            â”‚
â”‚  3. Recovery strategy registered?       â”‚
â”‚     â”œâ”€> Yes: Call recovery function     â”‚
â”‚     â”‚        â†“                          â”‚
â”‚     â”‚   try_reconnect(error)            â”‚
â”‚     â”‚        â†“                          â”‚
â”‚     â”‚   Success? Return True            â”‚
â”‚     â”‚   Failed? Return False            â”‚
â”‚     â”‚                                   â”‚
â”‚     â””â”€> No: Return False (no recovery)  â”‚
â”‚                                         â”‚
â”‚  4. If recovered: Continue execution    â”‚
â”‚     If failed: User decides next step   â”‚
â”‚                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Problem vs Solution**:

âŒ **Without Recovery**:
```python
# Connection fails
# User sees error
# User must manually reconnect
# Lost time and productivity
```

âœ… **With Recovery**:
```python
# Connection fails
# ErrorHandler tries to reconnect automatically
# If succeeds: User doesn't even notice (just a brief dialog)
# If fails: User can decide manually
```

**Concrete Example**:
```python
# Register recovery strategy
def reconnect_strategy(error: BrokerConnectionError) -> bool:
    """Try to reconnect to broker."""
    try:
        broker = get_broker(error.broker_name)
        broker.reconnect()
        logger.info(f"Reconnected to {error.broker_name}")
        return True  # Success!
    except Exception:
        logger.error("Reconnection failed")
        return False  # Failed

# Register it
error_handler.register_recovery(
    BrokerConnectionError,
    reconnect_strategy
)

# Now when BrokerConnectionError occurs:
# 1. ErrorHandler logs it
# 2. Shows dialog
# 3. Calls reconnect_strategy()
# 4. If successful, connection restored automatically!
```

**Why Use This?**

| Benefit | Description | Example |
|---------|-------------|---------|
| Automatic Recovery | Fix transient errors without user intervention | Network glitches, timeouts |
| User Experience | Minimize interruptions | User barely notices retry |
| Flexibility | Different strategies per error type | Reconnect vs re-auth vs reload |
| Testability | Test recovery logic in isolation | Mock recovery functions |

#### Concept 4: Global Exception Hook

**Real-World Analogy**: Think of a **building-wide fire alarm** ğŸš¨

Every room has smoke detectors. They all connect to a central system that:
- Detects fires anywhere in building
- Alerts everyone
- Activates sprinklers
- Calls fire department

Global exception hook does the same for errors.

**Visual Diagram**:
```
Application Execution
â”‚
â”œâ”€> User clicks button
â”‚   â””â”€> Event handler runs
â”‚       â””â”€> Calls business logic
â”‚           â””â”€> Raises exception âŒ
â”‚               â”‚
â”‚               â”œâ”€> Caught by try/except? âœ… Handle locally
â”‚               â”‚
â”‚               â””â”€> Not caught? âŒ Propagates up
â”‚                   â”‚
â”‚                   â””â”€> Reaches event loop
â”‚                       â”‚
â”‚                       â””â”€> sys.excepthook() â† CATCHES IT!
â”‚                           â”‚
â”‚                           â””â”€> ErrorHandler.handle()
â”‚                               â”œâ”€> Log error
â”‚                               â”œâ”€> Show dialog
â”‚                               â””â”€> Try recovery
â”‚
Application keeps running âœ…
```

**Problem vs Solution**:

âŒ **Without Global Hook**:
```python
# Unhandled exception in background thread
def background_task():
    data = fetch_data()  # Raises exception
    # Exception propagates
    # Thread crashes
    # User sees nothing (silent failure) or app crashes
```

âœ… **With Global Hook**:
```python
# Same scenario
def background_task():
    data = fetch_data()  # Raises exception
    # Exception propagates to global hook
    # Hook logs it
    # Hook shows error dialog
    # App keeps running
```

**Installation**:
```python
def exception_hook(exc_type, exc_value, exc_traceback):
    """Global exception handler."""
    # Log the unhandled exception
    logger.critical(
        "Unhandled exception",
        exc_info=(exc_type, exc_value, exc_traceback)
    )

    # Handle it
    error_handler.handle(exc_value)

# Install hook
sys.excepthook = exception_hook
```

**Why Use This?**

| Benefit | Description | Example |
|---------|-------------|---------|
| Safety Net | Catch ALL exceptions, even in threads | Background tasks, callbacks |
| No Silent Failures | Every error is logged and shown | User always knows what happened |
| Crash Prevention | App doesn't terminate unexpectedly | Graceful degradation |
| Complete Coverage | Even bugs we didn't anticipate | Defensive programming |

### Component Interactions

**Sequence Diagram: Error Raised â†’ Handled â†’ Recovered**

```
App Code    ApplicationError    ErrorHandler    Logger    Dialog    Recovery
   â”‚               â”‚                  â”‚           â”‚         â”‚          â”‚
   â”‚ raise error   â”‚                  â”‚           â”‚         â”‚          â”‚
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚                  â”‚           â”‚         â”‚          â”‚
   â”‚               â”‚                  â”‚           â”‚         â”‚          â”‚
   â”‚               â”‚  handle(error)   â”‚           â”‚         â”‚          â”‚
   â”‚               â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚           â”‚         â”‚          â”‚
   â”‚               â”‚                  â”‚           â”‚         â”‚          â”‚
   â”‚               â”‚                  â”‚ log error â”‚         â”‚          â”‚
   â”‚               â”‚                  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚         â”‚          â”‚
   â”‚               â”‚                  â”‚  (full    â”‚         â”‚          â”‚
   â”‚               â”‚                  â”‚ traceback)â”‚         â”‚          â”‚
   â”‚               â”‚                  â”‚           â”‚         â”‚          â”‚
   â”‚               â”‚                  â”‚ show dialog         â”‚          â”‚
   â”‚               â”‚                  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚          â”‚
   â”‚               â”‚                  â”‚ (user msg)â”‚         â”‚          â”‚
   â”‚               â”‚                  â”‚           â”‚    User clicks OK  â”‚
   â”‚               â”‚                  â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤          â”‚
   â”‚               â”‚                  â”‚           â”‚         â”‚          â”‚
   â”‚               â”‚                  â”‚ try recovery        â”‚          â”‚
   â”‚               â”‚                  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
   â”‚               â”‚                  â”‚           â”‚         â”‚  attempt â”‚
   â”‚               â”‚                  â”‚           â”‚         â”‚  (e.g.,  â”‚
   â”‚               â”‚                  â”‚           â”‚         â”‚ reconnect)
   â”‚               â”‚                  â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚               â”‚                  â”‚ success=True        â”‚          â”‚
   â”‚               â”‚                  â”‚           â”‚         â”‚          â”‚
   â”‚               â”‚  return True     â”‚           â”‚         â”‚          â”‚
   â”‚               â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â”‚         â”‚          â”‚
   â”‚               â”‚                  â”‚           â”‚         â”‚          â”‚
   â”‚  continue     â”‚                  â”‚           â”‚         â”‚          â”‚
   â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                  â”‚           â”‚         â”‚          â”‚
```

---

## 3. Technical Approach

### Strategy Diagrams

**ErrorHandler Lifecycle**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  App Starts  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Create ErrorHandler        â”‚
â”‚ - Inject Logger            â”‚
â”‚ - Store parent widget      â”‚
â”‚ - Initialize strategies {} â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Register in DI Container   â”‚
â”‚ as Singleton               â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Install Global Hook        â”‚
â”‚ sys.excepthook = hook      â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Register Recovery          â”‚
â”‚ Strategies (optional)      â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ready to     â”‚
â”‚ Handle Errorsâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Error Flow Decision Tree**:

```
Error Raised
    â”‚
    â”œâ”€> Is ApplicationError?
    â”‚   â”œâ”€> Yes: Extract user_message, context
    â”‚   â””â”€> No: Use generic message
    â”‚
    â”œâ”€> Log Error
    â”‚   â”œâ”€> ApplicationError: Log with context
    â”‚   â””â”€> Other: Log with full traceback
    â”‚
    â”œâ”€> Show Dialog
    â”‚   â”œâ”€> Recoverable: Warning icon
    â”‚   â””â”€> Unrecoverable: Critical icon
    â”‚
    â””â”€> Attempt Recovery
        â”œâ”€> Strategy registered?
        â”‚   â”œâ”€> Yes: Call strategy
        â”‚   â”‚   â”œâ”€> Success: Return True
        â”‚   â”‚   â””â”€> Failure: Return False
        â”‚   â””â”€> No: Return False
        â”‚
        â””â”€> Return result to caller
```

### Pseudocode Only

**ApplicationError Base Class**:
```
CLASS ApplicationError(Exception):
    INIT(message, user_message, recoverable=True, **context):
        self.message = message              # Technical message
        self.user_message = user_message    # User-friendly Korean
        self.recoverable = recoverable      # Can recover?
        self.context = context              # Extra metadata

        # Store for logging
        self.timestamp = NOW()
        self.error_type = TYPE_NAME(self)
```

**ErrorHandler.handle Method**:
```
FUNCTION handle(error: Exception) -> bool:
    # Step 1: Log error with full context
    IF error IS ApplicationError:
        logger.error(
            error.message,
            error_type=error.error_type,
            recoverable=error.recoverable,
            **error.context
        )
    ELSE:
        logger.exception(
            "Unhandled exception",
            exc_info=error
        )

    # Step 2: Display error dialog
    user_msg = GET user_message from error OR "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."
    icon = IF error.recoverable THEN Warning ELSE Critical
    SHOW QMessageBox(
        icon=icon,
        title="ì˜¤ë¥˜",
        text=user_msg
    )
    WAIT for user to click OK

    # Step 3: Attempt recovery
    error_type = TYPE(error)
    IF error_type IN _recovery_strategies:
        strategy = _recovery_strategies[error_type]
        TRY:
            success = CALL strategy(error)
            IF success:
                logger.info(f"Recovery succeeded for {error_type}")
                RETURN True
            ELSE:
                logger.warning(f"Recovery failed for {error_type}")
                RETURN False
        EXCEPT recovery_exception:
            logger.error(
                "Recovery strategy raised exception",
                original_error=error,
                recovery_error=recovery_exception
            )
            RETURN False
    ELSE:
        RETURN False  # No recovery strategy
```

**Global Exception Hook**:
```
FUNCTION exception_hook(exc_type, exc_value, exc_traceback):
    # Log unhandled exception
    logger.critical(
        "Unhandled exception caught by global hook",
        exc_info=(exc_type, exc_value, exc_traceback)
    )

    # Handle it
    TRY:
        error_handler.handle(exc_value)
    EXCEPT handler_exception:
        # Error in error handler - fallback to stderr
        PRINT to sys.stderr:
            "CRITICAL: Error handler failed!"
            "Original error:", exc_value
            "Handler error:", handler_exception
```

**Recovery Strategy Registration**:
```
FUNCTION register_recovery(error_type: type, strategy: Callable) -> None:
    # Validate inputs
    IF NOT isinstance(error_type, type):
        RAISE TypeError("error_type must be a class")

    IF NOT callable(strategy):
        RAISE TypeError("strategy must be callable")

    # Store strategy
    _recovery_strategies[error_type] = strategy

    logger.debug(f"Registered recovery strategy for {error_type}")
```

### Design Decisions Table

#### Decision 1: Separate Technical and User Messages

| Decision | Chosen | Why | Alternative Rejected |
|----------|--------|-----|---------------------|
| **Message Structure** | **Dual messages (technical + user)** | **Detailed Reasoning**: Developers and users have completely different needs. Developers need full technical details to debug (stack traces, variable values, endpoints). Users need simple, actionable Korean messages without jargon. Combining them creates either too much detail (confuses users) or too little (hampers debugging).<br><br>**Problem/Solution**:<br>Single message approach fails both audiences:<br>```python<br># Too technical for users<br>"ConnectionError: Timeout after 30s on api.ebestsec.co.kr:8080"<br><br># Too vague for developers<br>"ì—°ê²° ì‹¤íŒ¨"<br><br># Our approach: both!<br>message="Timeout after 30s on api.ebestsec.co.kr:8080"<br>user_message="ì¦ê¶Œì‚¬ ì—°ê²° ì‹¤íŒ¨. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”."<br>```<br><br>**Trade-offs**:<br>- **Gain**: Perfect for each audience, clear debugging, happy users<br>- **Lose**: Must write two messages (but worth it!)<br><br>**Concrete Example**:<br>Log file: Full debugging details<br>User dialog: "ì¦ê¶Œì‚¬ ì—°ê²° ì‹¤íŒ¨. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”."<br> | **Single Message**: Rejected because:<br>1. Technical messages confuse users<br>2. Simple messages lack debugging info<br>3. Can't localize without losing details |

#### Decision 2: Recoverable Flag on Errors

| Decision | Chosen | Why | Alternative Rejected |
|----------|--------|-----|---------------------|
| **Recovery Indication** | **Boolean `recoverable` flag** | **Detailed Reasoning**: Not all errors are equal. Some are transient (network timeoutâ€”retry might work), others are permanent (data doesn't existâ€”retrying won't help). The `recoverable` flag tells the ErrorHandler how to respond: retry for recoverable, give up for unrecoverable.<br><br>**Problem/Solution**:<br>Without flag, we don't know if we should retry:<br>```python<br># Should we retry this?<br>raise Exception("Failed")  # Who knows?<br><br># Clear intent<br>raise BrokerConnectionError(..., recoverable=True)  # Yes, retry!<br>raise DataNotFoundError(..., recoverable=False)  # No, data is gone<br>```<br><br>**Trade-offs**:<br>- **Gain**: Clear recovery semantics, smart error handling<br>- **Lose**: Must decide recoverability for each error (good discipline!)<br><br>**Usage**:<br>```python<br>if error.recoverable:<br>    # Show "Retry?" button<br>    # Attempt automatic recovery<br>else:<br>    # Show "OK" button only<br>    # Don't retry (won't help)<br>```<br> | **No Recoverability Info**: Rejected because:<br>1. Can't decide if retry makes sense<br>2. Wastes time retrying unrecoverable errors<br>3. Confuses users with inappropriate options |

#### Decision 3: Exception Hierarchy (not error codes)

| Decision | Chosen | Why | Alternative Rejected |
|----------|--------|-----|---------------------|
| **Error Representation** | **Exception hierarchy (classes)** | **Detailed Reasoning**: Python is object-oriented. Exception classes provide type safety (`except ValidationError:`), inheritance (shared behavior), and metadata storage (context dict). Error codes are primitive, error-prone (typos), and lose context.<br><br>**Problem/Solution**:<br>Error codes approach:<br>```python<br># Error codes (primitive)<br>ERR_VALIDATION = 1001<br>ERR_CONNECTION = 2001<br>raise Exception(ERR_VALIDATION)  # What does 1001 mean? Look it up!<br><br># Exception classes (rich)<br>raise ValidationError(field="email", ...)  # Clear type, rich context<br>```<br><br>**Trade-offs**:<br>- **Gain**: Type safety, IDE support, Pythonic, rich context<br>- **Lose**: More classes to define (but better organization)<br><br>**Benefits**:<br>```python<br># Type-safe catch blocks<br>try:<br>    ...<br>except ValidationError as e:<br>    # IDE knows e.field exists<br>    print(f"Invalid {e.field}")<br>except BrokerConnectionError as e:<br>    # IDE knows e.broker_name exists<br>    print(f"Failed to connect to {e.broker_name}")<br>```<br> | **Error Codes** (integers, strings): Rejected because:<br>1. No type safety (can't catch specific errors)<br>2. Hard to remember codes<br>3. No metadata storage<br>4. Not Pythonic |

#### Decision 4: Global Exception Hook

| Decision | Chosen | Why | Alternative Rejected |
|----------|--------|-----|---------------------|
| **Unhandled Exceptions** | **Install `sys.excepthook`** | **Detailed Reasoning**: Desktop apps have many execution contexts: main thread, background threads, Qt event loop, timers. It's impossible to wrap every single line in try/except. The global exception hook is a safety net that catches EVERYTHING we missed, preventing crashes and silent failures.<br><br>**Problem/Solution**:<br>Without hook, unhandled exceptions crash the app:<br>```python<br># Background thread<br>def fetch_data():<br>    response = api.call()  # Raises exception<br>    # No try/except!<br>    # App crashes or thread dies silently<br><br># With hook installed<br># Same exception is caught by hook<br># Logged, shown to user, app keeps running<br>```<br><br>**Trade-offs**:<br>- **Gain**: Complete safety net, no crashes, always logged<br>- **Lose**: None (this is pure benefit)<br><br>**Real Example**:<br>User clicks button 1000 times a day. One click triggers rare edge case. Without hook: app crashes. With hook: error logged and shown, app continues.<br> | **No Global Hook** (rely on try/except everywhere): Rejected because:<br>1. Impossible to cover every execution path<br>2. One missed exception = crash<br>3. Silent failures in threads<br>4. Defensive programming is hard to maintain |

#### Decision 5: Korean as Primary Language

| Decision | Chosen | Why | Alternative Rejected |
|----------|--------|-----|---------------------|
| **User Message Language** | **Korean primary, English fallback** | **Detailed Reasoning**: Our target users are Korean traders. Error messages during stressful situations (trading) must be in their native language for instant comprehension. English technical terms are acceptable for developers in logs, but user-facing dialogs must be Korean.<br><br>**Problem/Solution**:<br>English messages for Korean users:<br>```python<br># User sees (stressed during trading):<br>"Broker connection timeout after 30 seconds"<br># User thinks: "What? Timeout? What do I do?"<br><br># Korean message:<br>"ì¦ê¶Œì‚¬ ì—°ê²° ì‹¤íŒ¨. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”."<br># User thinks: "ì•„, ì—°ê²° ì•ˆëêµ¬ë‚˜. ë‹¤ì‹œ ì‹œë„í•˜ë©´ ë˜ê² ë„¤."<br># (Clear, actionable, immediate understanding)<br>```<br><br>**Trade-offs**:<br>- **Gain**: User clarity, reduced stress, professional UX<br>- **Lose**: Must translate all messages (but worth it!)<br><br>**Implementation**:<br>```python<br>raise BrokerConnectionError(<br>    message="Connection timeout after 30s",  # English for logs<br>    user_message="ì¦ê¶Œì‚¬ ì—°ê²° ì‹¤íŒ¨. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.",  # Korean for dialog<br>)<br>```<br> | **English Only**: Rejected because:<br>1. Language barrier for Korean users<br>2. Slower comprehension during stress<br>3. Unprofessional for target market |

---

## 4. Implementation Strategy

### Development Phases

```
Phase 1: Exception Classes (2 hours)
â”œâ”€ Create ApplicationError base class
â”œâ”€ Define specific exception types
â”‚  â”œâ”€ ValidationError
â”‚  â”œâ”€ BrokerConnectionError
â”‚  â”œâ”€ BrokerAuthenticationError
â”‚  â””â”€ DataNotFoundError
â””â”€ Write docstrings and examples
    â†“
Phase 2: ErrorHandler Core (2 hours)
â”œâ”€ Create ErrorHandler class
â”œâ”€ Implement handle() method
â”‚  â”œâ”€ Logging logic
â”‚  â”œâ”€ Dialog display
â”‚  â””â”€ Recovery attempt
â””â”€ Dependency injection setup
    â†“
Phase 3: Error Dialog UI (1 hour)
â”œâ”€ Create QMessageBox wrapper
â”œâ”€ Add Korean message formatting
â””â”€ Test with different error types
    â†“
Phase 4: Global Hook (1 hour)
â”œâ”€ Implement exception_hook function
â”œâ”€ Install with sys.excepthook
â””â”€ Test with unhandled exceptions
    â†“
Phase 5: Recovery Strategies (1 hour)
â”œâ”€ Implement register_recovery()
â”œâ”€ Create sample strategies
â”‚  â””â”€ Reconnection strategy
â””â”€ Test recovery flow
    â†“
Phase 6: Testing & Polish (1 hour)
â”œâ”€ Unit tests for all exception types
â”œâ”€ Integration tests for ErrorHandler
â”œâ”€ UI tests for error dialogs
â””â”€ Performance validation
```

**Timeline**:
```
Task                    â”‚ H1 â”‚ H2 â”‚ H3 â”‚ H4 â”‚ H5 â”‚ H6 â”‚ H7 â”‚ H8 â”‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
Exception Classes       â”‚ â–ˆâ–ˆ â”‚ â–ˆâ–ˆ â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â”‚
ErrorHandler Core       â”‚    â”‚    â”‚ â–ˆâ–ˆ â”‚ â–ˆâ–ˆ â”‚    â”‚    â”‚    â”‚    â”‚
Error Dialog UI         â”‚    â”‚    â”‚    â”‚    â”‚ â–ˆâ–ˆ â”‚    â”‚    â”‚    â”‚
Global Hook             â”‚    â”‚    â”‚    â”‚    â”‚    â”‚ â–ˆâ–ˆ â”‚    â”‚    â”‚
Recovery Strategies     â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â”‚ â–ˆâ–ˆ â”‚    â”‚
Testing & Polish        â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â”‚ â–ˆâ–ˆ â”‚
```

### Integration Points

**System Architecture**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  APPLICATION LAYER                      â”‚
â”‚                                                         â”‚
â”‚  All Services/Components                               â”‚
â”‚  â””â”€> Raise ApplicationError subclasses                 â”‚
â”‚  â””â”€> Use ErrorHandler via DI                           â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â”‚ inject IErrorHandler
                         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               INFRASTRUCTURE LAYER                      â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚     ErrorHandler (YOU ARE HERE)             â”‚       â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚       â”‚
â”‚  â”‚  â”‚ handle(error)                    â”‚       â”‚       â”‚
â”‚  â”‚  â”‚  â”œâ”€> Log via Logger              â”‚       â”‚       â”‚
â”‚  â”‚  â”‚  â”œâ”€> Show QMessageBox            â”‚       â”‚       â”‚
â”‚  â”‚  â”‚  â””â”€> Try recovery strategy       â”‚       â”‚       â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚           Logger (E01-F04)                  â”‚       â”‚
â”‚  â”‚  â† Logs all errors                          â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                         â”‚
â”‚  Global Exception Hook (sys.excepthook)                â”‚
â”‚  â””â”€> Catches unhandled â†’ ErrorHandler.handle()        â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Integration Points:
â‘  DI Container: ErrorHandler registered as singleton
â‘¡ Logger: ErrorHandler injects Logger for error logging
â‘¢ All Services: Raise typed exceptions, inject ErrorHandler
â‘£ Global Hook: Catches unhandled exceptions
â‘¤ Qt: QMessageBox dialogs shown on parent widget
```

### Risk Mitigation

| Risk | Probability | Impact | Mitigation Strategy |
|------|-------------|--------|---------------------|
| Error in error handler (meta-error) | Low | Critical | Wrap handle() in try/except, fall back to sys.stderr; comprehensive testing |
| Infinite error loops | Low | High | Add recursion counter, limit error handling depth to 3 |
| Poor Korean message quality | Medium | Medium | Review with native speaker, iterate on clarity |
| Recovery strategy bugs | Medium | Medium | Isolate recovery in try/except, log failures, don't crash |
| Missing exception types | Medium | Low | Start with common types (validation, connection, auth), add more as needed |
| Dialog shown on wrong thread | Low | Medium | Always invoke QMessageBox on main thread (Qt requirement) |

---

## 5. Expected Behavior & Scenarios

### User Stories (Given/When/Then)

**Story 1: Validation Error Shown to User**
```
GIVEN: User enters invalid email "notanemail"
WHEN: Form validation raises ValidationError
THEN: Warning dialog appears with Korean message
  "ì…ë ¥ ì˜¤ë¥˜: ì´ë©”ì¼ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤."
  AND: Error is logged with field="email", value="notanemail"
  AND: User can correct input and continue
```

**Story 2: Connection Error with Automatic Recovery**
```
GIVEN: Broker connection times out
  AND: Reconnection recovery strategy is registered
WHEN: BrokerConnectionError is raised
THEN: Error is logged with full context (broker, timeout)
  AND: Warning dialog shows "ì¦ê¶Œì‚¬ ì—°ê²° ì‹¤íŒ¨. ì¬ì—°ê²° ì¤‘ì…ë‹ˆë‹¤..."
  AND: Recovery strategy attempts reconnection
  AND: If successful, dialog closes and work continues
  AND: If failed, user can retry manually or cancel
```

**Story 3: Unhandled Exception in Background Thread**
```
GIVEN: Background thread runs data fetch
  AND: Unexpected exception occurs (not caught)
WHEN: Exception propagates to global hook
THEN: Hook logs "Unhandled exception" with full traceback
  AND: Critical error dialog shows "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."
  AND: Thread terminates but app keeps running
  AND: User is aware something went wrong
```

**Story 4: Developer-Friendly Logging**
```
GIVEN: Any ApplicationError is raised
WHEN: ErrorHandler.handle() is called
THEN: Log entry includes:
  - Error type (e.g., "BrokerConnectionError")
  - Technical message (e.g., "Timeout after 30s")
  - All context kwargs (broker="eBest", timeout=30)
  - Stack traceback
  - Timestamp
  - Recoverable flag
```

**Story 5: Recovery Strategy Fails Gracefully**
```
GIVEN: Recovery strategy is registered but raises exception
WHEN: ErrorHandler attempts recovery
THEN: Recovery exception is caught
  AND: Logged as "Recovery strategy failed" with both errors
  AND: Original error dialog remains shown
  AND: handle() returns False
  AND: No crash from meta-error
```

### Edge Cases

| Case | Expected Behavior | Rationale |
|------|-------------------|-----------|
| Error in error handler | Log to stderr, don't crash | Ultimate fallback |
| Dialog shown from non-main thread | Queue to main thread | Qt requirement |
| Recovery strategy not callable | TypeError during registration | Fail fast at setup |
| User message is None | Use generic Korean message | Always show something |
| Context contains non-serializable | Log warning, skip field | Don't crash on logging |
| Multiple errors simultaneously | Queue and handle sequentially | Prevent dialog chaos |
| Recursive error (error â†’ handle â†’ error) | Detect recursion, break loop | Prevent infinite loop |

### Performance Expectations

**Error Handling Overhead**:

```
Target: < 10ms per error (overhead beyond logging)

Breakdown per error:
â”œâ”€ Create exception object:    ~0.1ms
â”œâ”€ Extract context/traceback:  ~0.5ms
â”œâ”€ Log error (E01-F04):        ~1.0ms
â”œâ”€ Create QMessageBox:         ~2.0ms
â”œâ”€ Show dialog (blocking):     âˆ (waits for user)
â”œâ”€ Check recovery strategy:    ~0.1ms
â”œâ”€ Call recovery (if exists):  varies
â””â”€ Total (before dialog):      ~3.7ms âœ… Well under 10ms

Note: Dialog display is interactive, not counted in overhead
Recovery strategies are optional and vary
```

---

## 6. Testing Strategy

### Coverage Pyramid

```
                  â–²
                 â•± â•²
                â•±   â•²         E2E: Full app error scenarios
               â•±â”€â”€â”€â”€â”€â•²        (~5 tests)
              â•±       â•²
             â•±         â•²
            â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•²     Integration: Handler + Logger + Dialog
           â•±             â•²    (~10 tests)
          â•±               â•²
         â•±                 â•²
        â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•²  Unit: Exception classes, handler methods
       â•±                     â•² (~25 tests)
      â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•²
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Target Coverage: 80%+
```

### Key Scenarios

**Unit Test Scenarios**:
- âœ… ApplicationError stores message, user_message, context
- âœ… ApplicationError defaults recoverable to True
- âœ… ValidationError includes field name in context
- âœ… BrokerConnectionError includes broker_name in context
- âœ… ErrorHandler.handle() logs error via Logger
- âœ… ErrorHandler.handle() shows QMessageBox (mock)
- âœ… ErrorHandler.handle() calls recovery strategy if registered
- âœ… ErrorHandler.handle() catches recovery exceptions
- âœ… register_recovery() validates inputs
- âœ… Exception hook logs unhandled exceptions
- âœ… Exception hook calls ErrorHandler.handle()

**Integration Test Scenarios**:
- âœ… Raise ValidationError â†’ logged + dialog + no crash
- âœ… Raise BrokerConnectionError â†’ recovery attempted
- âœ… Unhandled exception â†’ caught by hook â†’ handled
- âœ… Recovery succeeds â†’ handle() returns True
- âœ… Recovery fails â†’ handle() returns False
- âœ… Multiple errors queued â†’ handled sequentially
- âœ… Error from background thread â†’ handled on main thread
- âœ… Korean messages displayed correctly

**UI Test Scenarios**:
- âœ… Error dialog shows correct icon (warning/critical)
- âœ… Error dialog shows Korean message
- âœ… Error dialog blocks until user clicks OK
- âœ… Dialog parent is correct QWidget

**Performance Test Scenarios**:
- âœ… Create ApplicationError in < 1ms
- âœ… ErrorHandler.handle() overhead < 10ms (excluding dialog)
- âœ… 100 errors handled in < 1 second

### Validation Approach

**Conceptual Validation Steps**:

1. **Exception Creation**
   - Create each exception type
   - Verify message, user_message, context stored
   - Check recoverable flag

2. **Error Handling Flow**
   - Raise exception
   - Verify logged with Logger
   - Verify dialog shown (mock QMessageBox)
   - Verify recovery attempted

3. **Recovery Strategies**
   - Register strategy
   - Trigger error
   - Verify strategy called
   - Test success and failure paths

4. **Global Hook**
   - Raise unhandled exception
   - Verify hook catches it
   - Verify ErrorHandler.handle() called

5. **Korean Localization**
   - Display all error types
   - Review messages with native speaker
   - Verify encoding (UTF-8)

---

## Summary

### What We're Building

A comprehensive error handling infrastructure that:
- Catches all exceptions (handled and unhandled)
- Logs errors with full context and tracebacks
- Shows user-friendly Korean error dialogs
- Attempts automatic recovery where possible
- Prevents application crashes

### Why It Matters

Enables reliable, professional application by:
- Preventing crashes and data loss
- Providing clear user communication
- Enabling effective debugging
- Supporting graceful degradation
- Building user trust

### How It Works

1. Define typed exception hierarchy with dual messages
2. ErrorHandler catches, logs, displays, and recovers
3. Global exception hook provides safety net
4. Recovery strategies enable automatic fixes
5. QMessageBox dialogs communicate with users in Korean

### What Makes It Different

- **Dual Messages**: Technical (logs) + User-friendly (dialogs)
- **Typed Exceptions**: Rich context, not generic errors
- **Recoverable Flag**: Intelligent retry logic
- **Global Safety Net**: sys.excepthook catches everything
- **Korean-First**: Native language for target users
- **Recovery Strategies**: Automatic fixes for transient errors

---

**Next Steps**: Ready for implementation! See `E01-F05.spec.md` for detailed requirements and task breakdown.

**Questions?** All requirements are clearâ€”no open questions or clarifications needed.
