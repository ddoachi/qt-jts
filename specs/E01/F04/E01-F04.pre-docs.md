# Pre-Implementation Docs: E01-F04 - Logging Infrastructure

**Feature**: Logging Infrastructure
**Spec ID**: E01-F04
**Created**: 2025-12-28
**Estimated Effort**: 8 hours
**Reading Time**: 12-15 minutes

---

## 1. Problem & Context

### Clear Problem Statement

**Problem**: Desktop applications need comprehensive logging to debug issues, understand user behavior, and monitor production problems. Without structured logging, debugging is like searching for a needle in a haystackâ€”you have no visibility into what happened when errors occur.

**Example Without Logging**:
```python
def process_data(data):
    result = calculate(data)  # Fails silently
    return result  # Why did this fail? No idea!
```

**Example With Logging**:
```python
def process_data(data):
    logger.debug(f"Processing data: {data}")
    result = calculate(data)
    logger.info(f"Result: {result}")
    return result  # Full trail of what happened!
```

### Business Impact

**Why This Matters**:
- **Debugging Production Issues**: See exactly what happened when users report bugs
- **Performance Monitoring**: Track slow operations and bottlenecks
- **Usage Analytics**: Understand how users interact with the application
- **Compliance**: Maintain audit trails for regulated environments
- **Qt Integration**: Capture framework warnings that could indicate problems

### Current Pain Points

| Issue | Impact | Frequency | Severity |
|-------|--------|-----------|----------|
| No visibility into errors | Cannot debug production issues | Every error | ğŸ”´ Critical |
| Print statements everywhere | Messy, inconsistent, not persistent | Daily | ğŸ”´ High |
| Qt warnings lost | Miss important framework messages | Common | ğŸŸ¡ Medium |
| No log file management | Logs fill up disk space | Over time | ğŸŸ¡ Medium |
| Unstructured output | Hard to parse/analyze logs | Every log | ğŸŸ¡ Medium |

### Success Metrics

- âœ… All application events logged with appropriate levels
- âœ… Log files auto-rotate at 10MB (max 50MB total)
- âœ… JSON logs parseable by standard tools
- âœ… Qt framework messages captured
- âœ… Logging overhead < 1ms per call
- âœ… Korean characters (and all Unicode) properly encoded

---

## 2. Conceptual Solution

### Core Architecture

Think of logging like a **newspaper printing system** ğŸ“°:
- **Logger**: The printing press (central hub)
- **Handlers**: Different output channels (file, console)
- **Formatters**: Layout templates (JSON, text)
- **Levels**: News categories (DEBUG=gossip, ERROR=breaking news)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              LOGGING ARCHITECTURE                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                     â”‚
â”‚  Application Code                                  â”‚
â”‚       â”‚                                             â”‚
â”‚       â”œâ”€â”€> logger.debug("Detail info")             â”‚
â”‚       â”œâ”€â”€> logger.info("General info")             â”‚
â”‚       â”œâ”€â”€> logger.error("Error occurred")          â”‚
â”‚       â”‚                                             â”‚
â”‚       â–¼                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                   â”‚
â”‚  â”‚   Logger    â”‚ (Central hub)                     â”‚
â”‚  â”‚  Instance   â”‚                                    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                                   â”‚
â”‚         â”‚                                           â”‚
â”‚    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”                                    â”‚
â”‚    â”‚          â”‚                                     â”‚
â”‚    â–¼          â–¼                                     â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚ â”‚ File â”‚  â”‚Consoleâ”‚                                â”‚
â”‚ â”‚Handler  â”‚Handlerâ”‚                                â”‚
â”‚ â””â”€â”€â”€â”¬â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”˜                                â”‚
â”‚     â”‚         â”‚                                     â”‚
â”‚     â–¼         â–¼                                     â”‚
â”‚  [JSON]   [Text]  (Formatters)                    â”‚
â”‚     â”‚         â”‚                                     â”‚
â”‚     â–¼         â–¼                                     â”‚
â”‚  jts.log   stdout                                  â”‚
â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Concepts Explained

#### Concept 1: Log Levels

**Real-World Analogy**: Think of log levels like **news priorities** ğŸ“»

- **DEBUG** = Behind-the-scenes gossip (verbose details)
  - "User clicked button at coordinates (150, 200)"
  - Only developers care

- **INFO** = Regular news (normal operations)
  - "User logged in successfully"
  - General awareness

- **WARNING** = Weather alerts (something unusual but not broken)
  - "Database response took 3 seconds (slow)"
  - Potential problems

- **ERROR** = Breaking news (something failed)
  - "Failed to save file: Permission denied"
  - Requires attention

- **CRITICAL** = Emergency broadcast (system failure)
  - "Database connection lost, shutting down"
  - Immediate action needed

**Visual Diagram**:
```
Severity â†’
DEBUG < INFO < WARNING < ERROR < CRITICAL
  â”‚      â”‚       â”‚         â”‚        â”‚
  â”‚      â”‚       â”‚         â”‚        â””â”€> System failure
  â”‚      â”‚       â”‚         â””â”€> Operation failed
  â”‚      â”‚       â””â”€> Unusual but working
  â”‚      â””â”€> Normal operations
  â””â”€> Detailed debugging info

Filtering Example:
Set level to INFO:
  DEBUG   â†’  âŒ Filtered out
  INFO    â†’  âœ… Logged
  WARNING â†’  âœ… Logged
  ERROR   â†’  âœ… Logged
  CRITICAL â†’ âœ… Logged
```

**Why Use This?**

| Benefit | Description | Example |
|---------|-------------|---------|
| Noise Reduction | Filter out verbose details in production | Production: INFO+, Dev: DEBUG+ |
| Prioritization | Focus on important messages | Errors stand out in sea of INFO |
| Performance | Skip expensive debug logging | Don't format debug strings if level=INFO |
| Targeted Debugging | Enable DEBUG only when investigating | Turn on DEBUG for specific module |

**Concrete Example from Our System**:
```python
# File: DEBUG and above (everything)
file_handler.setLevel(logging.DEBUG)

# Console: INFO and above (less noise)
console_handler.setLevel(logging.INFO)

# Result:
logger.debug("Cache lookup for key 'user_123'")  # File only
logger.info("User logged in")  # Both file and console
logger.error("Failed to save settings")  # Both, highlighted
```

#### Concept 2: Log Rotation

**Real-World Analogy**: Think of a **rotating file cabinet** ğŸ—„ï¸

Imagine you have 6 file drawers:
1. Current drawer (jts.log) - you're adding papers
2. When it gets full (10MB), you:
   - Move drawer 1 â†’ drawer 2
   - Move drawer 2 â†’ drawer 3
   - ... and so on ...
   - Throw away drawer 6 (oldest)
   - Start fresh with empty drawer 1

**Visual Diagram**:
```
BEFORE (jts.log reaches 10MB):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ jts.log  â”‚ â† 10MB (FULL!)
â”‚ (9.8MB)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚jts.log.1 â”‚ â† 10MB
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚jts.log.2 â”‚ â† 10MB
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚jts.log.3 â”‚ â† 10MB
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚jts.log.4 â”‚ â† 10MB
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

AFTER (rotation triggered):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ jts.log  â”‚ â† 0KB (NEW!)
â”‚ (empty)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚jts.log.1 â”‚ â† 10MB (was jts.log)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚jts.log.2 â”‚ â† 10MB (was jts.log.1)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚jts.log.3 â”‚ â† 10MB (was jts.log.2)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚jts.log.4 â”‚ â† 10MB (was jts.log.3)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Total: 5 files Ã— 10MB = 50MB max disk usage
```

**Problem vs Solution**:

âŒ **Without Rotation**:
```
Day 1:  jts.log = 10MB
Day 10: jts.log = 100MB
Day 30: jts.log = 300MB
Day 90: jts.log = 900MB  â† Disk full!
```

âœ… **With Rotation**:
```
Any day: jts.log (current) + 4 backups = 50MB max
Old logs automatically deleted, recent logs preserved
```

**Why Use This?**

| Benefit | Description | Example |
|---------|-------------|---------|
| Disk Space Control | Prevent logs from filling disk | 50MB max vs unlimited growth |
| Automatic Cleanup | No manual intervention needed | Set it and forget it |
| Keep Recent History | Preserve last few days of logs | Last 5 rotations = ~5 days |
| Performance | Smaller files = faster searches | 10MB file vs 1GB file |

#### Concept 3: Structured Logging (JSON)

**Real-World Analogy**: Think of **data in a spreadsheet vs a paragraph** ğŸ“Š

**Unstructured (text paragraph)**:
```
"2025-12-28 10:30:45 ERROR User john failed login attempt"
```
Hard to parse, hard to search, hard to analyze.

**Structured (JSON)**:
```json
{
  "timestamp": "2025-12-28T10:30:45Z",
  "level": "ERROR",
  "message": "Login failed",
  "user": "john",
  "module": "auth.login",
  "line": 42
}
```
Easy to parse, easy to filter, easy to analyze.

**Why Use This?**

| Benefit | Description | Example |
|---------|-------------|---------|
| Parseability | Load logs into tools | `jq '.level == "ERROR"' jts.log` |
| Searchability | Find specific fields | All errors from module "auth" |
| Analytics | Aggregate and visualize | Count errors by module |
| Debugging | Rich context in one place | User, module, line, timestamp |

**Concrete Example**:
```python
# Simple log call
logger.error("Login failed", user="john", ip="192.168.1.1")

# Becomes in jts.log (JSON):
{
  "timestamp": "2025-12-28T10:30:45.123Z",
  "level": "ERROR",
  "message": "Login failed",
  "user": "john",
  "ip": "192.168.1.1",
  "module": "auth.login",
  "function": "authenticate",
  "line": 42,
  "thread": "MainThread"
}

# Console output (human-readable):
2025-12-28 10:30:45 ERROR [auth.login:42] Login failed (user=john, ip=192.168.1.1)
```

#### Concept 4: Qt Message Integration

**Real-World Analogy**: Think of **combining two radio stations into one stream** ğŸ“»

Qt framework emits its own warnings/errors:
- "QPixmap: Invalid pixmap size"
- "QLayout: Cannot add NULL widget"

**Problem**: These go to stderr and get lost.

**Solution**: Redirect Qt messages into our logging system:

```
Qt Framework Messages          Our Application Logs
        â”‚                             â”‚
        â”œâ”€â”€> qWarning()               â”œâ”€â”€> logger.info()
        â”œâ”€â”€> qCritical()              â”œâ”€â”€> logger.error()
        â”‚                             â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
          Qt Message Handler
                 â”‚
                 â–¼
        Unified Log Stream
                 â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                         â”‚
    â–¼                         â–¼
  jts.log                   Console
  (JSON)                    (Text)
```

**Benefit**: All logs in one place, searchable, persistent.

### Component Interactions

**Sequence Diagram: Logging a Message**

```
App Code      Logger      FileHandler    ConsoleHandler   Disk/Console
   â”‚             â”‚              â”‚               â”‚              â”‚
   â”‚  error()    â”‚              â”‚               â”‚              â”‚
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚              â”‚               â”‚              â”‚
   â”‚             â”‚              â”‚               â”‚              â”‚
   â”‚             â”‚ Create       â”‚               â”‚              â”‚
   â”‚             â”‚ LogRecord    â”‚               â”‚              â”‚
   â”‚             â”‚              â”‚               â”‚              â”‚
   â”‚             â”‚  handle()    â”‚               â”‚              â”‚
   â”‚             â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚               â”‚              â”‚
   â”‚             â”‚              â”‚               â”‚              â”‚
   â”‚             â”‚              â”‚ Format        â”‚              â”‚
   â”‚             â”‚              â”‚ as JSON       â”‚              â”‚
   â”‚             â”‚              â”‚               â”‚              â”‚
   â”‚             â”‚              â”‚ Write         â”‚              â”‚
   â”‚             â”‚              â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
   â”‚             â”‚              â”‚               â”‚    jts.log   â”‚
   â”‚             â”‚              â”‚               â”‚              â”‚
   â”‚             â”‚  handle()    â”‚               â”‚              â”‚
   â”‚             â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚              â”‚
   â”‚             â”‚              â”‚               â”‚              â”‚
   â”‚             â”‚              â”‚               â”‚ Format       â”‚
   â”‚             â”‚              â”‚               â”‚ as Text      â”‚
   â”‚             â”‚              â”‚               â”‚              â”‚
   â”‚             â”‚              â”‚               â”‚ Write        â”‚
   â”‚             â”‚              â”‚               â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
   â”‚             â”‚              â”‚               â”‚   stdout     â”‚
   â”‚   return    â”‚              â”‚               â”‚              â”‚
   â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤              â”‚               â”‚              â”‚
```

---

## 3. Technical Approach

### Strategy Diagrams

**Logger Initialization Lifecycle**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  App Starts  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Create Logger("JTS")         â”‚
â”‚ Set level to DEBUG           â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Create Log Directory         â”‚
â”‚ ~/.jts/logs/                 â”‚
â”‚ (mkdir if not exists)        â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Setup File Handler           â”‚
â”‚ - RotatingFileHandler        â”‚
â”‚ - 10MB max, 5 backups        â”‚
â”‚ - JsonFormatter              â”‚
â”‚ - Level: DEBUG               â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Setup Console Handler        â”‚
â”‚ - StreamHandler(stdout)      â”‚
â”‚ - TextFormatter              â”‚
â”‚ - Level: INFO                â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Install Qt Message Handler   â”‚
â”‚ qInstallMessageHandler()     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Register in DI Container     â”‚
â”‚ as Singleton                 â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ready to Log â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Pseudocode Only

**Core Logging Logic**:
```
FUNCTION log(level, message, **context):
    # Create log record with metadata
    record = CREATE LogRecord(
        level=level,
        message=message,
        timestamp=NOW(),
        module=CALLING_MODULE,
        function=CALLING_FUNCTION,
        line=CALLING_LINE_NUMBER,
        thread=CURRENT_THREAD,
        extra=context
    )

    # Send to all handlers
    FOR handler IN handlers:
        IF record.level >= handler.level:
            formatted = handler.formatter.format(record)
            handler.emit(formatted)

    RETURN success
```

**File Rotation Logic** (automatic in RotatingFileHandler):
```
FUNCTION emit(log_message):
    IF current_file_size + message_size > MAX_SIZE:
        # Rotate files
        CLOSE current file
        RENAME jts.log â†’ jts.log.1
        RENAME jts.log.1 â†’ jts.log.2
        RENAME jts.log.2 â†’ jts.log.3
        RENAME jts.log.3 â†’ jts.log.4
        RENAME jts.log.4 â†’ jts.log.5
        DELETE jts.log.5  # Remove oldest
        CREATE new empty jts.log

    WRITE log_message to current file
```

**Qt Message Handler**:
```
FUNCTION qt_message_handler(msg_type, context, message):
    # Map Qt types to logging levels
    level = MAP qt_type:
        QtDebugMsg    â†’ DEBUG
        QtInfoMsg     â†’ INFO
        QtWarningMsg  â†’ WARNING
        QtCriticalMsg â†’ ERROR
        QtFatalMsg    â†’ CRITICAL

    # Extract Qt context
    file = context.file OR "unknown"
    line = context.line OR 0
    function = context.function OR "unknown"

    # Log with Qt prefix
    logger.log(
        level,
        f"[Qt] {message}",
        qt_file=file,
        qt_line=line,
        qt_function=function
    )
```

**JSON Formatter**:
```
FUNCTION format_json(log_record):
    data = {
        "timestamp": log_record.created (ISO 8601),
        "level": log_record.levelname,
        "message": log_record.getMessage(),
        "module": log_record.module,
        "function": log_record.funcName,
        "line": log_record.lineno,
        "thread": log_record.threadName
    }

    # Add extra context if present
    IF log_record has extra fields:
        FOR key, value IN log_record.extra:
            data[key] = value

    # Add exception info if present
    IF log_record.exc_info exists:
        data["exception"] = format_exception(log_record.exc_info)

    RETURN json.dumps(data, ensure_ascii=False)  # UTF-8!
```

### Design Decisions Table

#### Decision 1: JSON Files + Text Console

| Decision | Chosen | Why | Alternative Rejected |
|----------|--------|-----|---------------------|
| **Log Format** | **JSON for files, Text for console** | **Detailed Reasoning**: Different consumers have different needs. Files are parsed by tools (analytics, debugging), so they need structure. Console is read by humans during development, so it needs readability. Having both gives us the best of both worlds.<br><br>**Problem/Solution**:<br>- JSON everywhere: Hard for humans to read in console<br>- Text everywhere: Hard for tools to parse<br>- Hybrid approach: Perfect for both use cases<br><br>**Trade-offs**:<br>- **Gain**: Optimal format for each consumer<br>- **Lose**: Slight complexity (two formatters instead of one)<br><br>**Examples**:<br>```python<br># Console (human-friendly)<br>2025-12-28 10:30:45 ERROR Login failed<br><br># File (tool-friendly)<br>{"timestamp":"2025-12-28T10:30:45Z","level":"ERROR",...}<br>```<br> | **Single Format**: Rejected because:<br>1. JSON is hard to read in console during development<br>2. Plain text is hard to parse programmatically<br>3. Developers need quick scanning, tools need structure |

#### Decision 2: Size-Based Rotation (not time-based)

| Decision | Chosen | Why | Alternative Rejected |
|----------|--------|-----|---------------------|
| **Rotation Strategy** | **Size-based (10MB)** | **Detailed Reasoning**: Desktop applications have unpredictable usage patterns. Some users run the app 24/7, others once a week. Size-based rotation adapts to actual usageâ€”heavy logging rotates more often, light logging preserves history longer.<br><br>**Problem/Solution**:<br>- Time-based (daily): Light users get tiny fragmented files, heavy users get huge files<br>- Size-based: Files are consistently sized regardless of usage patterns<br><br>**Trade-offs**:<br>- **Gain**: Predictable file sizes, adapts to usage<br>- **Lose**: Can't say "give me yesterday's logs" (but can still search by timestamp)<br><br>**Concrete Example**:<br>Heavy user (10K logs/day):<br>- Time-based: 1 file/day Ã— 50MB = huge files<br>- Size-based: 5 rotations/day Ã— 10MB = manageable<br><br>Light user (100 logs/day):<br>- Time-based: 30 files Ã— 1KB = fragmented<br>- Size-based: 1 file covering weeks = consolidated<br> | **Time-Based Rotation** (daily, weekly): Rejected because:<br>1. Unpredictable file sizes (1KB to 1GB)<br>2. Doesn't adapt to usage patterns<br>3. Desktop apps don't have regular schedules like servers |

#### Decision 3: UTF-8 Encoding Always

| Decision | Chosen | Why | Alternative Rejected |
|----------|--------|-----|---------------------|
| **Text Encoding** | **UTF-8** | **Detailed Reasoning**: Our application targets Korean users, and Korean text requires Unicode support. UTF-8 is the universal standard that handles all languages, emojis, and special characters without issues. Python 3 defaults to UTF-8 internally, so it's the natural choice.<br><br>**Problem/Solution**:<br>```python<br># Korean text in logs<br>logger.info("ì‚¬ìš©ì ë¡œê·¸ì¸: í™ê¸¸ë™")<br><br># With UTF-8: âœ… Works perfectly<br># With ASCII: âŒ UnicodeEncodeError<br>```<br><br>**Trade-offs**:<br>- **Gain**: Support all languages, future-proof<br>- **Lose**: None (UTF-8 is the standard)<br><br>**Why It Matters**:<br>- Korean file names: "ì„¤ì •.json"<br>- Korean error messages: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"<br>- Korean user names: "í™ê¸¸ë™"<br>All must log correctly.<br> | **ASCII or Latin-1**: Rejected because:<br>1. Cannot represent Korean characters<br>2. Causes UnicodeEncodeError with non-Latin text<br>3. Not the modern standard |

#### Decision 4: Standard Library Only (no third-party loggers)

| Decision | Chosen | Why | Alternative Rejected |
|----------|--------|-----|---------------------|
| **Logging Library** | **Python stdlib `logging`** | **Detailed Reasoning**: Python's built-in logging module is battle-tested, feature-complete, and maintained as part of the language. It supports everything we need: levels, handlers, formatters, rotation. Using it means zero dependencies and guaranteed compatibility.<br><br>**Problem/Solution**:<br>Third-party loggers (loguru, structlog) add nice features but also:<br>- âŒ External dependency to manage<br>- âŒ Learning curve for team<br>- âŒ Version compatibility issues<br>- âœ… stdlib is always available, always compatible<br><br>**Trade-offs**:<br>- **Gain**: Zero dependencies, proven reliability<br>- **Lose**: More verbose configuration (but we only configure once)<br><br>**Features Comparison**:<br>```<br>Feature           stdlib  loguru  structlog<br>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€<br>Levels            âœ…      âœ…      âœ…<br>Handlers          âœ…      âœ…      âœ…<br>Rotation          âœ…      âœ…      âœ…<br>JSON format       âœ…      âœ…      âœ…<br>Dependencies      0       0       0<br>Learning curve    Low     Medium  High<br>```<br> | **Third-party loggers** (loguru, structlog): Rejected because:<br>1. External dependencies increase project complexity<br>2. Stdlib logging is sufficient for our needs<br>3. Team familiarity with stdlib<br>4. No need for advanced features like contextvars |

#### Decision 5: Integrate Qt Message Handler

| Decision | Chosen | Why | Alternative Rejected |
|----------|--------|-----|---------------------|
| **Qt Messages** | **Integrate with `qInstallMessageHandler`** | **Detailed Reasoning**: Qt framework emits many useful warnings and errors (resource loading, layout issues, deprecated APIs). These messages are critical for debugging but normally go to stderr and disappear. Integrating them into our logging system ensures we never miss important Qt diagnostics.<br><br>**Problem/Solution**:<br>```python<br># Without integration<br>Qt: QPixmap: Cannot load image.png  # Lost in stderr<br><br># With integration<br>2025-12-28 10:30:45 WARNING [Qt] QPixmap: Cannot load image.png<br># Logged, searchable, persistent<br>```<br><br>**Trade-offs**:<br>- **Gain**: Unified logging, Qt messages preserved<br>- **Lose**: Slight complexity (one more handler to setup)<br><br>**Concrete Example**:<br>Qt framework helps us catch bugs:<br>- "QLayout: Cannot add NULL widget" â†’ We forgot to create widget<br>- "QPixmap: Invalid size" â†’ Image resource missing<br>- All logged and debuggable<br> | **Separate Qt Logs**: Rejected because:<br>1. Qt messages get lost in stderr<br>2. Fragmented logging (app logs vs Qt logs)<br>3. Harder to correlate Qt errors with app behavior |

---

## 4. Implementation Strategy

### Development Phases

```
Phase 1: Basic Logger (2 hours)
â”œâ”€ Create Logger class
â”œâ”€ Implement log methods (debug, info, warning, error, critical)
â””â”€ Basic console output
    â†“
Phase 2: File Handling (2 hours)
â”œâ”€ Configure RotatingFileHandler
â”œâ”€ Implement JsonFormatter
â”œâ”€ Test rotation behavior
â””â”€ Handle file permission errors
    â†“
Phase 3: Console Formatting (1 hour)
â”œâ”€ Implement TextFormatter
â”œâ”€ Add color support (optional)
â””â”€ Configure console handler
    â†“
Phase 4: Qt Integration (2 hours)
â”œâ”€ Implement qt_message_handler
â”œâ”€ Map Qt types to levels
â”œâ”€ Install with qInstallMessageHandler
â””â”€ Test Qt message capture
    â†“
Phase 5: Testing & Polish (1 hour)
â”œâ”€ Unit tests for all components
â”œâ”€ Integration tests
â”œâ”€ Performance validation
â””â”€ UTF-8 encoding verification
```

**Timeline Visualization**:
```
Task                    â”‚ H1 â”‚ H2 â”‚ H3 â”‚ H4 â”‚ H5 â”‚ H6 â”‚ H7 â”‚ H8 â”‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
Basic Logger            â”‚ â–ˆâ–ˆ â”‚ â–ˆâ–ˆ â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â”‚
File Handling           â”‚    â”‚    â”‚ â–ˆâ–ˆ â”‚ â–ˆâ–ˆ â”‚    â”‚    â”‚    â”‚    â”‚
Console Formatting      â”‚    â”‚    â”‚    â”‚    â”‚ â–ˆâ–ˆ â”‚    â”‚    â”‚    â”‚
Qt Integration          â”‚    â”‚    â”‚    â”‚    â”‚    â”‚ â–ˆâ–ˆ â”‚ â–ˆâ–ˆ â”‚    â”‚
Testing & Polish        â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â”‚ â–ˆâ–ˆ â”‚
```

### Integration Points

**System Architecture**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  APPLICATION LAYER                      â”‚
â”‚                                                         â”‚
â”‚  All Services/Components                               â”‚
â”‚  â””â”€> Use Logger via DI Container                       â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â”‚ inject ILogger
                         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               INFRASTRUCTURE LAYER                      â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚         Logger (YOU ARE HERE)               â”‚       â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚       â”‚
â”‚  â”‚  â”‚ FileHandler  â”‚  â”‚ConsoleHandlerâ”‚        â”‚       â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚       â”‚
â”‚  â”‚         â”‚                 â”‚                 â”‚       â”‚
â”‚  â”‚         â–¼                 â–¼                 â”‚       â”‚
â”‚  â”‚    ~/.jts/logs/      stdout                â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                         â”‚
â”‚  Qt Framework                                          â”‚
â”‚  â””â”€> qInstallMessageHandler â†’ Logger                  â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Key Integration Points:
â‘  DI Container: Logger registered as singleton
â‘¡ All Services: Inject logger for debugging
â‘¢ Qt Framework: Messages redirected to logger
â‘£ Error Handler: Uses logger for error reporting
â‘¤ File System: Writes to ~/.jts/logs/
```

### Risk Mitigation

| Risk | Probability | Impact | Mitigation Strategy |
|------|-------------|--------|---------------------|
| Log file permission errors | Low | Medium | Catch file creation errors; fall back to console-only logging with warning |
| Disk space exhaustion | Low | Medium | Rotation limits total size to 50MB; document in user guide |
| Performance impact on I/O | Low | Low | Use buffered handlers (default); log asynchronously if bottleneck found |
| Qt handler installation fails | Low | Low | Catch exception, continue without Qt integration, log warning |
| Log format changes break parsers | Very Low | Low | Version log format in JSON; maintain backward compatibility |

---

## 5. Expected Behavior & Scenarios

### User Stories (Given/When/Then)

**Story 1: First Log Message Creates File**
```
GIVEN: Application starts for the first time
  AND: ~/.jts/logs/ directory doesn't exist
WHEN: First logger.info() call is made
THEN: Directory ~/.jts/logs/ is created
  AND: File ~/.jts/logs/jts.log is created
  AND: Message appears in console and file
```

**Story 2: Debug Messages Filter to File Only**
```
GIVEN: Logger configured with file=DEBUG, console=INFO
WHEN: logger.debug("Cache lookup") is called
THEN: Message appears in jts.log (JSON format)
  AND: Message does NOT appear in console
  AND: Subsequent logger.info() appears in both
```

**Story 3: Exception Logging Captures Traceback**
```
GIVEN: An exception occurs in try/except block
WHEN: logger.exception("Failed to process", exc_info=True)
THEN: Log includes exception message
  AND: Log includes full stack traceback
  AND: Traceback is in both file and console logs
  AND: JSON log has "exception" field with traceback
```

**Story 4: Log Rotation at 10MB**
```
GIVEN: jts.log file is 9.9MB
WHEN: A log message is written that exceeds 10MB
THEN: jts.log is renamed to jts.log.1
  AND: Previous jts.log.1 is renamed to jts.log.2
  AND: ... cascade continues to jts.log.4
  AND: jts.log.5 (oldest) is deleted
  AND: New empty jts.log is created
  AND: New message is written to new jts.log
  AND: No messages are lost during rotation
```

**Story 5: Qt Warning is Captured**
```
GIVEN: Qt message handler is installed
WHEN: Qt framework calls qWarning("Invalid pixmap")
THEN: Logger receives the message
  AND: Log includes "[Qt]" prefix
  AND: Log includes Qt context (file, line, function)
  AND: Message appears in both file and console
  AND: Level is WARNING (mapped from qWarning)
```

### Edge Cases

| Case | Expected Behavior | Rationale |
|------|-------------------|-----------|
| Log directory creation fails | Fall back to console-only logging + warning | Don't crash, degrade gracefully |
| Disk full during write | Handler catches exception, log to console | Prevent app crash |
| Korean characters in message | Encoded as UTF-8 in file | Full Unicode support |
| Exception with no traceback | Log message only, no exception field | Handle partial data gracefully |
| Qt handler already installed | Skip installation, log warning | Don't override existing handler |
| Log call from multiple threads | Messages serialized correctly | Python logging is thread-safe |
| Rotation during active write | RotatingFileHandler handles atomically | Prevent corruption |

### Performance Expectations

**Logging Performance Budget**:

```
Target: < 1ms per log call (overhead)

Breakdown per log call:
â”œâ”€ Create LogRecord:          ~0.05ms
â”œâ”€ Format as JSON:            ~0.10ms
â”œâ”€ Write to file (buffered):  ~0.20ms
â”œâ”€ Format as Text:            ~0.05ms
â”œâ”€ Write to console:          ~0.10ms
â””â”€ Total:                     ~0.50ms âœ… Well under 1ms

Note: Buffered I/O means writes are fast
Actual disk I/O happens in background
```

**Throughput Expectations**:
```
Scenario: Heavy logging session
- 1000 log messages
- Mixed levels (DEBUG to ERROR)
- Total time: < 500ms
- Throughput: 2000+ messages/second
```

---

## 6. Testing Strategy

### Coverage Pyramid

```
                  â–²
                 â•± â•²
                â•±   â•²         E2E: Full app with logging
               â•±â”€â”€â”€â”€â”€â•²        (~3 tests)
              â•±       â•²
             â•±         â•²
            â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•²     Integration: File rotation, Qt
           â•±             â•²    (~8 tests)
          â•±               â•²
         â•±                 â•²
        â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•²  Unit: Logger methods, formatters
       â•±                     â•² (~20 tests)
      â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•²
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Target Coverage: 80%+
- Unit tests: 70% of tests
- Integration: 25% of tests
- E2E: 5% of tests
```

### Key Scenarios

**Unit Test Scenarios**:
- âœ… Logger.debug() logs message at DEBUG level
- âœ… Logger.info() logs message at INFO level
- âœ… Logger.warning() logs message at WARNING level
- âœ… Logger.error() logs message at ERROR level
- âœ… Logger.critical() logs message at CRITICAL level
- âœ… Logger.exception() includes traceback
- âœ… JsonFormatter produces valid JSON
- âœ… JsonFormatter includes all required fields
- âœ… JsonFormatter handles extra context kwargs
- âœ… JsonFormatter handles exception info
- âœ… TextFormatter produces human-readable output
- âœ… TextFormatter includes timestamp and level
- âœ… Level filtering works (DEBUG filtered when level=INFO)
- âœ… UTF-8 encoding handles Korean characters

**Integration Test Scenarios**:
- âœ… Log file created in correct directory
- âœ… File rotation occurs at 10MB size limit
- âœ… 5 backup files maintained (jts.log.1 through .5)
- âœ… Oldest backup deleted when rotating
- âœ… Qt message handler captures Qt warnings
- âœ… Qt message handler maps types to levels correctly
- âœ… Multiple threads can log concurrently
- âœ… Permission error falls back to console-only

**Performance Test Scenarios**:
- âœ… Single log call completes in < 1ms
- âœ… 1000 log calls complete in < 1 second
- âœ… Memory usage remains stable (no leaks)

### Validation Approach

**Conceptual Validation Steps**:

1. **Functional Validation**
   - Log messages at each level
   - Verify file and console output
   - Test rotation behavior
   - Validate JSON structure

2. **Format Validation**
   - Parse JSON logs with `json.loads()`
   - Verify required fields present
   - Check UTF-8 encoding
   - Validate timestamps

3. **Integration Validation**
   - Bootstrap logger in DI container
   - Use logger from multiple services
   - Trigger Qt warnings
   - Verify unified logging

4. **Performance Validation**
   - Measure log call duration
   - Test high-volume logging
   - Monitor memory usage
   - Benchmark rotation overhead

5. **Edge Case Validation**
   - Test permission errors
   - Test disk full scenarios
   - Test concurrent logging
   - Test malformed messages

---

## Summary

### What We're Building

A comprehensive logging infrastructure that:
- Writes structured JSON logs to rotating files (10MB max, 5 backups)
- Displays human-readable text logs to console
- Captures Qt framework messages
- Supports all log levels with filtering
- Handles Unicode (Korean) characters
- Performs with < 1ms overhead per call

### Why It Matters

Enables effective debugging and monitoring by:
- Providing visibility into application behavior
- Persisting logs for later analysis
- Capturing Qt framework diagnostics
- Managing disk space automatically
- Supporting programmatic log analysis

### How It Works

1. Initialize logger with file and console handlers
2. Configure rotation (10MB, 5 backups) and formatters (JSON, text)
3. Install Qt message handler to capture framework messages
4. Log messages with appropriate levels throughout application
5. Rotation happens automatically when files reach size limit

### What Makes It Different

- **Dual Format**: JSON for files (parseable), text for console (readable)
- **Qt Integration**: Captures framework messages in unified system
- **Size-Based Rotation**: Adapts to actual usage patterns
- **UTF-8 First**: Full Unicode support for Korean and all languages
- **Standard Library**: Zero dependencies, maximum compatibility

---

**Next Steps**: Ready for implementation! See `E01-F04.spec.md` for detailed requirements and task breakdown.

**Questions?** All requirements are clearâ€”no open questions or clarifications needed.
