# Spec: E03-F01 - Domain Entities & Interfaces

---
# ============================================================================
# SPEC METADATA
# ============================================================================

# === IDENTIFICATION ===
id: E03-F01
clickup_task_id: ''
title: Domain Entities & Interfaces
type: feature

# === HIERARCHY ===
parent: E03
children:
  - E03-F01-T01
  - E03-F01-T02
  - E03-F01-T03
epic: E03
feature: F01
task: null
domain: broker

# === WORKFLOW ===
status: draft
priority: high

# === TRACKING ===
created: '2025-12-28'
updated: '2025-12-28'
due_date: ''
estimated_hours: 16
actual_hours: 0

# === METADATA ===
tags:
  - domain
  - entities
  - interfaces
  - rate-limiting
effort: medium
risk: low
---

**Status**: Draft
**Type**: Feature
**Parent**: E03
**Created**: 2025-12-28
**Updated**: 2025-12-28

## Executive Summary

Define the core domain model for broker integration, including value objects for financial data (Balance, Position, Order), abstract gateway interface for broker abstraction, and token bucket rate limiter for API throttling. This feature establishes the foundational abstractions that all broker implementations will use.

## Execution Flow

```
1. Define domain value objects
   → Create Balance, Position, Order dataclasses
   → Ensure immutability with frozen=True
2. Define enums for order types and statuses
   → OrderSide, OrderType, OrderStatus
   → BrokerType, AccountType, ConnectionStatus
3. Create IBrokerGateway abstract interface
   → Define all broker operation methods
   → Ensure async compatibility
4. Implement RateLimiter
   → Token bucket algorithm
   → Thread-safe operations
   → Return: SUCCESS with domain model ready
```

## User Stories

### Primary User Story
**As a** developer
**I want to** use well-defined domain entities
**So that** I can work with type-safe financial data across the application

### Additional Stories
- **As a** developer, **I want to** use a common broker interface, **So that** I can swap broker implementations
- **As a** developer, **I want to** use a rate limiter, **So that** API requests are throttled correctly

## Acceptance Scenarios

### Scenario 1: Create Balance Entity
**Given** account data from broker API
**When** Balance object is created
**Then** all fields are accessible and immutable

### Scenario 2: Use Rate Limiter
**Given** a rate limiter configured for 20 req/sec
**When** 20 requests are made in 1 second
**Then** all requests succeed, 21st blocks or fails

### Scenario 3: Implement Gateway Interface
**Given** IBrokerGateway interface
**When** new broker implementation is created
**Then** all abstract methods must be implemented

## Requirements

### Functional Requirements
- **FR-001**: Balance, Position, Order dataclasses with all required fields
- **FR-002**: IBrokerGateway abstract base class with all methods
- **FR-003**: RateLimiter implements token bucket algorithm
- **FR-004**: Domain entities are immutable (frozen dataclasses)

### Non-Functional Requirements
- **NFR-001**: RateLimiter is thread-safe
- **NFR-002**: Token refill is time-based and accurate
- **NFR-003**: All monetary values use Decimal for precision

### Technical Constraints
- **TC-001**: Use Python dataclasses for entities
- **TC-002**: Use ABC for interface definition
- **TC-003**: Use decimal.Decimal for financial values

## Key Entities

### Entity: Balance
- **Description**: Account balance value object
- **Key Attributes**: account_id, total_equity, cash_balance, buying_power, currency
- **Relationships**: Belongs to Account

### Entity: Position
- **Description**: Stock position with P&L calculations
- **Key Attributes**: symbol_code, symbol_name, quantity, avg_price, current_price
- **Relationships**: Belongs to Account

### Entity: Order
- **Description**: Trading order entity
- **Key Attributes**: id, account_id, symbol_code, side, order_type, quantity, price, status
- **Relationships**: Belongs to Account

## Dependencies

### Upstream Dependencies
- [ ] E02: Storage patterns for entity persistence

### Downstream Impact
- [ ] E03-F02: gRPC Gateway uses these interfaces
- [ ] E03-F03: Mock Gateway uses these interfaces
- [ ] E03-F04: Registry uses these entities

## Gate Checks

### Pre-Implementation Gates
- [x] No [NEEDS CLARIFICATION] markers remain
- [x] Performance requirements specified
- [x] All requirements testable

### Quality Gates
- [ ] Unit tests for all entities
- [ ] Unit tests for RateLimiter
- [ ] Test coverage > 80%

## Tasks Preview

| ID | Title | Effort | Wave | Dependencies |
|----|-------|--------|------|--------------|
| [E03-F01-T01](T01/E03-F01-T01.spec.md) | Define domain entities | M | 1 | - |
| [E03-F01-T02](T02/E03-F01-T02.spec.md) | Define IBrokerGateway interface | M | 2 | T01 |
| [E03-F01-T03](T03/E03-F01-T03.spec.md) | Implement RateLimiter | M | 1 | - |

**[P]** = Can be executed in parallel (T01, T03 are parallel in Wave 1)

## Success Criteria

### Acceptance Criteria
- [ ] All domain entities implemented
- [ ] IBrokerGateway interface complete
- [ ] RateLimiter working correctly
- [ ] 80% test coverage

### Definition of Done
- [ ] Code reviewed and approved
- [ ] Unit tests passing
- [ ] Documentation updated

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Decimal precision issues | Low | Medium | Use proper Decimal operations |
| Thread safety bugs | Low | High | Thorough testing with concurrency |

## Notes and Clarifications

### Decisions Made
- 2025-12-28: Use frozen dataclasses for immutability
- 2025-12-28: Use Decimal for all monetary values
- 2025-12-28: Token bucket for rate limiting

## Artifacts

### Input Documents
- [Parent Epic](../E03.spec.md)
- [PRD](../../../docs/prd.md)

### Output Artifacts
- [ ] `E03-F01.pre-docs.md` - Pre-implementation documentation
- [ ] `E03-F01.post-docs.md` - Post-implementation learnings

## References

- [Token Bucket Algorithm](https://en.wikipedia.org/wiki/Token_bucket)
- Python dataclasses documentation

---
*Template Version: 2.0.0 - Enhanced with Speckit features*
