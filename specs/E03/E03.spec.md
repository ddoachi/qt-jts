# Epic E03: Broker Integration

## Metadata

| Field | Value |
|-------|-------|
| Epic ID | E03 |
| Title | Broker Integration |
| Status | Draft |
| Platform | Cross-platform (via gRPC) |
| Dependencies | E01 (Framework), E02 (Storage) |
| PRD Sections | 5.0 |

---

## 1. Overview

### 1.1 Purpose

Integrate with Korean stock brokers for:
- Real-time and historical market data
- Account balance and position queries
- Order placement and management
- Rate limit compliance

### 1.2 Key Insight: gRPC Gateway

The existing JTS project has a **gRPC server running on Windows** that wraps the Creon COM API. This means:

- **Desktop app connects via gRPC** → fully cross-platform!
- **Reuse existing proto definitions** from `project-jts/jts/schemas/protobuf/`
- **Same patterns** as existing NestJS broker clients

```
┌─────────────────────────┐         ┌─────────────────────────┐
│  Qt Desktop App         │  gRPC   │  JTS gRPC Server        │
│  (Linux/macOS/Windows)  │────────►│  (Windows)              │
│                         │         │                         │
│  - BrokerGateway        │         │  - Creon COM wrapper    │
│  - Rate Limiter         │         │  - KIS REST client      │
└─────────────────────────┘         └─────────────────────────┘
```

### 1.3 Goals

1. **Unified Interface**: Same API regardless of underlying broker
2. **Cross-Platform**: All broker access via gRPC
3. **Rate Limit Aware**: Per-broker request throttling
4. **Testable**: Mock implementations for offline development

---

## 2. Architecture

### 2.1 Broker Abstraction

```
┌─────────────────────────────────────────────────────────────┐
│                      Domain Layer                            │
│  ┌───────────────────────────────────────────────────────┐  │
│  │ IBrokerGateway                                         │  │
│  │ ├─ get_symbols() -> list[Symbol]                       │  │
│  │ ├─ get_candles(symbol, timeframe, start, end)         │  │
│  │ ├─ get_balance(account_id) -> Balance                  │  │
│  │ ├─ get_positions(account_id) -> list[Position]        │  │
│  │ ├─ place_order(order) -> OrderResult                   │  │
│  │ └─ get_order_status(order_id) -> OrderStatus          │  │
│  └───────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   Infrastructure Layer                       │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────┐ │
│  │ GrpcBrokerGateway│ │ MockBrokerGateway│ │ RateLimiter │ │
│  │ (Production)     │ │ (Testing)        │ │             │ │
│  └─────────────────┘  └─────────────────┘  └─────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 Rate Limiter Design

```python
class RateLimiter:
    """Token bucket rate limiter"""

    def __init__(self, rate: int, per_seconds: int = 1):
        self._rate = rate
        self._per_seconds = per_seconds
        self._tokens = rate
        self._last_update = time.monotonic()
        self._lock = threading.Lock()

    def acquire(self, timeout: float = None) -> bool:
        """Acquire a token, blocking if necessary"""
        deadline = time.monotonic() + timeout if timeout else float('inf')

        while time.monotonic() < deadline:
            with self._lock:
                self._refill()
                if self._tokens >= 1:
                    self._tokens -= 1
                    return True
            time.sleep(0.01)

        return False

    def _refill(self) -> None:
        now = time.monotonic()
        elapsed = now - self._last_update
        self._tokens = min(
            self._rate,
            self._tokens + elapsed * (self._rate / self._per_seconds)
        )
        self._last_update = now

    @property
    def usage_ratio(self) -> float:
        """Current usage as ratio (0.0 - 1.0)"""
        with self._lock:
            self._refill()
            return 1.0 - (self._tokens / self._rate)
```

### 2.3 Connection Manager

```python
class BrokerConnectionManager:
    """Manages broker connections and health"""

    def __init__(self):
        self._connections: dict[str, BrokerConnection] = {}
        self._health_check_interval = 30  # seconds

    async def connect(self, broker_id: str, config: BrokerConfig) -> None:
        """Establish connection to broker"""
        connection = await self._create_connection(broker_id, config)
        self._connections[broker_id] = connection
        self._start_health_check(broker_id)

    async def disconnect(self, broker_id: str) -> None:
        """Close broker connection"""
        if broker_id in self._connections:
            await self._connections[broker_id].close()
            del self._connections[broker_id]

    def get_connection(self, broker_id: str) -> Optional[BrokerConnection]:
        return self._connections.get(broker_id)

    def get_status(self, broker_id: str) -> ConnectionStatus:
        conn = self._connections.get(broker_id)
        if not conn:
            return ConnectionStatus.DISCONNECTED
        return conn.status
```

---

## 3. Domain Entities

### 3.1 Broker Configuration

```python
@dataclass
class BrokerConfig:
    """Broker connection configuration"""
    broker_type: BrokerType  # KIS, CREON, KIWOOM
    grpc_host: str
    grpc_port: int
    rate_limit: int  # requests per second
    accounts: list[AccountConfig] = field(default_factory=list)

@dataclass
class AccountConfig:
    """Individual account configuration"""
    account_id: str
    account_name: str
    account_type: AccountType  # REAL, PAPER
    is_default: bool = False
```

### 3.2 Balance and Position

```python
@dataclass(frozen=True)
class Balance:
    """Account balance value object"""
    account_id: str
    total_equity: Decimal
    cash_balance: Decimal
    buying_power: Decimal
    currency: str = "KRW"

@dataclass(frozen=True)
class Position:
    """Position value object"""
    symbol_code: str
    symbol_name: str
    quantity: int
    avg_price: Decimal
    current_price: Decimal

    @property
    def market_value(self) -> Decimal:
        return self.current_price * self.quantity

    @property
    def unrealized_pnl(self) -> Decimal:
        return (self.current_price - self.avg_price) * self.quantity

    @property
    def unrealized_pnl_pct(self) -> Decimal:
        if self.avg_price == 0:
            return Decimal(0)
        return ((self.current_price - self.avg_price) / self.avg_price) * 100
```

### 3.3 Order

```python
@dataclass
class Order:
    """Order entity"""
    id: Optional[str]
    account_id: str
    symbol_code: str
    side: OrderSide  # BUY, SELL
    order_type: OrderType  # MARKET, LIMIT
    quantity: int
    price: Optional[Decimal] = None
    status: OrderStatus = OrderStatus.PENDING
    filled_quantity: int = 0
    filled_price: Optional[Decimal] = None
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)

    @property
    def is_filled(self) -> bool:
        return self.status == OrderStatus.FILLED

    @property
    def is_active(self) -> bool:
        return self.status in (OrderStatus.PENDING, OrderStatus.PARTIAL)
```

---

## 4. gRPC Integration

### 4.1 Proto Files (Reuse from JTS)

```protobuf
// From project-jts/jts/schemas/protobuf/market_data.proto
service MarketDataService {
    rpc GetSymbols(GetSymbolsRequest) returns (GetSymbolsResponse);
    rpc GetCandles(GetCandlesRequest) returns (stream CandleData);
    rpc GetQuote(GetQuoteRequest) returns (QuoteData);
    rpc StreamQuotes(StreamQuotesRequest) returns (stream QuoteData);
}

// From project-jts/jts/schemas/protobuf/trading.proto
service TradingService {
    rpc GetBalance(GetBalanceRequest) returns (BalanceResponse);
    rpc GetPositions(GetPositionsRequest) returns (PositionsResponse);
    rpc PlaceOrder(PlaceOrderRequest) returns (OrderResponse);
    rpc CancelOrder(CancelOrderRequest) returns (OrderResponse);
    rpc GetOrderStatus(GetOrderStatusRequest) returns (OrderStatusResponse);
}
```

### 4.2 gRPC Client Implementation

```python
class GrpcBrokerGateway(IBrokerGateway):
    """gRPC-based broker gateway"""

    def __init__(
        self,
        config: BrokerConfig,
        rate_limiter: RateLimiter
    ):
        self._config = config
        self._rate_limiter = rate_limiter
        self._channel: Optional[grpc.Channel] = None
        self._market_data_stub = None
        self._trading_stub = None

    async def connect(self) -> None:
        """Establish gRPC connection"""
        self._channel = grpc.aio.insecure_channel(
            f"{self._config.grpc_host}:{self._config.grpc_port}"
        )
        self._market_data_stub = MarketDataServiceStub(self._channel)
        self._trading_stub = TradingServiceStub(self._channel)

    async def get_candles(
        self,
        symbol: str,
        timeframe: str,
        start: datetime,
        end: datetime
    ) -> list[Candle]:
        """Fetch historical candles with rate limiting"""
        # Acquire rate limit token
        if not self._rate_limiter.acquire(timeout=30):
            raise RateLimitExceededError()

        request = GetCandlesRequest(
            symbol=symbol,
            timeframe=timeframe,
            start_time=start.isoformat(),
            end_time=end.isoformat()
        )

        candles = []
        async for candle_data in self._market_data_stub.GetCandles(request):
            candles.append(self._map_candle(candle_data))

        return candles

    def _map_candle(self, proto: CandleData) -> Candle:
        """Map protobuf to domain entity"""
        return Candle(
            timestamp=datetime.fromisoformat(proto.timestamp),
            open=Decimal(proto.open),
            high=Decimal(proto.high),
            low=Decimal(proto.low),
            close=Decimal(proto.close),
            volume=proto.volume
        )
```

### 4.3 Mock Gateway (Testing)

```python
class MockBrokerGateway(IBrokerGateway):
    """Mock broker for testing and offline development"""

    def __init__(self):
        self._symbols: dict[str, Symbol] = {}
        self._candles: dict[str, list[Candle]] = {}
        self._balance = Balance(
            account_id="MOCK-001",
            total_equity=Decimal("100000000"),
            cash_balance=Decimal("100000000"),
            buying_power=Decimal("100000000")
        )
        self._positions: list[Position] = []
        self._orders: dict[str, Order] = {}

    async def get_candles(
        self,
        symbol: str,
        timeframe: str,
        start: datetime,
        end: datetime
    ) -> list[Candle]:
        """Return mock candles or generate random ones"""
        key = f"{symbol}:{timeframe}"
        if key in self._candles:
            return [c for c in self._candles[key]
                   if start <= c.timestamp <= end]

        # Generate mock data
        return self._generate_mock_candles(start, end, timeframe)

    def _generate_mock_candles(
        self,
        start: datetime,
        end: datetime,
        timeframe: str
    ) -> list[Candle]:
        """Generate realistic mock candle data"""
        candles = []
        current = start
        price = Decimal("50000")  # Starting price

        while current <= end:
            # Random walk
            change = Decimal(str(random.gauss(0, 0.02)))
            open_price = price
            close_price = price * (1 + change)
            high_price = max(open_price, close_price) * Decimal("1.01")
            low_price = min(open_price, close_price) * Decimal("0.99")

            candles.append(Candle(
                timestamp=current,
                open=open_price,
                high=high_price,
                low=low_price,
                close=close_price,
                volume=random.randint(100000, 10000000)
            ))

            price = close_price
            current = self._next_timestamp(current, timeframe)

        return candles
```

---

## 5. Broker Registry

### 5.1 Interface (Following JTS Pattern)

```python
class IBrokerRegistry(ABC):
    """Central registry for broker management"""

    @abstractmethod
    def register(self, broker_id: str, gateway: IBrokerGateway) -> None:
        """Register a broker gateway"""
        ...

    @abstractmethod
    def unregister(self, broker_id: str) -> None:
        """Unregister a broker gateway"""
        ...

    @abstractmethod
    def get(self, broker_id: str) -> Optional[IBrokerGateway]:
        """Get broker gateway by ID"""
        ...

    @abstractmethod
    def list_all(self) -> list[BrokerInfo]:
        """List all registered brokers with status"""
        ...

    @abstractmethod
    def get_healthy(self) -> list[IBrokerGateway]:
        """Get all healthy broker gateways"""
        ...
```

### 5.2 Implementation

```python
class BrokerRegistry(IBrokerRegistry):
    """Broker registry implementation"""

    def __init__(self):
        self._brokers: dict[str, IBrokerGateway] = {}
        self._configs: dict[str, BrokerConfig] = {}
        self._lock = threading.RLock()

    def register(self, broker_id: str, gateway: IBrokerGateway) -> None:
        with self._lock:
            self._brokers[broker_id] = gateway

    def get(self, broker_id: str) -> Optional[IBrokerGateway]:
        with self._lock:
            return self._brokers.get(broker_id)

    def list_all(self) -> list[BrokerInfo]:
        with self._lock:
            return [
                BrokerInfo(
                    broker_id=broker_id,
                    broker_type=self._configs[broker_id].broker_type,
                    status=gateway.status,
                    rate_limit_usage=gateway.rate_limiter.usage_ratio
                )
                for broker_id, gateway in self._brokers.items()
            ]
```

---

## 6. UI Components

### 6.1 Broker Status Widget (PRD 5.0.2)

```
┌─────────────────────────────────────────────────────────────────────────┐
│ Broker & Account Management                                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│ KIS (한국투자증권)                                      [+ 계좌 추가]   │
│ ├─ 계좌 1: 50012345-01 (실전투자)         잔고: ₩52,340,000   [활성] ● │
│ ├─ 계좌 2: 50012345-02 (모의투자)         잔고: ₩100,000,000  [활성] ● │
│ └─ Rate Limit: 20 req/sec                 Used: 12 req/sec    [정상]   │
│                                                                          │
│ Creon (대신증권)                                        [+ 계좌 추가]   │
│ ├─ 계좌 1: 12345678 (위탁)                잔고: ₩28,500,000   [활성] ● │
│ └─ Rate Limit: 15 req/sec                 Used: 8 req/sec     [정상]   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 6.2 Rate Limit Indicator

```python
class RateLimitIndicator(QWidget):
    """Visual rate limit indicator"""

    def __init__(self, rate_limiter: RateLimiter, parent=None):
        super().__init__(parent)
        self._rate_limiter = rate_limiter
        self._setup_ui()
        self._start_update_timer()

    def _setup_ui(self):
        layout = QHBoxLayout(self)

        self._progress = QProgressBar()
        self._progress.setMaximum(100)
        self._progress.setTextVisible(False)
        layout.addWidget(self._progress)

        self._label = QLabel()
        layout.addWidget(self._label)

        self._status = QLabel()
        layout.addWidget(self._status)

    def _update(self):
        usage = self._rate_limiter.usage_ratio
        self._progress.setValue(int(usage * 100))

        rate = self._rate_limiter.rate
        used = int(usage * rate)
        self._label.setText(f"{used}/{rate} req/s")

        # Status color
        if usage < 0.7:
            self._status.setText("정상")
            self._status.setStyleSheet("color: green")
        elif usage < 0.9:
            self._status.setText("주의")
            self._status.setStyleSheet("color: orange")
        else:
            self._status.setText("제한")
            self._status.setStyleSheet("color: red")
```

---

## 7. Tasks Breakdown

| Task ID | Title | Effort | Dependencies |
|---------|-------|--------|--------------|
| E03-F01-T01 | Define domain entities (Balance, Position, Order) | M | E02 |
| E03-F01-T02 | Define IBrokerGateway interface | M | T01 |
| E03-F01-T03 | Implement RateLimiter | M | - |
| E03-F02-T01 | Generate Python gRPC stubs from protos | M | - |
| E03-F02-T02 | Implement GrpcBrokerGateway | L | F01, F02-T01 |
| E03-F02-T03 | Implement connection management | M | F02-T02 |
| E03-F03-T01 | Implement MockBrokerGateway | M | F01 |
| E03-F03-T02 | Create mock data generators | M | F03-T01 |
| E03-F04-T01 | Implement BrokerRegistry | M | F01, F02, F03 |
| E03-F04-T02 | Create broker configuration UI | L | F04-T01, E01 |
| E03-F05-T01 | Create RateLimitIndicator widget | M | F01-T03 |
| E03-F05-T02 | Create BrokerStatusWidget | L | F04-T01, F05-T01 |

---

## 8. Acceptance Criteria

### 8.1 Functional

- [ ] Connect to JTS gRPC server and fetch symbol list
- [ ] Fetch historical candles with rate limiting
- [ ] Query account balance and positions
- [ ] Place and cancel orders (paper trading mode)
- [ ] Display real-time rate limit usage

### 8.2 Non-Functional

- [ ] Rate limiter prevents exceeding broker limits
- [ ] Connection auto-reconnects on failure
- [ ] Graceful degradation when broker unavailable
- [ ] < 100ms latency for gRPC calls (local network)

### 8.3 Testing

- [ ] MockBrokerGateway enables full offline testing
- [ ] Unit tests for RateLimiter token bucket logic
- [ ] Integration tests against local gRPC server
- [ ] Test coverage > 80%

---

## 9. TDD Approach

### 9.1 Rate Limiter Tests

```python
class TestRateLimiter:
    def test_acquire_within_limit(self):
        limiter = RateLimiter(rate=10, per_seconds=1)

        for _ in range(10):
            assert limiter.acquire(timeout=0.1) is True

    def test_acquire_exceeds_limit(self):
        limiter = RateLimiter(rate=5, per_seconds=1)

        # Exhaust tokens
        for _ in range(5):
            limiter.acquire(timeout=0)

        # Next acquire should fail immediately
        assert limiter.acquire(timeout=0) is False

    def test_tokens_refill_over_time(self):
        limiter = RateLimiter(rate=10, per_seconds=1)

        # Exhaust all tokens
        for _ in range(10):
            limiter.acquire(timeout=0)

        # Wait for refill
        time.sleep(0.5)

        # Should have ~5 tokens back
        for _ in range(5):
            assert limiter.acquire(timeout=0) is True
```

### 9.2 Mock Gateway Tests

```python
class TestMockBrokerGateway:
    @pytest.fixture
    def gateway(self):
        return MockBrokerGateway()

    async def test_get_candles_returns_data(self, gateway):
        candles = await gateway.get_candles(
            symbol="005930",
            timeframe="1d",
            start=datetime(2024, 1, 1),
            end=datetime(2024, 1, 31)
        )

        assert len(candles) > 0
        assert all(isinstance(c, Candle) for c in candles)

    async def test_get_balance_returns_mock_data(self, gateway):
        balance = await gateway.get_balance("MOCK-001")

        assert balance.total_equity > 0
        assert balance.cash_balance > 0
```

---

## 10. Platform Notes

### 10.1 gRPC Server Requirements

The JTS gRPC server must be running on a Windows machine with:
- Creon HTS installed and logged in
- gRPC server listening on configured port
- Network accessible from desktop app

### 10.2 Development Setup

```bash
# Generate Python gRPC stubs
python -m grpc_tools.protoc \
    -I../../project-jts/jts/schemas/protobuf \
    --python_out=src/infrastructure/grpc/generated \
    --grpc_python_out=src/infrastructure/grpc/generated \
    market_data.proto trading.proto common.proto
```

### 10.3 Fallback Strategy

If gRPC server is unavailable:
1. Check cached data in local DuckDB
2. Use MockBrokerGateway for development
3. Display clear "Offline Mode" indicator to user

---

## 11. References

- [gRPC Python](https://grpc.io/docs/languages/python/)
- [Token Bucket Algorithm](https://en.wikipedia.org/wiki/Token_bucket)
- PRD Section 5.0: Broker & Account Management
- Existing JTS: `/home/joohan/dev/project-jts/jts/libs/grpc/`
