---
# ============================================================================
# SPEC METADATA
# ============================================================================

# === IDENTIFICATION ===
id: E07
clickup_task_id: ''
title: Market Scanner
type: epic

# === HIERARCHY ===
parent: null
children:
  - E07-F01
  - E07-F02
  - E07-F03
  - E07-F04
  - E07-F05
epic: E07
domain: scanner

# === WORKFLOW ===
status: draft
priority: high

# === TRACKING ===
created: '2025-12-28'
updated: '2025-12-28'
due_date: ''
estimated_hours: 80
actual_hours: 0

# === METADATA ===
tags:
  - scanner
  - formula
  - market-analysis
effort: epic
risk: medium
---

# Spec: E07 - Market Scanner

**Status**: Draft
**Type**: Epic
**Parent**: None (Top-level Epic)
**Created**: 2025-12-28
**Updated**: 2025-12-28

## Executive Summary

Find stocks matching custom-defined patterns across the entire market with volume surges, momentum breakouts, and technical signals. Includes reusable formula library with parameters, real-time and historical scanning modes, and export results for further analysis.

---

## 1. Overview

### 1.1 Purpose

Find stocks matching custom-defined patterns across the entire market:
- Volume surges, momentum breakouts, technical signals
- Reusable formula library with parameters
- Real-time and historical scanning modes
- Export results for further analysis

### 1.2 Goals

1. **Fast Scanning**: 500+ symbols scanned in < 30 seconds
2. **Flexible Formulas**: User-defined patterns with parameters
3. **Visual Results**: Chart preview and match details
4. **Organized Library**: Tag-based formula organization

---

## 2. Architecture

### 2.1 Scanner Flow

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           Scanner Workflow                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌──────────┐ │
│  │  Formula    │───►│  Config     │───►│  Execute    │───►│  Review  │ │
│  │  Selection  │    │  (Markets,  │    │  Scan       │    │  Results │ │
│  │             │    │   Period)   │    │             │    │          │ │
│  └─────────────┘    └─────────────┘    └─────────────┘    └──────────┘ │
│        │                                      │                  │      │
│        │    ┌─────────────────────────────────┘                  │      │
│        │    │                                                    │      │
│        ▼    ▼                                                    ▼      │
│  ┌─────────────┐                                          ┌──────────┐ │
│  │  Formula    │                                          │  Actions │ │
│  │  Library    │                                          │  - Chart │ │
│  │             │                                          │  - Export│ │
│  │  [Save]     │                                          │  - Pattern│ │
│  └─────────────┘                                          └──────────┘ │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 Component Structure

```
src/presentation/views/scanner/
├── scanner_view.py              # Main scanner view
├── formula_library_widget.py    # Formula library sidebar
├── scan_config_widget.py        # Scan configuration panel
├── scan_results_widget.py       # Results table and chart
├── formula_editor_dialog.py     # Create/edit formula dialog
└── match_details_widget.py      # Match detail panel
```

---

## 3. Domain Model

### 3.1 Scan Session

```python
@dataclass
class ScanSession:
    """A scanning session"""
    id: str
    formula: Formula
    config: ScanConfig
    status: ScanStatus  # PENDING, RUNNING, COMPLETED, FAILED
    results: Optional[ScanResults] = None
    created_at: datetime = field(default_factory=datetime.utcnow)
    completed_at: Optional[datetime] = None

@dataclass
class ScanConfig:
    """Scan configuration"""
    data_source: DataSource  # LOCAL, LIVE
    markets: list[Market]  # KOSPI, KOSDAQ, ETF
    timeframe: str  # 1m, 5m, 1h, 1d
    date_range: DateRange
    symbol_filter: Optional[SymbolFilter] = None
    parameters: dict[str, Any] = field(default_factory=dict)

@dataclass
class SymbolFilter:
    """Filter symbols before scanning"""
    sectors: list[str] = field(default_factory=list)
    min_market_cap: Optional[Decimal] = None
    max_market_cap: Optional[Decimal] = None
    include_symbols: list[str] = field(default_factory=list)
    exclude_symbols: list[str] = field(default_factory=list)

@dataclass
class ScanResults:
    """Scan results"""
    total_symbols_scanned: int
    total_matches: int
    matches: list[ScanMatch]
    execution_time_ms: float

@dataclass
class ScanMatch:
    """A single scan match"""
    symbol: str
    symbol_name: str
    match_time: datetime
    candle: Candle
    indicator_values: dict[str, float]
```

---

## 4. Use Cases

### 4.1 Run Scan Use Case

```python
class RunScanUseCase:
    """Execute a market scan"""

    def __init__(
        self,
        processing_engine: ProcessingEngine,
        symbol_repo: ISymbolRepository,
        scan_session_repo: IScanSessionRepository
    ):
        self._engine = processing_engine
        self._symbol_repo = symbol_repo
        self._session_repo = scan_session_repo

    async def execute(
        self,
        request: RunScanRequest,
        progress_callback: Callable[[ScanProgress], None] = None
    ) -> ScanSession:
        # Create session
        session = ScanSession(
            id=str(uuid.uuid4()),
            formula=request.formula,
            config=request.config,
            status=ScanStatus.PENDING
        )
        await self._session_repo.save(session)

        # Resolve symbols based on config
        symbols = await self._resolve_symbols(request.config)

        # Create processing job
        job = ProcessingJob(
            id=session.id,
            job_type=JobType.SCAN,
            symbols=symbols,
            timeframe=request.config.timeframe,
            date_range=request.config.date_range,
            formula=request.formula,
            parameters=request.config.parameters
        )

        # Execute scan
        session.status = ScanStatus.RUNNING
        await self._session_repo.save(session)

        def on_progress(completed, total):
            if progress_callback:
                progress_callback(ScanProgress(
                    session_id=session.id,
                    completed=completed,
                    total=total
                ))

        results = await self._engine.process_batch(job, on_progress)

        # Aggregate results
        aggregator = SignalAggregator()
        signals = aggregator.aggregate(results)

        session.results = ScanResults(
            total_symbols_scanned=len(symbols),
            total_matches=signals.total_matches,
            matches=self._convert_matches(signals.matches),
            execution_time_ms=sum(r.processing_time_ms for r in results)
        )
        session.status = ScanStatus.COMPLETED
        session.completed_at = datetime.utcnow()

        await self._session_repo.save(session)
        return session

    async def _resolve_symbols(self, config: ScanConfig) -> list[str]:
        """Get symbols based on config"""
        symbols = []

        for market in config.markets:
            market_symbols = await self._symbol_repo.get_by_market(market)
            symbols.extend([s.code for s in market_symbols])

        # Apply filter
        if config.symbol_filter:
            symbols = self._apply_filter(symbols, config.symbol_filter)

        return symbols
```

### 4.2 Manage Formula Library

```python
class FormulaLibraryUseCase:
    """Manage formula library"""

    def __init__(self, formula_repo: IFormulaRepository):
        self._repo = formula_repo

    async def create_formula(self, request: CreateFormulaRequest) -> Formula:
        """Create new formula"""
        # Parse to validate
        formula_service = FormulaService(self._repo)
        parsed = formula_service.parse(request.expression)

        formula = Formula(
            id=0,
            name=request.name,
            expression=request.expression,
            category=request.category,
            description=request.description,
            tags=request.tags,
            parameters=parsed.parameters
        )

        return await self._repo.save(formula)

    async def get_by_category(
        self,
        category: FormulaCategory
    ) -> list[Formula]:
        """Get formulas by category"""
        return await self._repo.get_by_category(category)

    async def search(self, query: str) -> list[Formula]:
        """Search formulas by name or tags"""
        return await self._repo.search(query)

    async def update_formula(
        self,
        formula_id: int,
        updates: FormulaUpdate
    ) -> Formula:
        """Update existing formula"""
        formula = await self._repo.get_by_id(formula_id)
        if not formula:
            raise FormulaNotFoundError(formula_id)

        # Apply updates
        if updates.name:
            formula.name = updates.name
        if updates.expression:
            formula.expression = updates.expression
        if updates.tags:
            formula.tags = updates.tags

        formula.version += 1
        return await self._repo.save(formula)
```

---

## 5. UI Components

### 5.1 Scanner View (PRD 6.3)

```
┌─────────────────────────────────────────────────────────────────────────┐
│ Scanner                                                                  │
├──────────────┬──────────────────────────────────────┬───────────────────┤
│              │                                      │                   │
│  Formula     │  Configuration                       │  Chart            │
│  Library     │  ├─ Markets: [KOSPI] [KOSDAQ]       │                   │
│              │  ├─ Timeframe: [일봉 ▼]              │  [Candlestick     │
│  ┌────────┐  │  ├─ Period: 2024-01 to 2024-12      │   chart showing   │
│  │Volume  │  │  └─ Parameters: Period=20           │   selected match] │
│  │Surge   │◄─┤                                      │                   │
│  ├────────┤  │  [▶ 스캔 실행]                       │                   │
│  │Golden  │  ├──────────────────────────────────────┤                   │
│  │Cross   │  │  Results (47 matches)                │  Match Details:   │
│  ├────────┤  │  ┌────────┬──────────┬─────────┐    │  ├─ Volume: 15M   │
│  │RSI     │  │  │Symbol  │ Time     │ Volume  │    │  ├─ Ratio: 3.2x  │
│  │Oversold│  │  ├────────┼──────────┼─────────┤    │  └─ Close: +1.4% │
│  └────────┘  │  │005930  │ 12-28    │ 3.2x    │◄───┤                   │
│              │  │000660  │ 12-27    │ 2.8x    │    │                   │
│  [+ 새 공식] │  └────────┴──────────┴─────────┘    │  [종목 추가]      │
│              │                                      │                   │
└──────────────┴──────────────────────────────────────┴───────────────────┘
```

### 5.2 Formula Library Widget

```python
class FormulaLibraryWidget(QWidget):
    """Formula library sidebar"""

    formula_selected = Signal(Formula)
    new_formula_requested = Signal()
    edit_formula_requested = Signal(Formula)

    def __init__(
        self,
        formula_use_case: FormulaLibraryUseCase,
        parent=None
    ):
        super().__init__(parent)
        self._use_case = formula_use_case
        self._setup_ui()
        self._load_formulas()

    def _setup_ui(self):
        layout = QVBoxLayout(self)

        # Search
        self._search_input = QLineEdit()
        self._search_input.setPlaceholderText("Search formulas...")
        self._search_input.textChanged.connect(self._on_search)
        layout.addWidget(self._search_input)

        # Category filter
        self._category_combo = QComboBox()
        self._category_combo.addItem("All", None)
        self._category_combo.addItem("Scan", FormulaCategory.SCAN)
        self._category_combo.addItem("Entry", FormulaCategory.ENTRY)
        self._category_combo.addItem("Exit", FormulaCategory.EXIT)
        self._category_combo.currentIndexChanged.connect(self._on_filter_changed)
        layout.addWidget(self._category_combo)

        # Formula list
        self._formula_list = QListWidget()
        self._formula_list.itemClicked.connect(self._on_formula_clicked)
        self._formula_list.itemDoubleClicked.connect(self._on_formula_double_clicked)
        layout.addWidget(self._formula_list)

        # New formula button
        self._new_button = QPushButton("+ 새 공식")
        self._new_button.clicked.connect(self.new_formula_requested.emit)
        layout.addWidget(self._new_button)

    async def _load_formulas(self):
        """Load formulas from repository"""
        category = self._category_combo.currentData()
        if category:
            formulas = await self._use_case.get_by_category(category)
        else:
            formulas = await self._use_case.get_all()

        self._formula_list.clear()
        for formula in formulas:
            item = QListWidgetItem(formula.name)
            item.setData(Qt.UserRole, formula)
            self._formula_list.addItem(item)
```

### 5.3 Scan Results Widget

```python
class ScanResultsWidget(QWidget):
    """Scan results table with chart preview"""

    match_selected = Signal(ScanMatch)
    export_requested = Signal(list)  # List of matches

    def __init__(self, parent=None):
        super().__init__(parent)
        self._matches: list[ScanMatch] = []
        self._setup_ui()

    def _setup_ui(self):
        layout = QVBoxLayout(self)

        # Header with count and export
        header = QHBoxLayout()
        self._count_label = QLabel("Results (0 matches)")
        self._export_button = QPushButton("CSV 내보내기")
        self._export_button.clicked.connect(self._on_export)
        header.addWidget(self._count_label)
        header.addStretch()
        header.addWidget(self._export_button)
        layout.addLayout(header)

        # Results table
        self._table = QTableWidget()
        self._table.setColumnCount(5)
        self._table.setHorizontalHeaderLabels([
            "Symbol", "Name", "Time", "Close", "Volume Ratio"
        ])
        self._table.setSelectionBehavior(QTableWidget.SelectRows)
        self._table.itemSelectionChanged.connect(self._on_selection_changed)
        layout.addWidget(self._table)

    def set_results(self, results: ScanResults):
        """Display scan results"""
        self._matches = results.matches
        self._count_label.setText(f"Results ({results.total_matches} matches)")

        self._table.setRowCount(len(results.matches))
        for i, match in enumerate(results.matches):
            self._table.setItem(i, 0, QTableWidgetItem(match.symbol))
            self._table.setItem(i, 1, QTableWidgetItem(match.symbol_name))
            self._table.setItem(i, 2, QTableWidgetItem(
                match.match_time.strftime("%Y-%m-%d")
            ))
            self._table.setItem(i, 3, QTableWidgetItem(
                f"₩{match.candle.close:,.0f}"
            ))
            vol_ratio = match.indicator_values.get('volume_ratio', 0)
            self._table.setItem(i, 4, QTableWidgetItem(f"{vol_ratio:.1f}x"))

    def _on_selection_changed(self):
        """Handle row selection"""
        rows = self._table.selectionModel().selectedRows()
        if rows:
            idx = rows[0].row()
            self.match_selected.emit(self._matches[idx])

    def _on_export(self):
        """Export matches to CSV"""
        self.export_requested.emit(self._matches)
```

### 5.4 Chart Preview Widget

```python
class ChartPreviewWidget(QWidget):
    """Candlestick chart with indicator overlay"""

    def __init__(
        self,
        candle_repo: ICandleRepository,
        parent=None
    ):
        super().__init__(parent)
        self._candle_repo = candle_repo
        self._setup_ui()

    def _setup_ui(self):
        layout = QVBoxLayout(self)

        # PyQtGraph chart
        self._chart = pg.PlotWidget()
        self._chart.setBackground('w')
        layout.addWidget(self._chart)

        # Match details
        self._details = MatchDetailsWidget()
        layout.addWidget(self._details)

    async def show_match(self, match: ScanMatch, formula: Formula):
        """Display chart for match"""
        # Load surrounding candles
        start = match.match_time - timedelta(days=60)
        end = match.match_time + timedelta(days=10)

        candles = await self._candle_repo.get_range(
            symbol_id=self._get_symbol_id(match.symbol),
            timeframe="1d",
            start=start,
            end=end
        )

        # Draw candlesticks
        self._draw_candlesticks(candles)

        # Mark the match point
        self._mark_match(match.match_time)

        # Update details
        self._details.set_match(match)

    def _draw_candlesticks(self, candles: list[Candle]):
        """Draw candlestick chart"""
        self._chart.clear()

        for i, candle in enumerate(candles):
            color = 'r' if candle.close < candle.open else 'g'

            # Draw body
            body = pg.BarGraphItem(
                x=[i], height=[abs(candle.close - candle.open)],
                width=0.6,
                y=[min(candle.open, candle.close)],
                brush=color
            )
            self._chart.addItem(body)

            # Draw wicks
            wick = pg.PlotCurveItem(
                x=[i, i], y=[candle.low, candle.high],
                pen=pg.mkPen(color, width=1)
            )
            self._chart.addItem(wick)

    def _mark_match(self, timestamp: datetime):
        """Add vertical line at match point"""
        # Find x position for timestamp
        # Add annotation
        pass
```

---

## 6. Hierarchical Structure

This epic has been split into **5 features** and **13 tasks** organized into **3 implementation waves**.

### 6.1 Features Overview

| Feature ID | Title | Complexity | Wave | Dependencies |
|------------|-------|------------|------|--------------|
| [E07-F01](F01/E07-F01.spec.md) | Domain Model | M | 1 | E06 |
| [E07-F02](F02/E07-F02.spec.md) | Scan Execution | L | 2 | F01, E06 |
| [E07-F03](F03/E07-F03.spec.md) | Formula Library | M | 1 | E05 |
| [E07-F04](F04/E07-F04.spec.md) | UI Components | XL | 3 | F01, F02, F03, E01 |
| [E07-F05](F05/E07-F05.spec.md) | Export | M | 2 | F01 |

### 6.2 Tasks Breakdown

| Task ID | Title | Complexity | Wave | Dependencies |
|---------|-------|------------|------|--------------|
| [E07-F01-T01](F01/T01/E07-F01-T01.spec.md) | Define ScanSession and ScanConfig entities | M | 1 | E06 |
| [E07-F01-T02](F01/T02/E07-F01-T02.spec.md) | Define ScanResults and ScanMatch | S | 1 | T01 |
| [E07-F02-T01](F02/T01/E07-F02-T01.spec.md) | Implement RunScanUseCase | L | 2 | F01, E06 |
| [E07-F02-T02](F02/T02/E07-F02-T02.spec.md) | Implement symbol resolution with filters | M | 2 | F02-T01 |
| [E07-F03-T01](F03/T01/E07-F03-T01.spec.md) | Implement FormulaLibraryUseCase | M | 1 | E05 |
| [E07-F03-T02](F03/T02/E07-F03-T02.spec.md) | Add formula versioning | S | 1 | F03-T01 |
| [E07-F04-T01](F04/T01/E07-F04-T01.spec.md) | Create ScannerView main layout | M | 3 | E01 |
| [E07-F04-T02](F04/T02/E07-F04-T02.spec.md) | Create FormulaLibraryWidget | L | 3 | F03, E01 |
| [E07-F04-T03](F04/T03/E07-F04-T03.spec.md) | Create ScanResultsWidget | L | 3 | F01, E01 |
| [E07-F04-T04](F04/T04/E07-F04-T04.spec.md) | Create ChartPreviewWidget | L | 3 | E01 |
| [E07-F04-T05](F04/T05/E07-F04-T05.spec.md) | Create FormulaEditorDialog | M | 3 | E05 |
| [E07-F05-T01](F05/T01/E07-F05-T01.spec.md) | Implement CSV export | M | 2 | F01 |
| [E07-F05-T02](F05/T02/E07-F05-T02.spec.md) | Implement Excel export | M | 2 | F05-T01 |

### 6.3 Wave Assignment

```
Wave 1 (Start immediately - no dependencies)
├── E07-F01-T01: Define ScanSession and ScanConfig (M)
├── E07-F01-T02: Define ScanResults and ScanMatch (S)
├── E07-F03-T01: Implement FormulaLibraryUseCase (M)
└── E07-F03-T02: Add formula versioning (S)

Wave 2 (Depends on Wave 1)
├── E07-F02-T01: Implement RunScanUseCase (L)
├── E07-F02-T02: Implement symbol resolution (M)
├── E07-F05-T01: Implement CSV export (M)
└── E07-F05-T02: Implement Excel export (M)

Wave 3 (Depends on Wave 1 & 2)
├── E07-F04-T01: Create ScannerView main layout (M)
├── E07-F04-T02: Create FormulaLibraryWidget (L)
├── E07-F04-T03: Create ScanResultsWidget (L)
├── E07-F04-T04: Create ChartPreviewWidget (L)
└── E07-F04-T05: Create FormulaEditorDialog (M)
```

### 6.4 Dependency Graph

```
E04 (Data Collection) ──────────┐
E05 (DSL) ──────────────┐       │
E06 (Processing Engine) │       │
        │               │       │
        ▼               ▼       ▼
    ┌───────┐       ┌───────┐  │
    │  F01  │       │  F03  │  │
    │Domain │       │Formula│  │
    │ Model │       │Library│  │
    └───┬───┘       └───┬───┘  │
        │               │      │
        ▼               │      │
    ┌───────┐           │      │
    │  F02  │◄──────────┘      │
    │ Scan  │                  │
    │Execution│                │
    └───┬───┘                  │
        │                      │
    ┌───┴───┐                  │
    │  F05  │                  │
    │Export │                  │
    └───────┘                  │
        │                      │
        ▼                      ▼
    ┌───────────────────────────┐
    │         F04 UI            │
    │   (All Widgets)           │
    └───────────────────────────┘
```

---

## 7. Acceptance Criteria (PRD 8.2)

### 7.1 Functional

- [ ] 500개 이상 종목 1년치 데이터 스캔 30초 이내 완료
- [ ] 스캔 진행률 실시간 표시
- [ ] 결과 CSV/Excel 내보내기 지원
- [ ] 커스텀 공식 저장/불러오기

### 7.2 UI/UX

- [ ] Formula library with search and categories
- [ ] Chart preview shows match context
- [ ] Results sortable by all columns

### 7.3 Testing

- [ ] Unit tests for RunScanUseCase
- [ ] Integration tests with real data
- [ ] UI tests for formula library
- [ ] Test coverage > 80%

---

## 8. References

- PRD Section 5.2: Market Scanner
- PRD Section 6.3: Scanner Screen
- E05: DSL Parser & Evaluator
- E06: Processing Engine
