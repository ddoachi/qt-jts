---
# ============================================================================
# SPEC METADATA
# ============================================================================

# === IDENTIFICATION ===
id: E07-F01-T02
clickup_task_id: '86ew020r7'
title: Define ScanResults and ScanMatch
type: task

# === HIERARCHY ===
parent: E07-F01
children: []
epic: E07
feature: F01
task: T02
domain: scanner

# === WORKFLOW ===
status: draft
priority: high

# === TRACKING ===
created: '2025-12-28'
updated: '2025-12-28'
due_date: ''
estimated_hours: 2
actual_hours: 0

# === METADATA ===
tags:
  - value-objects
  - results
  - dataclass
effort: small
risk: low
wave: 1
---

# Spec: E07-F01-T02 - Define ScanResults and ScanMatch

**Status**: Draft
**Type**: Task
**Parent**: [E07-F01](../E07-F01.spec.md)
**Created**: 2025-12-28
**Updated**: 2025-12-28

## Executive Summary

Create value objects for scan results: `ScanResults` for aggregated scan output with statistics, `ScanMatch` for individual matches, and `ScanProgress` for tracking scan execution progress.

## Execution Flow

```
1. Create ScanMatch value object
   → Define frozen dataclass with symbol, symbol_name, match_time, candle, indicator_values
   → Add convenience methods: get_indicator(), close_price, volume
   → Return: ScanMatch class

2. Create ScanResults value object
   → Define frozen dataclass with total_symbols_scanned, total_matches, matches, execution_time_ms
   → Add calculated properties: match_rate, avg_time_per_symbol_ms
   → Return: ScanResults class

3. Create ScanProgress value object
   → Define frozen dataclass with session_id, completed, total, current_symbol
   → Add calculated properties: progress_pct, elapsed_seconds, estimated_remaining_seconds
   → Return: SUCCESS with all value objects
```

## User Stories

### Primary User Story
**As a** developer
**I want to** have structured result objects
**So that** scan results can be displayed and exported consistently

## Acceptance Scenarios

### Scenario 1: Calculate Match Rate
**Given** results with 100 symbols scanned and 5 matches
**When** I access match_rate property
**Then** it returns 5.0

### Scenario 2: Zero Division Handling
**Given** results with 0 symbols scanned
**When** I access match_rate property
**Then** it returns 0.0 (not an error)

### Scenario 3: Get Indicator Value
**Given** a match with indicator_values {"volume_ratio": 3.2}
**When** I call match.get_indicator("volume_ratio")
**Then** it returns 3.2

### Scenario 4: Progress Estimation
**Given** progress with 50/100 completed in 10 seconds
**When** I access estimated_remaining_seconds
**Then** it returns approximately 10 seconds

## Requirements

### Functional Requirements
- **FR-001**: ScanResults MUST calculate match_rate as (matches/total)*100
- **FR-002**: ScanResults MUST handle zero symbols without error
- **FR-003**: ScanMatch MUST provide get_indicator with default value
- **FR-004**: ScanProgress MUST calculate progress percentage
- **FR-005**: ScanProgress MUST estimate remaining time

### Non-Functional Requirements
- **NFR-001**: Calculation < 1ms
- **NFR-002**: Memory per instance < 1KB

### Technical Constraints
- **TC-001**: Use frozen dataclasses for immutability
- **TC-002**: Use tuple for matches collection
- **TC-003**: Reference Candle type from E06

## Key Entities

### Entity: ScanMatch
```python
@dataclass(frozen=True)
class ScanMatch:
    symbol: str
    symbol_name: str
    match_time: datetime
    candle: Candle
    indicator_values: dict[str, float]

    def get_indicator(self, name: str, default: float = 0.0) -> float
    @property def close_price(self) -> float
    @property def volume(self) -> int
```

### Entity: ScanResults
```python
@dataclass(frozen=True)
class ScanResults:
    total_symbols_scanned: int
    total_matches: int
    matches: tuple[ScanMatch, ...]
    execution_time_ms: float

    @property def match_rate(self) -> float
    @property def avg_time_per_symbol_ms(self) -> float
```

### Entity: ScanProgress
```python
@dataclass(frozen=True)
class ScanProgress:
    session_id: str
    completed: int
    total: int
    current_symbol: str = ""
    started_at: datetime

    @property def progress_pct(self) -> float
    @property def elapsed_seconds(self) -> float
    @property def estimated_remaining_seconds(self) -> float
```

## Dependencies

### Upstream Dependencies
- [ ] E07-F01-T01: ScanSession references ScanResults
- [ ] E06: Candle type

### Downstream Impact
- [ ] E07-F02: RunScanUseCase creates these
- [ ] E07-F04-T03: ScanResultsWidget displays these
- [ ] E07-F05: Export uses these

## Gate Checks

### Pre-Implementation Gates
- [ ] E07-F01-T01 complete
- [ ] Candle type from E06 available

### Quality Gates
- [ ] All calculations tested
- [ ] Edge cases (zero division) tested
- [ ] 90% test coverage

## Success Criteria

### Acceptance Criteria
- [ ] ScanResults calculates statistics correctly
- [ ] ScanMatch provides indicator access
- [ ] ScanProgress estimates time accurately
- [ ] All objects are immutable

### Definition of Done
- [ ] Code reviewed
- [ ] Unit tests passing
- [ ] Type hints complete

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| Time estimation inaccuracy | Low | Low | Use simple linear projection |

## Artifacts

### Input Documents
- [Feature Spec](../E07-F01.spec.md)
- [T01 Spec](../T01/E07-F01-T01.spec.md)

### Output Artifacts
- [ ] `src/domain/value_objects/scan_results.py`

---
*Template Version: 2.0.0*
