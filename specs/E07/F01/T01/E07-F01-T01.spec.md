---
# ============================================================================
# SPEC METADATA
# ============================================================================

# === IDENTIFICATION ===
id: E07-F01-T01
clickup_task_id: '86ew020r5'
title: Define ScanSession and ScanConfig Entities
type: task

# === HIERARCHY ===
parent: E07-F01
children: []
epic: E07
feature: F01
task: T01
domain: scanner

# === WORKFLOW ===
status: draft
priority: high

# === TRACKING ===
created: '2025-12-28'
updated: '2025-12-28'
due_date: ''
estimated_hours: 4
actual_hours: 0

# === METADATA ===
tags:
  - entities
  - dataclass
  - validation
effort: medium
risk: low
wave: 1
---

# Spec: E07-F01-T01 - Define ScanSession and ScanConfig Entities

**Status**: Draft
**Type**: Task
**Parent**: [E07-F01](../E07-F01.spec.md)
**Created**: 2025-12-28
**Updated**: 2025-12-28

## Executive Summary

Create the core domain entities for scan sessions: `ScanSession` for tracking scanning lifecycle, `ScanConfig` for configuration parameters, `SymbolFilter` for filtering criteria, and `ScanStatus` enum for status tracking.

## Execution Flow

```
1. Create ScanStatus enum
   → Define values: PENDING, RUNNING, COMPLETED, FAILED, CANCELLED
   → Return: Enum class

2. Create SymbolFilter value object
   → Define frozen dataclass with sectors, market_cap, include/exclude
   → Add __post_init__ validation for market_cap range
   → If min > max: ERROR "min_market_cap cannot exceed max_market_cap"

3. Create ScanConfig value object
   → Define frozen dataclass with data_source, markets, timeframe, date_range
   → Add __post_init__ validation for timeframe and markets
   → If invalid timeframe: ERROR "Invalid timeframe: {value}"
   → If empty markets: ERROR "At least one market must be selected"

4. Create ScanSession entity
   → Define dataclass with id, formula, config, status, results
   → Add factory method create()
   → Add transition methods: start(), complete(), fail()
   → If invalid transition: ERROR "Cannot transition from {from} to {to}"
   → Return: SUCCESS with all entities
```

## User Stories

### Primary User Story
**As a** developer
**I want to** have well-typed domain entities for scan operations
**So that** the scanner can track sessions and configurations safely

## Acceptance Scenarios

### Scenario 1: Create Session
**Given** a valid formula and configuration
**When** I call ScanSession.create(formula, config)
**Then** a new session is created with unique ID and PENDING status

### Scenario 2: Valid Status Transition
**Given** a session in PENDING status
**When** I call session.start()
**Then** status becomes RUNNING and started_at is set

### Scenario 3: Invalid Status Transition
**Given** a session in COMPLETED status
**When** I call session.start()
**Then** InvalidStatusTransitionError is raised

### Scenario 4: Invalid Timeframe
**Given** timeframe "2h" (not in allowed list)
**When** I create a ScanConfig
**Then** ValueError is raised

## Requirements

### Functional Requirements
- **FR-001**: ScanSession MUST have unique ID generated via uuid4
- **FR-002**: ScanSession MUST validate status transitions
- **FR-003**: ScanConfig MUST validate timeframe against: 1m, 5m, 15m, 1h, 1d, 1w
- **FR-004**: ScanConfig MUST require at least one market
- **FR-005**: SymbolFilter MUST validate min_market_cap <= max_market_cap

### Non-Functional Requirements
- **NFR-001**: Entity creation < 1ms
- **NFR-002**: Memory per instance < 1KB

### Technical Constraints
- **TC-001**: Use Python dataclasses with frozen=True for value objects
- **TC-002**: Use tuple for immutable collections
- **TC-003**: Use Decimal for financial values

## Key Entities

### Entity: ScanSession
```python
@dataclass
class ScanSession:
    id: str
    formula: Formula
    config: ScanConfig
    status: ScanStatus = ScanStatus.PENDING
    results: Optional[ScanResults] = None
    created_at: datetime
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    error_message: Optional[str] = None
```

### Entity: ScanConfig
```python
@dataclass(frozen=True)
class ScanConfig:
    data_source: DataSource
    markets: tuple[Market, ...]
    timeframe: str
    date_range: DateRange
    symbol_filter: Optional[SymbolFilter] = None
    parameters: dict[str, Any]
```

### Entity: SymbolFilter
```python
@dataclass(frozen=True)
class SymbolFilter:
    sectors: tuple[str, ...]
    min_market_cap: Optional[Decimal] = None
    max_market_cap: Optional[Decimal] = None
    include_symbols: tuple[str, ...]
    exclude_symbols: tuple[str, ...]
```

## Dependencies

### Upstream Dependencies
- [ ] E06: DateRange, DataSource, Market types

### Downstream Impact
- [ ] E07-F01-T02: Uses ScanSession for ScanResults
- [ ] E07-F02: Uses all entities

## Gate Checks

### Pre-Implementation Gates
- [ ] E06 types available
- [ ] All attribute types defined

### Quality Gates
- [ ] All validation rules tested
- [ ] Status transitions tested
- [ ] 90% test coverage

## Success Criteria

### Acceptance Criteria
- [ ] ScanSession creates with unique ID
- [ ] Status transitions work correctly
- [ ] ScanConfig validates timeframe
- [ ] SymbolFilter validates market cap range
- [ ] All value objects are immutable

### Definition of Done
- [ ] Code reviewed
- [ ] Unit tests passing
- [ ] Type hints complete

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| E06 type changes | Low | Medium | Early integration |

## Artifacts

### Input Documents
- [Feature Spec](../E07-F01.spec.md)

### Output Artifacts
- [ ] `src/domain/entities/scan_session.py`
- [ ] `src/domain/value_objects/scan_config.py`
- [ ] `src/domain/enums/scan_status.py`

---
*Template Version: 2.0.0*
