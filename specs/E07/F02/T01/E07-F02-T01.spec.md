---
# ============================================================================
# SPEC METADATA
# ============================================================================

# === IDENTIFICATION ===
id: E07-F02-T01
clickup_task_id: '86ew020ra'
title: Implement RunScanUseCase
type: task

# === HIERARCHY ===
parent: E07-F02
children: []
epic: E07
feature: F02
task: T01
domain: scanner

# === WORKFLOW ===
status: draft
priority: high

# === TRACKING ===
created: '2025-12-28'
updated: '2025-12-28'
due_date: ''
estimated_hours: 8
actual_hours: 0

# === METADATA ===
tags:
  - use-case
  - orchestration
  - async
effort: large
risk: medium
wave: 2
---

# Spec: E07-F02-T01 - Implement RunScanUseCase

**Status**: Draft
**Type**: Task
**Parent**: [E07-F02](../E07-F02.spec.md)
**Created**: 2025-12-28
**Updated**: 2025-12-28

## Executive Summary

Implement the main scan orchestration use case that creates sessions, resolves symbols, executes processing jobs via E06 engine, and aggregates results with progress tracking.

## Execution Flow

```
1. Validate RunScanRequest
   → Check formula is not null
   → Check config is valid
   → If invalid: ERROR "Invalid scan request"

2. Create and persist ScanSession
   → Call ScanSession.create(formula, config)
   → Save to IScanSessionRepository
   → If save fails: ERROR "Failed to create session"

3. Resolve symbols
   → Call _resolve_symbols(config)
   → Get symbols for each market
   → Apply filters via SymbolFilterService
   → If no symbols: WARN "No symbols match criteria"

4. Create ProcessingJob
   → Build job with session.id, symbols, timeframe, formula
   → Set parameters from config

5. Execute scan
   → Transition session to RUNNING
   → Call engine.process_batch(job, on_progress)
   → On progress: invoke callback with ScanProgress
   → If error: transition to FAILED, return error

6. Aggregate results
   → Use SignalAggregator.aggregate(engine_results)
   → Create ScanResults with matches
   → Transition session to COMPLETED
   → Save session
   → Return: SUCCESS with RunScanResponse
```

## User Stories

### Primary User Story
**As a** trader
**I want to** scan the market for pattern matches
**So that** I can find trading opportunities

### Additional Stories
- **As a** trader, **I want to** see progress during scan, **So that** I know how long to wait

## Acceptance Scenarios

### Scenario 1: Successful Scan
**Given** a valid formula and KOSPI/KOSDAQ markets
**When** I execute the scan
**Then** I receive results with matching symbols

### Scenario 2: Progress Callback
**Given** a scan of 100 symbols
**When** the scan runs
**Then** progress callback is invoked with completed/total

### Scenario 3: Engine Error
**Given** the engine throws an exception
**When** during scan execution
**Then** session status is FAILED with error message

### Scenario 4: No Matches
**Given** a strict formula with no matches
**When** scan completes
**Then** results have 0 matches (not an error)

## Requirements

### Functional Requirements
- **FR-001**: MUST create session before starting scan
- **FR-002**: MUST persist session at each status change
- **FR-003**: MUST provide progress via callback
- **FR-004**: MUST aggregate engine results into ScanResults
- **FR-005**: MUST handle engine errors gracefully

### Non-Functional Requirements
- **NFR-001**: 500 symbols in < 30 seconds
- **NFR-002**: Memory < 500MB for 500 symbols

### Technical Constraints
- **TC-001**: Use async/await
- **TC-002**: Integrate with E06 ProcessingEngine
- **TC-003**: Use dependency injection

## Key Entities

### Class: RunScanUseCase
```python
class RunScanUseCase:
    def __init__(
        self,
        processing_engine: ProcessingEngine,
        symbol_repo: ISymbolRepository,
        scan_session_repo: IScanSessionRepository
    ): ...

    async def execute(
        self,
        request: RunScanRequest,
        progress_callback: Optional[Callable[[ScanProgress], None]] = None
    ) -> RunScanResponse: ...
```

### DTO: RunScanRequest
```python
@dataclass
class RunScanRequest:
    formula: Formula
    config: ScanConfig
```

### DTO: RunScanResponse
```python
@dataclass
class RunScanResponse:
    session: ScanSession
    success: bool
    error: Optional[str] = None
```

## Dependencies

### Upstream Dependencies
- [ ] E07-F01: Domain Model (ScanSession, ScanResults)
- [ ] E06: ProcessingEngine

### Downstream Impact
- [ ] E07-F02-T02: Uses this for symbol resolution
- [ ] E07-F04: UI calls this use case

## Gate Checks

### Pre-Implementation Gates
- [ ] E07-F01 complete
- [ ] E06 ProcessingEngine available
- [ ] Repository interfaces defined

### Quality Gates
- [ ] Unit tests with mocked engine
- [ ] Integration tests with real engine
- [ ] Performance test for 500 symbols

## Success Criteria

### Acceptance Criteria
- [ ] Scans complete successfully
- [ ] Progress callbacks work
- [ ] Errors handled gracefully
- [ ] 80% test coverage

### Definition of Done
- [ ] Code reviewed
- [ ] Tests passing
- [ ] Performance verified

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| Performance miss | Medium | High | Profile and optimize |
| Engine integration | Low | High | Early testing |

## Artifacts

### Input Documents
- [Feature Spec](../E07-F02.spec.md)

### Output Artifacts
- [ ] `src/application/use_cases/run_scan_use_case.py`
- [ ] `src/application/dto/scan_dto.py`
- [ ] `src/domain/repositories/scan_session_repository.py`

---
*Template Version: 2.0.0*
