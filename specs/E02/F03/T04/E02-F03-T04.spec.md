# Spec: E02-F03-T04 - Implement ClickHouseSymbolRepository

---
# ============================================================================
# SPEC METADATA
# ============================================================================

# === IDENTIFICATION ===
id: E02-F03-T04
clickup_task_id: '86ew01ykv'
title: Implement ClickHouseSymbolRepository
type: task

# === HIERARCHY ===
parent: E02-F03
children: []
epic: E02
feature: F03
task: T04
domain: storage

# === WORKFLOW ===
status: draft
priority: medium

# === TRACKING ===
created: '2025-12-28'
updated: '2025-12-28'
due_date: ''
estimated_hours: 4
actual_hours: 0

# === METADATA ===
tags: [infrastructure, clickhouse, repository, symbol]
effort: medium
risk: low
---

**Status**: Draft
**Type**: Task
**Parent**: [E02-F03 - Infrastructure Implementation](../E02-F03.spec.md)
**Created**: 2025-12-28
**Updated**: 2025-12-28

## Executive Summary

Implement the ISymbolRepository interface using ClickHouse for symbol metadata storage. Symbols represent stock information and are relatively low-volume compared to candles. Uses ReplacingMergeTree for upsert behavior based on updated_at timestamp.

## Execution Flow

```
1. Implement save()
   → Generate ID from code if not provided
   → Insert with updated_at timestamp
   → ReplacingMergeTree handles dedup
   → Return Symbol with ID

2. Implement lookup methods
   → get_by_id(): Reverse lookup from cache
   → get_by_code(): Direct query with FINAL
   → Cache ID mappings for efficiency

3. Implement query methods
   → get_by_market(): Filter by market enum
   → get_all_active(): Filter by is_active=1
   → search(): ILIKE pattern matching

4. Implement delete()
   → ALTER TABLE DELETE by code
   → OPTIMIZE TABLE FINAL
   → Remove from ID cache
   → Return: SUCCESS with all methods implemented
```

## User Stories

### Primary User Story
**As a** symbol manager
**I want to** persist symbol metadata to ClickHouse
**So that** symbol information is stored durably

### Additional Stories
- **As a** trader, **I want to** search symbols by name, **So that** I can find stocks easily

## Acceptance Scenarios

### Scenario 1: Save and Retrieve
**Given** new Symbol entity
**When** saving then retrieving by code
**Then** same symbol is returned

### Scenario 2: Search by Name
**Given** symbols with various names
**When** searching "Samsung"
**Then** matching symbols returned (case-insensitive)

### Scenario 3: Filter by Market
**Given** symbols in KOSPI and KOSDAQ
**When** querying by Market.KOSPI
**Then** only KOSPI symbols returned

### Scenario 4: Upsert Behavior
**Given** existing symbol
**When** saving updated version
**Then** new version replaces old via ReplacingMergeTree

## Requirements

### Functional Requirements
- **FR-001**: save() MUST upsert via ReplacingMergeTree
- **FR-002**: get_by_code() MUST use FINAL for accuracy
- **FR-003**: get_by_market() MUST filter by market
- **FR-004**: get_all_active() MUST filter is_active=1
- **FR-005**: search() MUST match code and name (case-insensitive)
- **FR-006**: delete() MUST ALTER DELETE and OPTIMIZE

### Non-Functional Requirements
- **NFR-001**: Symbol queries < 100ms
- **NFR-002**: Consistent ID generation from code

### Technical Constraints
- **TC-001**: Use FINAL for ReplacingMergeTree reads
- **TC-002**: Cache ID-to-code mappings

## Key Entities

### Class: ClickHouseSymbolRepository
```python
class ClickHouseSymbolRepository(ISymbolRepository):
    def __init__(self, ch_manager: ClickHouseManager): ...

    def save(self, symbol: Symbol) -> Symbol: ...
    def get_by_id(self, symbol_id: int) -> Optional[Symbol]: ...
    def get_by_code(self, code: str) -> Optional[Symbol]: ...
    def get_by_market(self, market: Market) -> list[Symbol]: ...
    def get_all_active(self) -> list[Symbol]: ...
    def search(self, query_str: str, limit: int = 20) -> list[Symbol]: ...
    def delete(self, symbol_id: int) -> bool: ...
```

## Dependencies

### Upstream Dependencies
- [ ] E02-F02-T01: ISymbolRepository interface
- [ ] E02-F03-T01: ClickHouseManager

### Downstream Impact
- [ ] E02-F04: Use cases use symbol lookups

## Gate Checks

### Pre-Implementation Gates
- [x] Interface methods defined
- [x] ClickHouseManager available

### Quality Gates
- [ ] Integration tests passing
- [ ] Test coverage > 90%

## Success Criteria

### Acceptance Criteria
- [ ] All interface methods implemented
- [ ] Search case-insensitive
- [ ] Consistent ID generation
- [ ] Behavior matches InMemory implementation

### Definition of Done
- [ ] Code reviewed
- [ ] Integration tests passing
- [ ] Documentation complete

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| ID cache inconsistency | Low | Medium | Clear cache on operations |

## Artifacts

### Output Artifacts
- [ ] `src/infrastructure/repositories/clickhouse/symbol_repository.py`
- [ ] `tests/integration/infrastructure/repositories/clickhouse/test_symbol_repository.py`

---
*Template Version: 2.0.0 - Enhanced with Speckit features*
