# Spec: E02-F03-T03 - Implement ClickHouseCandleRepository

---
# ============================================================================
# SPEC METADATA
# ============================================================================

# === IDENTIFICATION ===
id: E02-F03-T03
clickup_task_id: '86ew01ykn'
title: Implement ClickHouseCandleRepository
type: task

# === HIERARCHY ===
parent: E02-F03
children: []
epic: E02
feature: F03
task: T03
domain: storage

# === WORKFLOW ===
status: draft
priority: high

# === TRACKING ===
created: '2025-12-28'
updated: '2025-12-28'
due_date: ''
estimated_hours: 6
actual_hours: 0

# === METADATA ===
tags: [infrastructure, clickhouse, repository, candle]
effort: large
risk: medium
---

**Status**: Draft
**Type**: Task
**Parent**: [E02-F03 - Infrastructure Implementation](../E02-F03.spec.md)
**Created**: 2025-12-28
**Updated**: 2025-12-28

## Executive Summary

Implement the ICandleRepository interface using ClickHouse as the backend storage. This is a critical high-performance component that handles millions of candle records with batch inserts and efficient range queries using ClickHouse's columnar storage.

## Execution Flow

```
1. Implement save_many()
   → Convert Candle objects to row dictionaries
   → Batch insert via ClickHouseManager
   → Return count of inserted candles
   → If insert fails: ERROR "Candle insert failed"

2. Implement get_range()
   → Query with FINAL for deduplication
   → Filter by symbol, timeframe, date range
   → Convert rows to Candle objects
   → Return sorted list

3. Implement get_latest()
   → Query with ORDER BY timestamp DESC
   → Use LIMIT for count
   → Return reversed list (oldest first)

4. Implement metadata methods
   → get_coverage(): min/max timestamps
   → count(): total candles for symbol/timeframe
   → delete_range(): ALTER TABLE DELETE
   → Return: SUCCESS with all methods implemented
```

## User Stories

### Primary User Story
**As a** data pipeline
**I want to** persist candles to ClickHouse
**So that** historical data is stored durably

### Additional Stories
- **As a** backtesting engine, **I want to** fast range queries, **So that** I can retrieve historical data quickly

## Acceptance Scenarios

### Scenario 1: Batch Insert
**Given** ClickHouseCandleRepository
**When** saving 100,000 candles
**Then** operation completes in < 5 seconds

### Scenario 2: Range Query
**Given** candles stored for 2024
**When** querying Jan-Dec 2024
**Then** all candles returned sorted by timestamp

### Scenario 3: Deduplication
**Given** candles with duplicate timestamps inserted
**When** querying with FINAL
**Then** only latest version returned

### Scenario 4: Coverage Query
**Given** candles from 2024-01-01 to 2024-12-31
**When** calling get_coverage()
**Then** returns (2024-01-01, 2024-12-31)

## Requirements

### Functional Requirements
- **FR-001**: save_many() MUST batch insert candles
- **FR-002**: get_range() MUST use FINAL for accurate reads
- **FR-003**: get_latest() MUST return most recent candles
- **FR-004**: get_coverage() MUST return date boundaries
- **FR-005**: count() MUST return accurate count with FINAL
- **FR-006**: delete_range() MUST remove candles and OPTIMIZE

### Non-Functional Requirements
- **NFR-001**: Insert 100,000 candles in < 5 seconds
- **NFR-002**: Query 1,000,000 candles in < 1 second
- **NFR-003**: get_latest(count=1) in < 50ms

### Technical Constraints
- **TC-001**: Use FINAL keyword for ReplacingMergeTree
- **TC-002**: Use Decimal for price precision
- **TC-003**: Handle timezone-aware timestamps

## Key Entities

### Class: ClickHouseCandleRepository
```python
class ClickHouseCandleRepository(ICandleRepository):
    def __init__(self, ch_manager: ClickHouseManager): ...

    def save_many(
        self,
        symbol_id: int,
        timeframe: Timeframe,
        candles: list[Candle]
    ) -> int: ...

    def get_range(
        self,
        symbol_id: int,
        timeframe: Timeframe,
        start: datetime,
        end: datetime
    ) -> list[Candle]: ...

    def get_latest(
        self,
        symbol_id: int,
        timeframe: Timeframe,
        count: int = 1
    ) -> list[Candle]: ...

    def get_coverage(
        self,
        symbol_id: int,
        timeframe: Timeframe
    ) -> tuple[Optional[datetime], Optional[datetime]]: ...

    def count(self, symbol_id: int, timeframe: Timeframe) -> int: ...

    def delete_range(
        self,
        symbol_id: int,
        timeframe: Timeframe,
        start: datetime,
        end: datetime
    ) -> int: ...
```

## Dependencies

### Upstream Dependencies
- [ ] E02-F02-T01: ICandleRepository interface
- [ ] E02-F03-T01: ClickHouseManager

### Downstream Impact
- [ ] E02-F04-T01: ImportCandlesUseCase uses this
- [ ] E02-F04-T02: ExportCandlesUseCase uses this

## Gate Checks

### Pre-Implementation Gates
- [x] Interface methods defined
- [x] ClickHouseManager available

### Quality Gates
- [ ] Integration tests passing
- [ ] Performance benchmarks met
- [ ] Test coverage > 90%

## Success Criteria

### Acceptance Criteria
- [ ] All interface methods implemented
- [ ] Performance benchmarks pass
- [ ] Behavior matches InMemory implementation
- [ ] Decimal precision preserved

### Definition of Done
- [ ] Code reviewed
- [ ] Integration tests passing
- [ ] Performance verified
- [ ] Documentation complete

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| FINAL keyword performance | Medium | Medium | Index properly, limit query scope |
| Decimal conversion errors | Low | High | Use str conversion |

## Artifacts

### Output Artifacts
- [ ] `src/infrastructure/repositories/clickhouse/candle_repository.py`
- [ ] `tests/integration/infrastructure/repositories/clickhouse/test_candle_repository.py`

---
*Template Version: 2.0.0 - Enhanced with Speckit features*
