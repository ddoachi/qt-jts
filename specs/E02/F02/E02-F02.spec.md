# Spec: E02-F02 - Repository Interfaces

---
# ============================================================================
# SPEC METADATA
# ============================================================================

# === IDENTIFICATION ===
id: E02-F02
clickup_task_id: ''
title: Repository Interfaces
type: feature

# === HIERARCHY ===
parent: E02
children: [E02-F02-T01, E02-F02-T02]
epic: E02
feature: F02
domain: storage

# === WORKFLOW ===
status: draft
priority: high

# === TRACKING ===
created: '2025-12-28'
updated: '2025-12-28'
due_date: ''
estimated_hours: 8
actual_hours: 0

# === METADATA ===
tags: [repository, interfaces, ddd, abstraction]
effort: medium
risk: low
---

**Status**: Draft
**Type**: Feature
**Parent**: [E02 - Storage Layer](../E02.spec.md)
**Created**: 2025-12-28
**Updated**: 2025-12-28

## Executive Summary

Define abstract repository interfaces following the Repository Pattern. These interfaces decouple domain logic from data access implementation, enabling testability and flexibility in storage backends. Includes in-memory implementations for unit testing without database dependencies.

## Execution Flow

```
1. Define ICandleRepository interface
   → Abstract methods: save_many, get_range, get_latest, etc.
   → Type hints for all parameters and returns
   → If method not implemented: ERROR "Not implemented"

2. Define ISymbolRepository interface
   → Abstract methods: save, get_by_code, get_by_market, etc.
   → Consistent naming with other repositories

3. Define IFormulaRepository interface
   → Abstract methods: save, get_by_id, get_by_category, search
   → Support for tag-based queries

4. Implement InMemory repositories
   → InMemoryCandleRepository
   → InMemorySymbolRepository
   → InMemoryFormulaRepository
   → Return: SUCCESS with interfaces and test implementations
```

## User Stories

### Primary User Story
**As a** developer implementing use cases
**I want to** program against repository interfaces
**So that** I can swap storage implementations without changing business logic

### Additional Stories
- **As a** tester, **I want to** use in-memory repositories, **So that** I can test without databases
- **As an** architect, **I want to** abstract storage details, **So that** we can change databases later

## Acceptance Scenarios

### Scenario 1: Interface Contract
**Given** ICandleRepository interface
**When** implementing ClickHouseCandleRepository
**Then** all abstract methods must be implemented

### Scenario 2: In-Memory Testing
**Given** InMemoryCandleRepository
**When** saving and retrieving candles
**Then** behavior matches production repository

### Scenario 3: Interface Swap
**Given** use case using ICandleRepository
**When** switching from InMemory to ClickHouse implementation
**Then** no code changes required in use case

## Requirements

### Functional Requirements
- **FR-001**: ICandleRepository MUST define save_many, get_range, get_latest methods
- **FR-002**: ICandleRepository MUST define get_coverage, count, delete_range methods
- **FR-003**: ISymbolRepository MUST define save, get_by_id, get_by_code methods
- **FR-004**: ISymbolRepository MUST define get_by_market, get_all_active, search methods
- **FR-005**: IFormulaRepository MUST define save, get_by_id, get_by_category methods
- **FR-006**: IFormulaRepository MUST define get_by_tags, search, get_all, delete methods
- **FR-007**: All interfaces MUST use abstract base class (ABC)
- **FR-008**: In-memory implementations MUST pass same tests as production

### Non-Functional Requirements
- **NFR-001**: In-memory operations < 1ms for typical operations
- **NFR-002**: Type hints on all method signatures

### Technical Constraints
- **TC-001**: Use Python ABC for abstract classes
- **TC-002**: Interfaces in domain layer, implementations in infrastructure

## Key Entities

### Interface: ICandleRepository
```python
class ICandleRepository(ABC):
    @abstractmethod save_many(symbol_id, timeframe, candles) -> int
    @abstractmethod get_range(symbol_id, timeframe, start, end) -> list[Candle]
    @abstractmethod get_latest(symbol_id, timeframe, count) -> list[Candle]
    @abstractmethod get_coverage(symbol_id, timeframe) -> tuple[datetime, datetime]
    @abstractmethod count(symbol_id, timeframe) -> int
    @abstractmethod delete_range(symbol_id, timeframe, start, end) -> int
```

### Interface: ISymbolRepository
```python
class ISymbolRepository(ABC):
    @abstractmethod save(symbol) -> Symbol
    @abstractmethod get_by_id(symbol_id) -> Optional[Symbol]
    @abstractmethod get_by_code(code) -> Optional[Symbol]
    @abstractmethod get_by_market(market) -> list[Symbol]
    @abstractmethod get_all_active() -> list[Symbol]
    @abstractmethod search(query, limit) -> list[Symbol]
    @abstractmethod delete(symbol_id) -> bool
```

### Interface: IFormulaRepository
```python
class IFormulaRepository(ABC):
    @abstractmethod save(formula) -> Formula
    @abstractmethod get_by_id(formula_id) -> Optional[Formula]
    @abstractmethod get_by_category(category) -> list[Formula]
    @abstractmethod get_by_tags(tags) -> list[Formula]
    @abstractmethod search(query, limit) -> list[Formula]
    @abstractmethod get_all() -> list[Formula]
    @abstractmethod delete(formula_id) -> bool
```

## Dependencies

### Upstream Dependencies
- [ ] E02-F01: Domain entities (Symbol, Candle, Formula)

### Downstream Impact
- [ ] E02-F03: Infrastructure implements these interfaces
- [ ] E02-F04: Use cases depend on these interfaces

## Gate Checks

### Pre-Implementation Gates
- [x] All interface methods defined
- [x] Return types specified
- [x] Parameter types specified

### Quality Gates
- [ ] All interfaces documented
- [ ] In-memory implementations tested
- [ ] Test coverage > 95%

## Tasks Preview

### Implementation Tasks
- [ ] [E02-F02-T01](T01/E02-F02-T01.spec.md) Define repository interfaces
- [ ] [E02-F02-T02](T02/E02-F02-T02.spec.md) Implement InMemory repositories

## Success Criteria

### Acceptance Criteria
- [ ] All repository interfaces are abstract
- [ ] In-memory implementations fully functional
- [ ] Tests pass with in-memory repositories
- [ ] Interfaces documented with docstrings

### Definition of Done
- [ ] Code reviewed
- [ ] Unit tests passing
- [ ] Documentation complete
- [ ] Type hints verified

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| Interface changes break implementations | Medium | High | Version interfaces carefully |
| Missing method on interface | Low | Medium | Comprehensive design review |

## Notes and Clarifications

### Decisions Made
- 2025-12-28: Using ABC for interfaces instead of Protocol
- 2025-12-28: In-memory repos store data in dictionaries
- 2025-12-28: Interfaces in domain layer, not infrastructure

## Artifacts

### Input Documents
- [E02 - Storage Layer](../E02.spec.md)
- [E02-F01 - Domain Entities](../F01/E02-F01.spec.md)

### Output Artifacts
- [ ] `src/domain/repositories/candle_repository.py`
- [ ] `src/domain/repositories/symbol_repository.py`
- [ ] `src/domain/repositories/formula_repository.py`
- [ ] `src/infrastructure/repositories/in_memory/*.py`

---
*Template Version: 2.0.0 - Enhanced with Speckit features*
