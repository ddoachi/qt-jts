# Epic E02: Storage Layer

## Metadata

| Field | Value |
|-------|-------|
| Epic ID | E02 |
| Title | Storage Layer |
| Status | Draft |
| Platform | Cross-platform |
| Dependencies | E01 (Application Framework) |
| PRD Sections | 5.1.4, 5.1.5 |

---

## 1. Overview

### 1.1 Purpose

Integrate with existing JTS storage infrastructure for:
- Historical OHLCV candle data (millions of records)
- Scan formulas and discovered patterns
- Strategy definitions and backtest results
- Application metadata and caches

### 1.2 Goals

1. **Reuse Existing Infrastructure**: Leverage JTS ClickHouse and MongoDB
2. **High Performance**: Query 1M+ candles in < 1 second
3. **Consistency**: Share data with web-based JTS
4. **Testability**: Repository pattern with in-memory test implementations

---

## 2. Architecture

### 2.1 Database Strategy: Reuse JTS Infrastructure

**Existing JTS Databases** (from `project-jts/jts`):

| Database | Purpose | Access Method |
|----------|---------|---------------|
| **ClickHouse** | OHLCV candles, time-series data | Direct connection or gRPC |
| **MongoDB** | Formulas, strategies, configs | Direct connection or gRPC |
| **Redis** | Cache, rate limit state | Direct connection |

**Why Reuse Instead of New DB**:
- Data consistency between desktop and web apps
- No data duplication or sync issues
- Leverage existing schema and indexes
- Shared backtest results across platforms

### 2.2 Connection Options

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      Storage Access Options                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  Option A: Direct Connection (Recommended for local development)         │
│  ┌─────────────┐         ┌─────────────┐         ┌─────────────┐        │
│  │  Qt Desktop │────────►│ ClickHouse  │         │   MongoDB   │        │
│  │     App     │────────►│  (candles)  │         │  (configs)  │        │
│  └─────────────┘         └─────────────┘         └─────────────┘        │
│                                                                          │
│  Option B: Via gRPC (For remote/production)                              │
│  ┌─────────────┐         ┌─────────────┐         ┌─────────────┐        │
│  │  Qt Desktop │──gRPC──►│ JTS Backend │────────►│  Databases  │        │
│  │     App     │         │   Services  │         │             │        │
│  └─────────────┘         └─────────────┘         └─────────────┘        │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.3 ClickHouse Schema (Existing in JTS)

```sql
-- OHLCV candles table (existing in JTS)
CREATE TABLE candles (
    symbol String,
    exchange String,
    timeframe String,           -- 1m, 5m, 15m, 1h, 1d, 1w, 1M
    timestamp DateTime64(3),
    open Decimal64(4),
    high Decimal64(4),
    low Decimal64(4),
    close Decimal64(4),
    volume UInt64
) ENGINE = MergeTree()
ORDER BY (symbol, timeframe, timestamp);

-- Symbols metadata
CREATE TABLE symbols (
    code String,
    name String,
    market String,              -- KOSPI, KOSDAQ, ETF
    sector String,
    is_active UInt8,
    updated_at DateTime
) ENGINE = ReplacingMergeTree(updated_at)
ORDER BY code;
```

### 2.4 MongoDB Collections (Existing in JTS)

```javascript
// formulas collection
{
  _id: ObjectId,
  name: String,
  expression: String,
  category: String,             // scan, entry, exit, stop_loss
  description: String,
  tags: [String],
  parameters: [{
    name: String,
    dataType: String,
    defaultValue: Mixed,
    minValue: Number,
    maxValue: Number
  }],
  version: Number,
  createdAt: Date,
  updatedAt: Date
}

// strategies collection
{
  _id: ObjectId,
  name: String,
  description: String,
  entryFormulaId: ObjectId,
  exitFormulaId: ObjectId,
  stopLossRule: {
    type: String,               // formula, fixed_pct
    formulaId: ObjectId,
    percentage: Number
  },
  riskConfig: {
    positionSizePct: Number,
    maxPositions: Number,
    takeProfitPct: Number,
    maxDailyLossPct: Number
  },
  version: Number,
  createdAt: Date,
  updatedAt: Date
}

// backtest_results collection
{
  _id: ObjectId,
  strategyId: ObjectId,
  runAt: Date,
  config: {
    startDate: Date,
    endDate: Date,
    symbols: [String],
    initialCapital: Decimal128
  },
  metrics: {
    totalReturnPct: Number,
    sharpeRatio: Number,
    maxDrawdownPct: Number,
    winRate: Number,
    profitFactor: Number,
    totalTrades: Number
  },
  trades: [{
    symbol: String,
    side: String,
    entryTime: Date,
    entryPrice: Decimal128,
    exitTime: Date,
    exitPrice: Decimal128,
    quantity: Number,
    pnl: Decimal128,
    exitReason: String
  }]
}
```

### 2.5 Repository Layer

```
┌─────────────────────────────────────────────────────────┐
│                    Domain Layer                          │
│  ┌─────────────────────────────────────────────────┐   │
│  │ ISymbolRepository, ICandleRepository, etc.       │   │
│  │ (Abstract interfaces)                            │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│                 Infrastructure Layer                     │
│  ┌────────────────────┐  ┌──────────────────────────┐  │
│  │ClickHouseCandleRepo│  │ InMemorySymbolRepository │  │
│  │ MongoDFormulaRepo  │  │ (Testing)                │  │
│  │ (Production)       │  │                          │  │
│  └────────────────────┘  └──────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

---

## 3. Domain Entities

### 3.1 Symbol (Entity)

```python
@dataclass
class Symbol:
    """Stock symbol entity"""
    id: int
    code: str
    name: str
    market: Market  # Enum: KOSPI, KOSDAQ, ETF
    sector: Optional[str] = None
    is_active: bool = True

    def __post_init__(self):
        if not self.code:
            raise ValueError("Symbol code is required")
```

### 3.2 Candle (Value Object)

```python
@dataclass(frozen=True)
class Candle:
    """OHLCV candle - immutable value object"""
    timestamp: datetime
    open: Decimal
    high: Decimal
    low: Decimal
    close: Decimal
    volume: int

    @property
    def is_bullish(self) -> bool:
        return self.close > self.open

    @property
    def body_size(self) -> Decimal:
        return abs(self.close - self.open)

    @property
    def range(self) -> Decimal:
        return self.high - self.low
```

### 3.3 CandleSeries (Aggregate)

```python
class CandleSeries:
    """Collection of candles for a symbol/timeframe - Aggregate Root"""

    def __init__(
        self,
        symbol: Symbol,
        timeframe: Timeframe,
        candles: list[Candle]
    ):
        self._symbol = symbol
        self._timeframe = timeframe
        self._candles = sorted(candles, key=lambda c: c.timestamp)
        self._df: Optional[pd.DataFrame] = None

    @property
    def as_dataframe(self) -> pd.DataFrame:
        """Lazy conversion to pandas DataFrame for calculations"""
        if self._df is None:
            self._df = pd.DataFrame([
                asdict(c) for c in self._candles
            ])
            self._df.set_index('timestamp', inplace=True)
        return self._df

    def slice(self, start: datetime, end: datetime) -> 'CandleSeries':
        """Return subset of candles"""
        filtered = [c for c in self._candles
                   if start <= c.timestamp <= end]
        return CandleSeries(self._symbol, self._timeframe, filtered)
```

### 3.4 Formula (Entity)

```python
@dataclass
class Formula:
    """Scan/trading formula entity"""
    id: int
    name: str
    expression: str
    category: FormulaCategory  # SCAN, ENTRY, EXIT, STOP_LOSS
    description: Optional[str] = None
    tags: list[str] = field(default_factory=list)
    parameters: list[FormulaParameter] = field(default_factory=list)
    version: int = 1

    def with_parameters(self, **kwargs) -> str:
        """Return expression with parameters substituted"""
        result = self.expression
        for param in self.parameters:
            value = kwargs.get(param.name, param.default_value)
            result = result.replace(f":{param.name}", str(value))
        return result
```

---

## 4. Repository Interfaces

### 4.1 ICandleRepository

```python
from abc import ABC, abstractmethod

class ICandleRepository(ABC):
    """Repository interface for candle data"""

    @abstractmethod
    def save_many(self, symbol_id: int, timeframe: str,
                  candles: list[Candle]) -> int:
        """Save multiple candles, return count saved"""
        ...

    @abstractmethod
    def get_range(self, symbol_id: int, timeframe: str,
                  start: datetime, end: datetime) -> list[Candle]:
        """Get candles in date range"""
        ...

    @abstractmethod
    def get_latest(self, symbol_id: int, timeframe: str,
                   count: int = 1) -> list[Candle]:
        """Get most recent candles"""
        ...

    @abstractmethod
    def get_coverage(self, symbol_id: int, timeframe: str
                    ) -> tuple[Optional[datetime], Optional[datetime]]:
        """Get date range of stored data"""
        ...

    @abstractmethod
    def count(self, symbol_id: int, timeframe: str) -> int:
        """Count candles for symbol/timeframe"""
        ...

    @abstractmethod
    def delete_range(self, symbol_id: int, timeframe: str,
                     start: datetime, end: datetime) -> int:
        """Delete candles in range, return count deleted"""
        ...
```

### 4.2 ISymbolRepository

```python
class ISymbolRepository(ABC):
    """Repository interface for symbols"""

    @abstractmethod
    def save(self, symbol: Symbol) -> Symbol:
        """Save or update symbol"""
        ...

    @abstractmethod
    def get_by_code(self, code: str) -> Optional[Symbol]:
        """Find symbol by code"""
        ...

    @abstractmethod
    def get_by_market(self, market: Market) -> list[Symbol]:
        """Find all symbols in market"""
        ...

    @abstractmethod
    def get_all_active(self) -> list[Symbol]:
        """Get all active symbols"""
        ...

    @abstractmethod
    def search(self, query: str) -> list[Symbol]:
        """Search symbols by code or name"""
        ...
```

### 4.3 IFormulaRepository

```python
class IFormulaRepository(ABC):
    """Repository interface for formulas"""

    @abstractmethod
    def save(self, formula: Formula) -> Formula:
        """Save or update formula"""
        ...

    @abstractmethod
    def get_by_id(self, formula_id: int) -> Optional[Formula]:
        """Find formula by ID"""
        ...

    @abstractmethod
    def get_by_category(self, category: FormulaCategory) -> list[Formula]:
        """Find formulas by category"""
        ...

    @abstractmethod
    def search(self, query: str) -> list[Formula]:
        """Search formulas by name or tags"""
        ...

    @abstractmethod
    def delete(self, formula_id: int) -> bool:
        """Delete formula"""
        ...
```

---

## 5. Infrastructure Implementation

### 5.1 ClickHouse Connection Manager

```python
from clickhouse_driver import Client

class ClickHouseManager:
    """Manages ClickHouse connection lifecycle"""

    def __init__(self, host: str = 'localhost', port: int = 9000,
                 database: str = 'jts'):
        self._host = host
        self._port = port
        self._database = database
        self._client: Optional[Client] = None

    def connect(self) -> Client:
        if self._client is None:
            self._client = Client(
                host=self._host,
                port=self._port,
                database=self._database
            )
        return self._client

    def execute(self, query: str, params: dict = None) -> Any:
        return self.connect().execute(query, params or {})

    def close(self) -> None:
        if self._client:
            self._client.disconnect()
            self._client = None

    def __enter__(self):
        return self.connect()

    def __exit__(self, *args):
        self.close()
```

### 5.2 MongoDB Connection Manager

```python
from pymongo import MongoClient

class MongoDBManager:
    """Manages MongoDB connection lifecycle"""

    def __init__(self, uri: str = 'mongodb://localhost:27017',
                 database: str = 'jts'):
        self._uri = uri
        self._database_name = database
        self._client: Optional[MongoClient] = None

    @property
    def db(self):
        if self._client is None:
            self._client = MongoClient(self._uri)
        return self._client[self._database_name]

    def close(self) -> None:
        if self._client:
            self._client.close()
            self._client = None
```

### 5.3 ClickHouse Candle Repository

```python
class ClickHouseCandleRepository(ICandleRepository):
    """ClickHouse implementation of candle repository"""

    def __init__(self, ch_manager: ClickHouseManager):
        self._ch = ch_manager

    def save_many(self, symbol_id: int, timeframe: str,
                  candles: list[Candle]) -> int:
        if not candles:
            return 0

        # ClickHouse batch insert
        data = [
            {
                'symbol': symbol_id,
                'timeframe': timeframe,
                'timestamp': c.timestamp,
                'open': float(c.open),
                'high': float(c.high),
                'low': float(c.low),
                'close': float(c.close),
                'volume': c.volume
            }
            for c in candles
        ]
        self._ch.execute(
            'INSERT INTO candles VALUES',
            data
        )
        return len(candles)

    def get_range(self, symbol_id: int, timeframe: str,
                  start: datetime, end: datetime) -> list[Candle]:
        query = """
            SELECT timestamp, open, high, low, close, volume
            FROM candles
            WHERE symbol = %(symbol)s AND timeframe = %(timeframe)s
              AND timestamp >= %(start)s AND timestamp <= %(end)s
            ORDER BY timestamp
        """
        result = self._ch.execute(query, {
            'symbol': symbol_id,
            'timeframe': timeframe,
            'start': start,
            'end': end
        })
        return [
            Candle(
                timestamp=row[0],
                open=Decimal(str(row[1])),
                high=Decimal(str(row[2])),
                low=Decimal(str(row[3])),
                close=Decimal(str(row[4])),
                volume=row[5]
            )
            for row in result
        ]
```

### 5.4 MongoDB Formula Repository

```python
from bson import ObjectId

class MongoDBFormulaRepository(IFormulaRepository):
    """MongoDB implementation of formula repository"""

    def __init__(self, mongo_manager: MongoDBManager):
        self._db = mongo_manager.db
        self._collection = self._db.formulas

    def save(self, formula: Formula) -> Formula:
        doc = {
            'name': formula.name,
            'expression': formula.expression,
            'category': formula.category.value,
            'description': formula.description,
            'tags': formula.tags,
            'parameters': [asdict(p) for p in formula.parameters],
            'version': formula.version,
            'updatedAt': datetime.utcnow()
        }

        if formula.id:
            self._collection.update_one(
                {'_id': ObjectId(formula.id)},
                {'$set': doc}
            )
        else:
            doc['createdAt'] = datetime.utcnow()
            result = self._collection.insert_one(doc)
            formula = replace(formula, id=str(result.inserted_id))

        return formula

    def get_by_id(self, formula_id: str) -> Optional[Formula]:
        doc = self._collection.find_one({'_id': ObjectId(formula_id)})
        if not doc:
            return None
        return self._doc_to_formula(doc)

    def get_by_category(self, category: FormulaCategory) -> list[Formula]:
        docs = self._collection.find({'category': category.value})
        return [self._doc_to_formula(doc) for doc in docs]

    def _doc_to_formula(self, doc: dict) -> Formula:
        return Formula(
            id=str(doc['_id']),
            name=doc['name'],
            expression=doc['expression'],
            category=FormulaCategory(doc['category']),
            description=doc.get('description'),
            tags=doc.get('tags', []),
            parameters=[FormulaParameter(**p) for p in doc.get('parameters', [])],
            version=doc.get('version', 1)
        )
```

### 5.5 In-Memory Repository (Testing)

```python
class InMemoryCandleRepository(ICandleRepository):
    """In-memory implementation for testing"""

    def __init__(self):
        self._data: dict[tuple[int, str], list[Candle]] = {}

    def save_many(self, symbol_id: int, timeframe: str,
                  candles: list[Candle]) -> int:
        key = (symbol_id, timeframe)
        if key not in self._data:
            self._data[key] = []

        # Remove duplicates and add new
        existing_timestamps = {c.timestamp for c in self._data[key]}
        new_candles = [c for c in candles
                      if c.timestamp not in existing_timestamps]
        self._data[key].extend(new_candles)
        self._data[key].sort(key=lambda c: c.timestamp)
        return len(candles)

    def get_range(self, symbol_id: int, timeframe: str,
                  start: datetime, end: datetime) -> list[Candle]:
        key = (symbol_id, timeframe)
        if key not in self._data:
            return []
        return [c for c in self._data[key]
               if start <= c.timestamp <= end]
```

---

## 6. Data Management Use Cases

### 6.1 Candle Import Use Case

```python
class ImportCandlesUseCase:
    """Use case for importing candle data"""

    def __init__(
        self,
        candle_repo: ICandleRepository,
        symbol_repo: ISymbolRepository
    ):
        self._candle_repo = candle_repo
        self._symbol_repo = symbol_repo

    def execute(self, request: ImportCandlesRequest) -> ImportCandlesResult:
        # Validate symbol exists
        symbol = self._symbol_repo.get_by_code(request.symbol_code)
        if not symbol:
            raise SymbolNotFoundError(request.symbol_code)

        # Check for existing data
        existing_start, existing_end = self._candle_repo.get_coverage(
            symbol.id, request.timeframe
        )

        # Filter out already imported candles if incremental
        candles_to_import = request.candles
        if request.incremental and existing_end:
            candles_to_import = [
                c for c in request.candles
                if c.timestamp > existing_end
            ]

        # Save candles
        count = self._candle_repo.save_many(
            symbol.id, request.timeframe, candles_to_import
        )

        return ImportCandlesResult(
            symbol_code=request.symbol_code,
            imported_count=count,
            skipped_count=len(request.candles) - count
        )
```

---

## 7. Tasks Breakdown

| Task ID | Title | Effort | Dependencies |
|---------|-------|--------|--------------|
| E02-F01-T01 | Create domain entities (Symbol, Candle, Formula) | M | E01 |
| E02-F01-T02 | Create value objects and enums | S | T01 |
| E02-F01-T03 | Implement CandleSeries aggregate | M | T01, T02 |
| E02-F02-T01 | Define repository interfaces | M | T01 |
| E02-F02-T02 | Implement InMemory repositories (testing) | M | F02-T01 |
| E02-F03-T01 | Create ClickHouseManager connection wrapper | M | E01 |
| E02-F03-T02 | Create MongoDBManager connection wrapper | M | E01 |
| E02-F03-T03 | Implement ClickHouseCandleRepository | L | F02-T01, F03-T01 |
| E02-F03-T04 | Implement ClickHouseSymbolRepository | M | F02-T01, F03-T01 |
| E02-F03-T05 | Implement MongoDBFormulaRepository | M | F02-T01, F03-T02 |
| E02-F03-T06 | Implement MongoDBStrategyRepository | M | F02-T01, F03-T02 |
| E02-F04-T01 | Create ImportCandlesUseCase | M | F02, F03 |
| E02-F04-T02 | Create ExportCandlesUseCase | M | F02, F03 |
| E02-F04-T03 | Create data validation utilities | M | T01 |

---

## 8. Acceptance Criteria

### 8.1 Performance

- [ ] Insert 100,000 candles in < 5 seconds (ClickHouse batch insert)
- [ ] Query 1,000,000 candles in < 1 second (ClickHouse columnar scan)
- [ ] MongoDB formula/strategy CRUD < 100ms per operation

### 8.2 Reliability

- [ ] Connection pooling and retry logic for both databases
- [ ] Graceful handling of network failures (remote databases)
- [ ] Data consistency with existing web-based JTS

### 8.3 Testing

- [ ] All repository interfaces have in-memory implementations
- [ ] Unit tests use in-memory repositories
- [ ] Integration tests verify ClickHouse/MongoDB implementations
- [ ] Test coverage > 85% for storage layer

---

## 9. TDD Approach

### 9.1 Test First Example

```python
# RED: Write failing test
class TestCandleRepository:
    def test_save_and_retrieve_candles(self):
        repo = InMemoryCandleRepository()
        candles = [
            Candle(datetime(2024, 1, 1), Decimal("100"), Decimal("105"),
                   Decimal("99"), Decimal("103"), 1000000),
            Candle(datetime(2024, 1, 2), Decimal("103"), Decimal("108"),
                   Decimal("102"), Decimal("107"), 1200000),
        ]

        repo.save_many(symbol_id=1, timeframe="1d", candles=candles)

        result = repo.get_range(
            symbol_id=1, timeframe="1d",
            start=datetime(2024, 1, 1),
            end=datetime(2024, 1, 2)
        )

        assert len(result) == 2
        assert result[0].close == Decimal("103")
        assert result[1].volume == 1200000

# GREEN: Implement minimum code to pass
# REFACTOR: Clean up
```

### 9.2 Integration Test

```python
class TestClickHouseCandleRepository:
    @pytest.fixture
    def ch_manager(self):
        # Use test database or Docker container
        manager = ClickHouseManager(
            host='localhost',
            database='jts_test'
        )
        yield manager
        manager.close()

    def test_candle_persistence(self, ch_manager):
        repo = ClickHouseCandleRepository(ch_manager)
        # ... test actual database operations


class TestMongoDBFormulaRepository:
    @pytest.fixture
    def mongo_manager(self):
        manager = MongoDBManager(
            uri='mongodb://localhost:27017',
            database='jts_test'
        )
        yield manager
        # Clean up test data
        manager.db.formulas.delete_many({})
        manager.close()

    def test_formula_crud(self, mongo_manager):
        repo = MongoDBFormulaRepository(mongo_manager)
        # ... test actual database operations
```

---

## 10. References

- [ClickHouse Python Driver](https://clickhouse-driver.readthedocs.io/)
- [PyMongo Documentation](https://pymongo.readthedocs.io/)
- [Repository Pattern](https://martinfowler.com/eaaCatalog/repository.html)
- PRD Section 5.1: Historical Data Collection
- Existing JTS: `project-jts/jts` - ClickHouse & MongoDB schemas
