# Epic E02: Storage Layer

## Metadata

| Field | Value |
|-------|-------|
| Epic ID | E02 |
| Title | Storage Layer |
| Status | Draft |
| Platform | Cross-platform |
| Dependencies | E01 (Application Framework) |
| PRD Sections | 5.1.4, 5.1.5 |

---

## 1. Overview

### 1.1 Purpose

Implement a robust local storage layer for:
- Historical OHLCV candle data (millions of records)
- Scan formulas and discovered patterns
- Strategy definitions and backtest results
- Application metadata and caches

### 1.2 Goals

1. **High Performance**: Query 1M+ candles in < 1 second
2. **Durability**: No data loss on crash or power failure
3. **Portability**: Single file database for easy backup/migration
4. **Testability**: Repository pattern with in-memory test implementations

---

## 2. Architecture

### 2.1 Database Choice: DuckDB

**Why DuckDB over SQLite**:
| Feature | DuckDB | SQLite |
|---------|--------|--------|
| Columnar Storage | Yes | No |
| Vectorized Queries | Yes | No |
| Time-series Performance | Excellent | Moderate |
| Pandas Integration | Native | Via sqlite3 |
| OLAP Workloads | Optimized | Not optimized |

**Trade-offs**:
- DuckDB is newer (less battle-tested)
- Larger binary size
- Less widespread tooling

### 2.2 Database Schema

```sql
-- Market data tables
CREATE TABLE symbols (
    id INTEGER PRIMARY KEY,
    code VARCHAR(20) NOT NULL UNIQUE,
    name VARCHAR(100) NOT NULL,
    market VARCHAR(10) NOT NULL,  -- KOSPI, KOSDAQ, ETF
    sector VARCHAR(50),
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE candles (
    symbol_id INTEGER NOT NULL,
    timeframe VARCHAR(10) NOT NULL,  -- 1m, 5m, 15m, 1h, 1d, 1w, 1M
    timestamp TIMESTAMP NOT NULL,
    open DECIMAL(18, 4) NOT NULL,
    high DECIMAL(18, 4) NOT NULL,
    low DECIMAL(18, 4) NOT NULL,
    close DECIMAL(18, 4) NOT NULL,
    volume BIGINT NOT NULL,
    PRIMARY KEY (symbol_id, timeframe, timestamp),
    FOREIGN KEY (symbol_id) REFERENCES symbols(id)
);

-- Formulas and patterns
CREATE TABLE formulas (
    id INTEGER PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    expression TEXT NOT NULL,
    description TEXT,
    category VARCHAR(50),  -- scan, entry, exit, stop_loss
    tags TEXT,  -- JSON array
    version INTEGER DEFAULT 1,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE formula_parameters (
    id INTEGER PRIMARY KEY,
    formula_id INTEGER NOT NULL,
    name VARCHAR(50) NOT NULL,
    data_type VARCHAR(20) NOT NULL,  -- int, float, string
    default_value TEXT,
    min_value TEXT,
    max_value TEXT,
    FOREIGN KEY (formula_id) REFERENCES formulas(id)
);

-- Strategies and results
CREATE TABLE strategies (
    id INTEGER PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    entry_formula_id INTEGER,
    exit_formula_id INTEGER,
    stop_loss_formula_id INTEGER,
    take_profit_pct DECIMAL(5, 2),
    position_size_pct DECIMAL(5, 2),
    max_positions INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (entry_formula_id) REFERENCES formulas(id),
    FOREIGN KEY (exit_formula_id) REFERENCES formulas(id),
    FOREIGN KEY (stop_loss_formula_id) REFERENCES formulas(id)
);

CREATE TABLE backtest_results (
    id INTEGER PRIMARY KEY,
    strategy_id INTEGER NOT NULL,
    run_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    initial_capital DECIMAL(18, 2) NOT NULL,
    final_capital DECIMAL(18, 2) NOT NULL,
    total_return_pct DECIMAL(10, 4),
    cagr DECIMAL(10, 4),
    sharpe_ratio DECIMAL(10, 4),
    max_drawdown_pct DECIMAL(10, 4),
    win_rate DECIMAL(5, 4),
    profit_factor DECIMAL(10, 4),
    total_trades INTEGER,
    parameters TEXT,  -- JSON of parameter values
    FOREIGN KEY (strategy_id) REFERENCES strategies(id)
);

CREATE TABLE trades (
    id INTEGER PRIMARY KEY,
    backtest_id INTEGER,
    paper_session_id INTEGER,
    live_session_id INTEGER,
    symbol_id INTEGER NOT NULL,
    side VARCHAR(10) NOT NULL,  -- BUY, SELL
    entry_time TIMESTAMP NOT NULL,
    entry_price DECIMAL(18, 4) NOT NULL,
    exit_time TIMESTAMP,
    exit_price DECIMAL(18, 4),
    quantity INTEGER NOT NULL,
    pnl DECIMAL(18, 2),
    pnl_pct DECIMAL(10, 4),
    exit_reason VARCHAR(50),  -- signal, stop_loss, take_profit
    FOREIGN KEY (backtest_id) REFERENCES backtest_results(id),
    FOREIGN KEY (symbol_id) REFERENCES symbols(id)
);

-- Indexes for performance
CREATE INDEX idx_candles_symbol_timeframe ON candles(symbol_id, timeframe);
CREATE INDEX idx_candles_timestamp ON candles(timestamp);
CREATE INDEX idx_formulas_category ON formulas(category);
CREATE INDEX idx_trades_backtest ON trades(backtest_id);
```

### 2.3 Repository Layer

```
┌─────────────────────────────────────────────────────────┐
│                    Domain Layer                          │
│  ┌─────────────────────────────────────────────────┐   │
│  │ ISymbolRepository, ICandleRepository, etc.       │   │
│  │ (Abstract interfaces)                            │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│                 Infrastructure Layer                     │
│  ┌──────────────────┐    ┌──────────────────────────┐  │
│  │ DuckDBSymbolRepo │    │ InMemorySymbolRepository │  │
│  │ (Production)     │    │ (Testing)                │  │
│  └──────────────────┘    └──────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

---

## 3. Domain Entities

### 3.1 Symbol (Entity)

```python
@dataclass
class Symbol:
    """Stock symbol entity"""
    id: int
    code: str
    name: str
    market: Market  # Enum: KOSPI, KOSDAQ, ETF
    sector: Optional[str] = None
    is_active: bool = True

    def __post_init__(self):
        if not self.code:
            raise ValueError("Symbol code is required")
```

### 3.2 Candle (Value Object)

```python
@dataclass(frozen=True)
class Candle:
    """OHLCV candle - immutable value object"""
    timestamp: datetime
    open: Decimal
    high: Decimal
    low: Decimal
    close: Decimal
    volume: int

    @property
    def is_bullish(self) -> bool:
        return self.close > self.open

    @property
    def body_size(self) -> Decimal:
        return abs(self.close - self.open)

    @property
    def range(self) -> Decimal:
        return self.high - self.low
```

### 3.3 CandleSeries (Aggregate)

```python
class CandleSeries:
    """Collection of candles for a symbol/timeframe - Aggregate Root"""

    def __init__(
        self,
        symbol: Symbol,
        timeframe: Timeframe,
        candles: list[Candle]
    ):
        self._symbol = symbol
        self._timeframe = timeframe
        self._candles = sorted(candles, key=lambda c: c.timestamp)
        self._df: Optional[pd.DataFrame] = None

    @property
    def as_dataframe(self) -> pd.DataFrame:
        """Lazy conversion to pandas DataFrame for calculations"""
        if self._df is None:
            self._df = pd.DataFrame([
                asdict(c) for c in self._candles
            ])
            self._df.set_index('timestamp', inplace=True)
        return self._df

    def slice(self, start: datetime, end: datetime) -> 'CandleSeries':
        """Return subset of candles"""
        filtered = [c for c in self._candles
                   if start <= c.timestamp <= end]
        return CandleSeries(self._symbol, self._timeframe, filtered)
```

### 3.4 Formula (Entity)

```python
@dataclass
class Formula:
    """Scan/trading formula entity"""
    id: int
    name: str
    expression: str
    category: FormulaCategory  # SCAN, ENTRY, EXIT, STOP_LOSS
    description: Optional[str] = None
    tags: list[str] = field(default_factory=list)
    parameters: list[FormulaParameter] = field(default_factory=list)
    version: int = 1

    def with_parameters(self, **kwargs) -> str:
        """Return expression with parameters substituted"""
        result = self.expression
        for param in self.parameters:
            value = kwargs.get(param.name, param.default_value)
            result = result.replace(f":{param.name}", str(value))
        return result
```

---

## 4. Repository Interfaces

### 4.1 ICandleRepository

```python
from abc import ABC, abstractmethod

class ICandleRepository(ABC):
    """Repository interface for candle data"""

    @abstractmethod
    def save_many(self, symbol_id: int, timeframe: str,
                  candles: list[Candle]) -> int:
        """Save multiple candles, return count saved"""
        ...

    @abstractmethod
    def get_range(self, symbol_id: int, timeframe: str,
                  start: datetime, end: datetime) -> list[Candle]:
        """Get candles in date range"""
        ...

    @abstractmethod
    def get_latest(self, symbol_id: int, timeframe: str,
                   count: int = 1) -> list[Candle]:
        """Get most recent candles"""
        ...

    @abstractmethod
    def get_coverage(self, symbol_id: int, timeframe: str
                    ) -> tuple[Optional[datetime], Optional[datetime]]:
        """Get date range of stored data"""
        ...

    @abstractmethod
    def count(self, symbol_id: int, timeframe: str) -> int:
        """Count candles for symbol/timeframe"""
        ...

    @abstractmethod
    def delete_range(self, symbol_id: int, timeframe: str,
                     start: datetime, end: datetime) -> int:
        """Delete candles in range, return count deleted"""
        ...
```

### 4.2 ISymbolRepository

```python
class ISymbolRepository(ABC):
    """Repository interface for symbols"""

    @abstractmethod
    def save(self, symbol: Symbol) -> Symbol:
        """Save or update symbol"""
        ...

    @abstractmethod
    def get_by_code(self, code: str) -> Optional[Symbol]:
        """Find symbol by code"""
        ...

    @abstractmethod
    def get_by_market(self, market: Market) -> list[Symbol]:
        """Find all symbols in market"""
        ...

    @abstractmethod
    def get_all_active(self) -> list[Symbol]:
        """Get all active symbols"""
        ...

    @abstractmethod
    def search(self, query: str) -> list[Symbol]:
        """Search symbols by code or name"""
        ...
```

### 4.3 IFormulaRepository

```python
class IFormulaRepository(ABC):
    """Repository interface for formulas"""

    @abstractmethod
    def save(self, formula: Formula) -> Formula:
        """Save or update formula"""
        ...

    @abstractmethod
    def get_by_id(self, formula_id: int) -> Optional[Formula]:
        """Find formula by ID"""
        ...

    @abstractmethod
    def get_by_category(self, category: FormulaCategory) -> list[Formula]:
        """Find formulas by category"""
        ...

    @abstractmethod
    def search(self, query: str) -> list[Formula]:
        """Search formulas by name or tags"""
        ...

    @abstractmethod
    def delete(self, formula_id: int) -> bool:
        """Delete formula"""
        ...
```

---

## 5. Infrastructure Implementation

### 5.1 DuckDB Connection Manager

```python
class DatabaseManager:
    """Manages DuckDB connection lifecycle"""

    def __init__(self, db_path: Path):
        self._db_path = db_path
        self._connection: Optional[duckdb.DuckDBPyConnection] = None

    def connect(self) -> duckdb.DuckDBPyConnection:
        if self._connection is None:
            self._connection = duckdb.connect(str(self._db_path))
        return self._connection

    def close(self) -> None:
        if self._connection:
            self._connection.close()
            self._connection = None

    def execute(self, query: str, params: tuple = ()) -> Any:
        return self.connect().execute(query, params)

    def executemany(self, query: str, params: list[tuple]) -> Any:
        return self.connect().executemany(query, params)

    def __enter__(self):
        return self.connect()

    def __exit__(self, *args):
        self.close()
```

### 5.2 DuckDB Candle Repository

```python
class DuckDBCandleRepository(ICandleRepository):
    """DuckDB implementation of candle repository"""

    def __init__(self, db_manager: DatabaseManager):
        self._db = db_manager

    def save_many(self, symbol_id: int, timeframe: str,
                  candles: list[Candle]) -> int:
        if not candles:
            return 0

        # Use INSERT OR REPLACE for upsert behavior
        query = """
            INSERT OR REPLACE INTO candles
            (symbol_id, timeframe, timestamp, open, high, low, close, volume)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        """
        params = [
            (symbol_id, timeframe, c.timestamp,
             float(c.open), float(c.high), float(c.low),
             float(c.close), c.volume)
            for c in candles
        ]
        self._db.executemany(query, params)
        return len(candles)

    def get_range(self, symbol_id: int, timeframe: str,
                  start: datetime, end: datetime) -> list[Candle]:
        query = """
            SELECT timestamp, open, high, low, close, volume
            FROM candles
            WHERE symbol_id = ? AND timeframe = ?
              AND timestamp >= ? AND timestamp <= ?
            ORDER BY timestamp
        """
        result = self._db.execute(query, (symbol_id, timeframe, start, end))
        return [
            Candle(
                timestamp=row[0],
                open=Decimal(str(row[1])),
                high=Decimal(str(row[2])),
                low=Decimal(str(row[3])),
                close=Decimal(str(row[4])),
                volume=row[5]
            )
            for row in result.fetchall()
        ]
```

### 5.3 In-Memory Repository (Testing)

```python
class InMemoryCandleRepository(ICandleRepository):
    """In-memory implementation for testing"""

    def __init__(self):
        self._data: dict[tuple[int, str], list[Candle]] = {}

    def save_many(self, symbol_id: int, timeframe: str,
                  candles: list[Candle]) -> int:
        key = (symbol_id, timeframe)
        if key not in self._data:
            self._data[key] = []

        # Remove duplicates and add new
        existing_timestamps = {c.timestamp for c in self._data[key]}
        new_candles = [c for c in candles
                      if c.timestamp not in existing_timestamps]
        self._data[key].extend(new_candles)
        self._data[key].sort(key=lambda c: c.timestamp)
        return len(candles)

    def get_range(self, symbol_id: int, timeframe: str,
                  start: datetime, end: datetime) -> list[Candle]:
        key = (symbol_id, timeframe)
        if key not in self._data:
            return []
        return [c for c in self._data[key]
               if start <= c.timestamp <= end]
```

---

## 6. Data Management Use Cases

### 6.1 Candle Import Use Case

```python
class ImportCandlesUseCase:
    """Use case for importing candle data"""

    def __init__(
        self,
        candle_repo: ICandleRepository,
        symbol_repo: ISymbolRepository
    ):
        self._candle_repo = candle_repo
        self._symbol_repo = symbol_repo

    def execute(self, request: ImportCandlesRequest) -> ImportCandlesResult:
        # Validate symbol exists
        symbol = self._symbol_repo.get_by_code(request.symbol_code)
        if not symbol:
            raise SymbolNotFoundError(request.symbol_code)

        # Check for existing data
        existing_start, existing_end = self._candle_repo.get_coverage(
            symbol.id, request.timeframe
        )

        # Filter out already imported candles if incremental
        candles_to_import = request.candles
        if request.incremental and existing_end:
            candles_to_import = [
                c for c in request.candles
                if c.timestamp > existing_end
            ]

        # Save candles
        count = self._candle_repo.save_many(
            symbol.id, request.timeframe, candles_to_import
        )

        return ImportCandlesResult(
            symbol_code=request.symbol_code,
            imported_count=count,
            skipped_count=len(request.candles) - count
        )
```

---

## 7. Tasks Breakdown

| Task ID | Title | Effort | Dependencies |
|---------|-------|--------|--------------|
| E02-F01-T01 | Create domain entities (Symbol, Candle, Formula) | M | E01 |
| E02-F01-T02 | Create value objects and enums | S | T01 |
| E02-F01-T03 | Implement CandleSeries aggregate | M | T01, T02 |
| E02-F02-T01 | Define repository interfaces | M | T01 |
| E02-F02-T02 | Implement InMemory repositories (testing) | M | F02-T01 |
| E02-F03-T01 | Create DatabaseManager for DuckDB | M | E01 |
| E02-F03-T02 | Implement database schema migrations | M | F03-T01 |
| E02-F03-T03 | Implement DuckDBCandleRepository | L | F02-T01, F03-T01 |
| E02-F03-T04 | Implement DuckDBSymbolRepository | M | F02-T01, F03-T01 |
| E02-F03-T05 | Implement DuckDBFormulaRepository | M | F02-T01, F03-T01 |
| E02-F04-T01 | Create ImportCandlesUseCase | M | F02, F03 |
| E02-F04-T02 | Create ExportCandlesUseCase | M | F02, F03 |
| E02-F04-T03 | Create data validation utilities | M | T01 |

---

## 8. Acceptance Criteria

### 8.1 Performance

- [ ] Insert 100,000 candles in < 5 seconds
- [ ] Query 1,000,000 candles in < 1 second
- [ ] Database file size < 500MB for 5 years of daily data (all symbols)

### 8.2 Reliability

- [ ] No data corruption on application crash
- [ ] Graceful handling of concurrent access
- [ ] Automatic schema migration on version upgrade

### 8.3 Testing

- [ ] All repository interfaces have in-memory implementations
- [ ] Unit tests use in-memory repositories
- [ ] Integration tests verify DuckDB implementations
- [ ] Test coverage > 85% for storage layer

---

## 9. TDD Approach

### 9.1 Test First Example

```python
# RED: Write failing test
class TestCandleRepository:
    def test_save_and_retrieve_candles(self):
        repo = InMemoryCandleRepository()
        candles = [
            Candle(datetime(2024, 1, 1), Decimal("100"), Decimal("105"),
                   Decimal("99"), Decimal("103"), 1000000),
            Candle(datetime(2024, 1, 2), Decimal("103"), Decimal("108"),
                   Decimal("102"), Decimal("107"), 1200000),
        ]

        repo.save_many(symbol_id=1, timeframe="1d", candles=candles)

        result = repo.get_range(
            symbol_id=1, timeframe="1d",
            start=datetime(2024, 1, 1),
            end=datetime(2024, 1, 2)
        )

        assert len(result) == 2
        assert result[0].close == Decimal("103")
        assert result[1].volume == 1200000

# GREEN: Implement minimum code to pass
# REFACTOR: Clean up
```

### 9.2 Integration Test

```python
class TestDuckDBCandleRepository:
    @pytest.fixture
    def db_manager(self, tmp_path):
        db_path = tmp_path / "test.duckdb"
        manager = DatabaseManager(db_path)
        # Run migrations
        migrate(manager)
        yield manager
        manager.close()

    def test_candle_persistence(self, db_manager):
        repo = DuckDBCandleRepository(db_manager)
        # ... test actual database operations
```

---

## 10. References

- [DuckDB Python API](https://duckdb.org/docs/api/python/overview)
- [Repository Pattern](https://martinfowler.com/eaaCatalog/repository.html)
- PRD Section 5.1: Historical Data Collection
- Existing JTS: Portfolio entity patterns
