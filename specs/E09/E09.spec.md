# Epic E09: Strategy Builder

## Metadata

| Field | Value |
|-------|-------|
| Epic ID | E09 |
| Title | Strategy Builder |
| Status | Draft |
| Platform | Cross-platform |
| Dependencies | E05 (DSL), E08 (Pattern Discovery) |
| PRD Sections | 5.4 |

---

## 1. Overview

### 1.1 Purpose

Compose discovered rules into complete trading strategies:
- Combine entry, exit, and stop-loss rules
- Configure position sizing and risk management
- Organize strategies in a library
- Version control for strategy modifications

### 1.2 Goals

1. **Composable**: Mix and match rules from library
2. **Complete**: All parameters needed for execution
3. **Validated**: Syntax and logic validation
4. **Versioned**: Track changes over time

---

## 2. Architecture

### 2.1 Strategy Components (PRD 5.4.1)

```
┌─────────────────────────────────────────────────────────────┐
│                      TRADING STRATEGY                        │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  Entry Rule:     rsi(14) < 30 AND close > sma(close, 20)    │
│                                                              │
│  Exit Rule:      rsi(14) > 70 OR close < sma(close, 20)     │
│                                                              │
│  Stop-Loss:      -2% from entry price                        │
│                                                              │
│  Take-Profit:    +6% from entry price                        │
│                                                              │
│  Position Size:  10% of portfolio per trade                  │
│                                                              │
│  Max Positions:  5 concurrent                                │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 Component Structure

```
src/presentation/views/strategy/
├── strategy_view.py            # Main strategy view
├── strategy_list_widget.py     # Strategy library list
├── strategy_editor_widget.py   # Strategy composition editor
├── rule_selector_widget.py     # Rule selection from library
├── risk_config_widget.py       # Risk management config
└── strategy_preview_widget.py  # Strategy summary preview
```

---

## 3. Domain Model

### 3.1 Strategy Entity (Aggregate Root)

```python
@dataclass
class Strategy:
    """Complete trading strategy - Aggregate Root"""
    id: int
    name: str
    description: Optional[str]

    # Trading rules (from formula library)
    entry_rule: StrategyRule
    exit_rule: Optional[StrategyRule]
    stop_loss_rule: Optional[StrategyRule]

    # Risk management
    risk_config: RiskConfig

    # Metadata
    version: int = 1
    is_active: bool = True
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)

    def validate(self) -> list[ValidationError]:
        """Validate strategy completeness"""
        errors = []

        if not self.entry_rule:
            errors.append(ValidationError("Entry rule is required"))

        if not self.exit_rule and not self.stop_loss_rule:
            errors.append(ValidationError(
                "At least one exit method required (exit rule or stop-loss)"
            ))

        if self.risk_config.position_size_pct > 100:
            errors.append(ValidationError(
                "Position size cannot exceed 100%"
            ))

        return errors

@dataclass
class StrategyRule:
    """A rule within a strategy"""
    formula_id: Optional[int]  # Reference to formula library
    expression: str  # The actual DSL expression
    parameters: dict[str, Any] = field(default_factory=dict)

    @classmethod
    def from_formula(cls, formula: Formula, params: dict = None) -> 'StrategyRule':
        return cls(
            formula_id=formula.id,
            expression=formula.expression,
            parameters=params or {}
        )

    @classmethod
    def fixed_percentage(cls, percentage: float) -> 'StrategyRule':
        """Create fixed percentage rule (for stop-loss/take-profit)"""
        return cls(
            formula_id=None,
            expression=f"FIXED_PCT:{percentage}",
            parameters={'percentage': percentage}
        )

@dataclass
class RiskConfig:
    """Risk management configuration"""
    position_size_pct: float = 10.0  # % of portfolio per trade
    max_positions: int = 5  # Max concurrent positions
    stop_loss_pct: Optional[float] = None  # Fixed stop-loss %
    take_profit_pct: Optional[float] = None  # Fixed take-profit %
    max_daily_loss_pct: Optional[float] = None  # Daily loss limit
    trailing_stop_pct: Optional[float] = None  # Trailing stop %
```

### 3.2 Strategy Version

```python
@dataclass
class StrategyVersion:
    """Track strategy changes"""
    id: int
    strategy_id: int
    version: int
    snapshot: dict  # Serialized strategy state
    change_description: str
    created_at: datetime = field(default_factory=datetime.utcnow)
    created_by: Optional[str] = None
```

---

## 4. Use Cases

### 4.1 Create Strategy

```python
class CreateStrategyUseCase:
    """Create a new trading strategy"""

    def __init__(
        self,
        strategy_repo: IStrategyRepository,
        formula_service: FormulaService
    ):
        self._repo = strategy_repo
        self._formula_service = formula_service

    async def execute(self, request: CreateStrategyRequest) -> Strategy:
        # Build entry rule
        entry_rule = await self._build_rule(request.entry_rule)

        # Build exit rule
        exit_rule = None
        if request.exit_rule:
            exit_rule = await self._build_rule(request.exit_rule)

        # Build stop-loss rule
        stop_loss_rule = None
        if request.stop_loss_rule:
            stop_loss_rule = await self._build_rule(request.stop_loss_rule)
        elif request.risk_config.stop_loss_pct:
            stop_loss_rule = StrategyRule.fixed_percentage(
                request.risk_config.stop_loss_pct
            )

        # Create strategy
        strategy = Strategy(
            id=0,
            name=request.name,
            description=request.description,
            entry_rule=entry_rule,
            exit_rule=exit_rule,
            stop_loss_rule=stop_loss_rule,
            risk_config=request.risk_config
        )

        # Validate
        errors = strategy.validate()
        if errors:
            raise StrategyValidationError(errors)

        # Save
        return await self._repo.save(strategy)

    async def _build_rule(self, rule_request: RuleRequest) -> StrategyRule:
        """Build rule from request"""
        if rule_request.formula_id:
            # Load from formula library
            formula = await self._formula_service.get_by_id(rule_request.formula_id)
            return StrategyRule.from_formula(formula, rule_request.parameters)
        else:
            # Custom expression
            self._formula_service.validate(rule_request.expression)
            return StrategyRule(
                formula_id=None,
                expression=rule_request.expression,
                parameters=rule_request.parameters
            )
```

### 4.2 Update Strategy with Version

```python
class UpdateStrategyUseCase:
    """Update strategy with versioning"""

    def __init__(
        self,
        strategy_repo: IStrategyRepository,
        version_repo: IStrategyVersionRepository
    ):
        self._repo = strategy_repo
        self._version_repo = version_repo

    async def execute(
        self,
        strategy_id: int,
        updates: StrategyUpdate,
        change_description: str
    ) -> Strategy:
        # Load existing
        strategy = await self._repo.get_by_id(strategy_id)
        if not strategy:
            raise StrategyNotFoundError(strategy_id)

        # Create version snapshot before update
        await self._create_version_snapshot(strategy, change_description)

        # Apply updates
        if updates.name:
            strategy.name = updates.name
        if updates.entry_rule:
            strategy.entry_rule = updates.entry_rule
        if updates.exit_rule:
            strategy.exit_rule = updates.exit_rule
        if updates.stop_loss_rule:
            strategy.stop_loss_rule = updates.stop_loss_rule
        if updates.risk_config:
            strategy.risk_config = updates.risk_config

        strategy.version += 1
        strategy.updated_at = datetime.utcnow()

        # Validate
        errors = strategy.validate()
        if errors:
            raise StrategyValidationError(errors)

        return await self._repo.save(strategy)

    async def _create_version_snapshot(
        self,
        strategy: Strategy,
        description: str
    ):
        """Save strategy version before update"""
        version = StrategyVersion(
            id=0,
            strategy_id=strategy.id,
            version=strategy.version,
            snapshot=asdict(strategy),
            change_description=description
        )
        await self._version_repo.save(version)
```

### 4.3 Strategy Library

```python
class StrategyLibraryUseCase:
    """Manage strategy library"""

    def __init__(self, strategy_repo: IStrategyRepository):
        self._repo = strategy_repo

    async def list_all(self) -> list[StrategySummary]:
        """List all strategies with summary"""
        strategies = await self._repo.get_all()
        return [
            StrategySummary(
                id=s.id,
                name=s.name,
                entry_rule_preview=self._preview(s.entry_rule.expression),
                has_exit_rule=s.exit_rule is not None,
                has_stop_loss=s.stop_loss_rule is not None,
                position_size_pct=s.risk_config.position_size_pct,
                version=s.version,
                is_active=s.is_active
            )
            for s in strategies
        ]

    async def duplicate(self, strategy_id: int, new_name: str) -> Strategy:
        """Duplicate an existing strategy"""
        original = await self._repo.get_by_id(strategy_id)
        if not original:
            raise StrategyNotFoundError(strategy_id)

        copy = Strategy(
            id=0,
            name=new_name,
            description=f"Copy of {original.name}",
            entry_rule=original.entry_rule,
            exit_rule=original.exit_rule,
            stop_loss_rule=original.stop_loss_rule,
            risk_config=original.risk_config
        )

        return await self._repo.save(copy)

    def _preview(self, expression: str, max_length: int = 50) -> str:
        """Truncate expression for preview"""
        if len(expression) <= max_length:
            return expression
        return expression[:max_length - 3] + "..."
```

---

## 5. UI Components

### 5.1 Strategy Editor (PRD 5.4.2, 5.4.3)

```
┌─────────────────────────────────────────────────────────────────────────┐
│ Strategy Builder                                                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│ Strategy Name: [RSI Momentum Strategy                    ]               │
│ Description:   [Buy oversold stocks with momentum confirmation          ]│
│                                                                          │
│ ┌─────────────────────────────────────────────────────────────────────┐ │
│ │ Entry Rule                                            [규칙 선택 ▼] │ │
│ │                                                                       │ │
│ │ ┌─────────────────────────────────────────────────────────────────┐ │ │
│ │ │ rsi(14) < 30 AND close > sma(close, 20)                         │ │ │
│ │ └─────────────────────────────────────────────────────────────────┘ │ │
│ │ Parameters: RSI Period [14]  SMA Period [20]  RSI Threshold [30]   │ │
│ └─────────────────────────────────────────────────────────────────────┘ │
│                                                                          │
│ ┌─────────────────────────────────────────────────────────────────────┐ │
│ │ Exit Rule                                             [규칙 선택 ▼] │ │
│ │                                                                       │ │
│ │ ┌─────────────────────────────────────────────────────────────────┐ │ │
│ │ │ rsi(14) > 70 OR close < sma(close, 20)                          │ │ │
│ │ └─────────────────────────────────────────────────────────────────┘ │ │
│ └─────────────────────────────────────────────────────────────────────┘ │
│                                                                          │
│ ┌─────────────────────────────────────────────────────────────────────┐ │
│ │ Risk Management                                                      │ │
│ │                                                                       │ │
│ │ Stop-Loss:        [-2.0]% from entry price                           │ │
│ │ Take-Profit:      [+6.0]% from entry price                           │ │
│ │ Position Size:    [10]% of portfolio per trade                       │ │
│ │ Max Positions:    [5] concurrent trades                              │ │
│ │ Max Daily Loss:   [5.0]% (optional)                                  │ │
│ └─────────────────────────────────────────────────────────────────────┘ │
│                                                                          │
│                           [저장]  [백테스트 실행]  [페이퍼 트레이딩]    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 5.2 Rule Selector Dialog

```python
class RuleSelectorDialog(QDialog):
    """Select rule from library or create custom"""

    rule_selected = Signal(StrategyRule)

    def __init__(
        self,
        formula_repo: IFormulaRepository,
        category: FormulaCategory,
        parent=None
    ):
        super().__init__(parent)
        self._repo = formula_repo
        self._category = category
        self._setup_ui()
        self._load_rules()

    def _setup_ui(self):
        layout = QVBoxLayout(self)

        # Tabs: Library / Custom
        self._tabs = QTabWidget()

        # Library tab
        library_widget = QWidget()
        library_layout = QVBoxLayout(library_widget)

        self._search = QLineEdit()
        self._search.setPlaceholderText("Search rules...")
        library_layout.addWidget(self._search)

        self._rule_list = QListWidget()
        self._rule_list.itemDoubleClicked.connect(self._on_rule_selected)
        library_layout.addWidget(self._rule_list)

        self._tabs.addTab(library_widget, "Rule Library")

        # Custom tab
        custom_widget = QWidget()
        custom_layout = QVBoxLayout(custom_widget)

        self._editor = FormulaEditorWidget()
        custom_layout.addWidget(self._editor)

        self._tabs.addTab(custom_widget, "Custom Rule")

        layout.addWidget(self._tabs)

        # Buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel
        )
        buttons.accepted.connect(self._on_accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

    async def _load_rules(self):
        """Load rules from repository"""
        formulas = await self._repo.get_by_category(self._category)

        self._rule_list.clear()
        for formula in formulas:
            item = QListWidgetItem(formula.name)
            item.setData(Qt.UserRole, formula)
            item.setToolTip(formula.expression)
            self._rule_list.addItem(item)
```

### 5.3 Risk Config Widget

```python
class RiskConfigWidget(QWidget):
    """Risk management configuration"""

    config_changed = Signal(RiskConfig)

    def __init__(self, parent=None):
        super().__init__(parent)
        self._setup_ui()

    def _setup_ui(self):
        layout = QFormLayout(self)

        # Stop-loss
        self._stop_loss_spin = QDoubleSpinBox()
        self._stop_loss_spin.setRange(-50, 0)
        self._stop_loss_spin.setValue(-2.0)
        self._stop_loss_spin.setSuffix("%")
        layout.addRow("Stop-Loss:", self._stop_loss_spin)

        # Take-profit
        self._take_profit_spin = QDoubleSpinBox()
        self._take_profit_spin.setRange(0, 100)
        self._take_profit_spin.setValue(6.0)
        self._take_profit_spin.setSuffix("%")
        layout.addRow("Take-Profit:", self._take_profit_spin)

        # Position size
        self._position_size_spin = QDoubleSpinBox()
        self._position_size_spin.setRange(1, 100)
        self._position_size_spin.setValue(10.0)
        self._position_size_spin.setSuffix("%")
        layout.addRow("Position Size:", self._position_size_spin)

        # Max positions
        self._max_positions_spin = QSpinBox()
        self._max_positions_spin.setRange(1, 50)
        self._max_positions_spin.setValue(5)
        layout.addRow("Max Positions:", self._max_positions_spin)

        # Max daily loss
        self._max_daily_loss_spin = QDoubleSpinBox()
        self._max_daily_loss_spin.setRange(0, 100)
        self._max_daily_loss_spin.setValue(5.0)
        self._max_daily_loss_spin.setSuffix("%")
        self._max_daily_loss_spin.setSpecialValueText("No limit")
        layout.addRow("Max Daily Loss:", self._max_daily_loss_spin)

        # Connect signals
        for widget in [self._stop_loss_spin, self._take_profit_spin,
                      self._position_size_spin, self._max_positions_spin,
                      self._max_daily_loss_spin]:
            widget.valueChanged.connect(self._emit_config)

    def get_config(self) -> RiskConfig:
        """Get current risk configuration"""
        return RiskConfig(
            position_size_pct=self._position_size_spin.value(),
            max_positions=self._max_positions_spin.value(),
            stop_loss_pct=abs(self._stop_loss_spin.value()) or None,
            take_profit_pct=self._take_profit_spin.value() or None,
            max_daily_loss_pct=self._max_daily_loss_spin.value() or None
        )

    def set_config(self, config: RiskConfig):
        """Set risk configuration"""
        self._stop_loss_spin.setValue(-(config.stop_loss_pct or 0))
        self._take_profit_spin.setValue(config.take_profit_pct or 0)
        self._position_size_spin.setValue(config.position_size_pct)
        self._max_positions_spin.setValue(config.max_positions)
        self._max_daily_loss_spin.setValue(config.max_daily_loss_pct or 0)
```

---

## 6. Tasks Breakdown

| Task ID | Title | Effort | Dependencies |
|---------|-------|--------|--------------|
| E09-F01-T01 | Define Strategy entity (aggregate root) | M | E05 |
| E09-F01-T02 | Define StrategyRule and RiskConfig | M | T01 |
| E09-F01-T03 | Define StrategyVersion for versioning | S | T01 |
| E09-F02-T01 | Implement CreateStrategyUseCase | M | F01 |
| E09-F02-T02 | Implement UpdateStrategyUseCase with versioning | M | F01 |
| E09-F02-T03 | Implement StrategyLibraryUseCase | M | F01 |
| E09-F03-T01 | Implement IStrategyRepository interface | S | F01 |
| E09-F03-T02 | Implement DuckDBStrategyRepository | M | F03-T01 |
| E09-F04-T01 | Create StrategyView main layout | M | E01 |
| E09-F04-T02 | Create StrategyListWidget | M | F04-T01 |
| E09-F04-T03 | Create StrategyEditorWidget | L | F04-T01 |
| E09-F04-T04 | Create RuleSelectorDialog | M | F04-T03 |
| E09-F04-T05 | Create RiskConfigWidget | M | F04-T03 |

---

## 7. Acceptance Criteria

### 7.1 Functional

- [ ] Create strategy with entry, exit, and stop-loss rules
- [ ] Select rules from formula library
- [ ] Configure all risk parameters
- [ ] Save and load strategies
- [ ] Version control for strategy changes

### 7.2 Validation

- [ ] Entry rule required
- [ ] At least one exit method required
- [ ] Position size between 1-100%
- [ ] Clear validation error messages

### 7.3 Testing

- [ ] Unit tests for Strategy validation
- [ ] Unit tests for use cases
- [ ] Integration tests with storage
- [ ] Test coverage > 80%

---

## 8. References

- PRD Section 5.4: Strategy Builder
- E05: DSL Parser & Evaluator
- E08: Pattern Discovery (rule source)
